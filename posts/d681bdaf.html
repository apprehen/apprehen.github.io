<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>TypeScript语言学习 | 月晕</title><meta name="keywords" content="TypeScript,JavaScript,前端,前端开发"><meta name="author" content="月晕"><meta name="copyright" content="月晕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="TypeScript语言学习"><meta name="application-name" content="TypeScript语言学习"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="TypeScript语言学习"><meta property="og:url" content="https://blog.yueyun.site/posts/d681bdaf.html"><meta property="og:site_name" content="月晕"><meta property="og:description" content="TypeScript语言学习"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/liang.jpg"><meta property="article:author" content="月晕"><meta property="article:tag" content="JS,前端,前端开发,TS,TypeScript,Node,Node.js,Nodejs,Node,后端"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/liang.jpg"><meta name="description" content="TypeScript语言学习"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.yueyun.site/posts/d681bdaf"><link rel="preconnect" href="//cdn.cbd.int"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><meta name="google-site-verification" content="QmqYgcPLCjEZmEbdJVKduTaxnvd3OFJRyp3BLB2f0VQ"><meta name="baidu-site-verification" content="codeva-XPqAkKFOID"><meta name="msvalidate.01" content="xxx"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload='this.media="all"'><script async src="https://www.googletagmanager.com/gtag/js?id=G-W3DLGJMJDY"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-W3DLGJMJDY")</script><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"T^T","backTitle":"Ciallo~"},
  LA51: {"enable":true,"ck":"3GbfdCFGvNdWoQg1","LingQueMonitorID":"3GbfdCFGvNdWoQg1"},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://chat.yueyun.site',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🖥️ JavaScript爱好者","🔍 前沿技术追随者","🩵 吃饭睡觉看动漫","🔨 前端后端一把梭","🤓 玉玉郁郁第一名","🧟 间歇性发奋图强","😵 持续性混吃等死","🥰 欢迎找我来聊天"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 月晕","link":"链接: ","source":"来源: 月晕","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={configTitle:"月晕",title:"TypeScript语言学习",postAI:"",pageFillDescription:"TypeScript 简介, TypeScript 的特点, 基础类型, 布尔值, 数字, 字符串, 数组, 元祖 Tuple, 枚举, any, void, null 和 undefined, never, object, 类型断言, 变量声明, var 声明, 作用域规则, 捕获变量怪异之处, let 声明, 块作用域, 重定义及屏蔽, 块级作用域变量的获取, const 声明, let vs. const, 解构, 解构数组, 对象解构, 属性重命名, 默认值, 函数声明, 展开, 接口, 接口初探, 可选属性, 只读属性, readonly vs const, 额外的属性检查, 函数类型, 可索引的类型, 类类型, 实现接口, 类静态部分与实例部分的区别, 继承接口, 混合类型, 接口继承类, 类, 基本示例, 继承, 公共私有与受保护的修饰符, 默认为 public, 理解 private, 理解 protected, readonly 修饰符, 参数属性, 存取器, 静态属性, 抽象类, 高级技巧, 构造函数, 把类当做接口使用, 函数, 基本示例, 函数类型, 为函数定义类型, 书写完整函数类型, 推断类型, 可选参数和默认参数, 剩余参数, this, this 和箭头函数, this 参数, this 参数在回调函数里, 重载, 泛型, 基础示例, 使用泛型变量, 泛型类型, 泛型类, 泛型约束, 在泛型约束中使用类型参数, 类型推断, 类型推断, 基础, 最佳通用类型, 上下文类型, 高级类型, 交叉类型, 联合类型, 类型保护, 用户自定义的类型保护, typeof 类型保护, instanceof 类型保护, 可以为 null 的类型, 可选参数和可选属性, 类型保护和类型断言, 字符串字面量类型简介作为语言的超集为添加可选择的类型标注大大的增加了代码的可维护性和迭代性同时会不断的发展的新特性是现在流行的前端技术的特点始于归于终归是通过编译形成可以运行在任何浏览器上和等运行时环境中强大的工具构建大型应用程序类型允许开发者在开发应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构类型是可选的类型推断让一些类型的注释使你的代码的静态验证有很大的不同类型让你定义软件组件之间的接口和洞察现有库的行为先进的提供最新的和不断发展的特性包括那些来自年的和未来的提案中的特性比如异步功能和以帮助建立健壮的组件这些特性为高可信应用程序开发时是可用的但是会被编译成简洁的或更新版本的基础类型支持与几乎相同的数据类型此外还提供了实用的枚举类型方便我们使用布尔值最基本的数据类型就是简单的值在和里叫做其它语言中也一样数字和一样里的所有数字都是浮点数这些浮点数的类型是除了支持十进制和十六进制字面量还支持中引入的二进制和八进制字面量字符串程序的另一项基本操作是处理网页或服务器端的文本数据像其它语言里一样我们使用表示文本数据类型和一样可以使用双引号或单引号表示字符串你还可以使用模版字符串它可以定义多行文本和内嵌表达式这种字符串是被反引号包围并且以这种形式嵌入表达式这与下面定义的方式效果相同数组像一样可以操作数组元素有两种方式可以定义数组第一种可以在元素类型后面接上表示由此类型元素组成的一个数组第二种方式是使用数组泛型元素类型元祖元组类型允许表示一个已知元素数量和类型的数组各元素的类型不必相同比如你可以定义一对值分别为和类型的元组当访问一个已知索引的元素会得到正确的类型不存在方法当访问一个越界的元素会使用联合类型替代字符串可以赋值给类型和都有布尔不是类型联合类型是高级主题我们会在以后的章节里讨论它枚举类型是对标准数据类型的一个补充像等其它语言一样使用枚举类型可以为一组数值赋予友好的名字默认情况下从开始为元素编号你也可以手动的指定成员的数值例如我们将上面的例子改成从开始编号或者全部都采用手动赋值枚举类型提供的一个便利是你可以由枚举的值得到它的名字例如我们知道数值为但是不确定它映射到里的哪个名字我们可以查找相应的名字显示因为上面代码里它的值是有时候我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型这些值可能来自于动态的内容比如来自用户输入或第三方代码库这种情况下我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查那么我们可以使用类型来标记这些变量也可以是个在对现有代码进行改写的时候类型是十分有用的它允许你在编译时可选择地包含或移除类型检查并且当你只知道一部分数据的类型时类型也是有用的比如你有一个数组它包含了不同的类型的数据某种程度上来说类型像是与类型相反它表示没有任何类型当一个函数没有返回值时你通常会见到其返回值类型是声明一个类型的变量没有什么大用因为你只能为它赋予和和里和两者各自有自己的类型分别叫做和和相似它们的本身的类型用处不是很大默认情况下和是所有类型的子类型就是说你可以把和赋值给类型的变量然而当你指定了标记和只能赋值给和它们各自这能避免很多常见的问题也许在某处你想传入一个或或你可以使用联合类型再次说明稍后我们会介绍联合类型类型表示的是那些永不存在的值的类型例如类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型变量也可能是类型当它们被永不为真的类型保护所约束时类型是任何类型的子类型也可以赋值给任何类型然而没有类型是的子类型或可以赋值给类型除了本身之外即使也不可以赋值给下面是一些返回类型的函数返回的函数必须存在无法达到的终点推断的返回值类型为返回的函数必须存在无法达到的终点表示非原始类型也就是除或之外的类型使用类型就可以更好的表示像这样的例如类型断言有时候你会遇到这样的情况你会比更了解某个值的详细信息通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型通过类型断言这种方式可以告诉编译器相信我我知道自己在干什么类型断言好比其它语言里的类型转换但是不进行特殊的数据检查和解构它没有运行时的影响只是在编译阶段起作用会假设你程序员已经进行了必须的检查类型断言有两种形式其一是尖括号语法另一个为语法两种形式是等价的至于使用哪个大多数情况下是凭个人喜好然而当你在里使用时只有语法断言是被允许的变量声明和是里相对较新的变量声明方式在很多方面与是相似的但是可以帮助大家避免在里常见一些问题是对的一个增强它能阻止对一个变量再次赋值因为是的超集所以它本身就支持和下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替如果你已经对声明的怪异之处了如指掌那么你可以轻松地略过这节声明在的时代我们都是通过关键字定义变量大家都能理解这里定义了一个名为值为的变量我们也可以在函数内部定义变量并且我们也可以在其它函数内部访问相同的变量上面的例子是一个典型的闭包场景可以获取到函数里定义的变量每当被调用时它都可以访问到里的变量即使当在已经执行完后才被调用它仍然可以访问作用域规则声明有些奇怪的作用域规则看下面的例子有些同学可能要多看几遍这个例子变量是定义在语句里面但是我们却可以在语句的外面访问它这是因为声明的作用域是函数作用域函数参数也使用函数作用域这些作用域规则可能会引发一些错误其中之一就是多次声明同一个变量并不会报错这里很容易看出一些问题里层的循环会覆盖变量因为所有都引用相同的函数作用域内的变量有经验的开发者们很清楚这些问题可能在代码审查时漏掉引发无穷的麻烦捕获变量怪异之处猜一下下面的代码会返回什么答案是会在若干毫秒的延时后执行一个函数等待其它代码执行完毕很多程序员对这种行为已经很熟悉了但如果你很不解也没有关系因为你并不是一个人大多数人期望输出结果是这样我们传给的每一个函数表达式实际上都引用了相同作用域里的同一个让我们花点时间思考一下这是为什么在若干毫秒后执行一个函数并且是在循环结束后循环结束后的值为所以当函数被调用的时候它会打印出一个通常的解决方法是使用立即执行的函数表达式来捕获每次迭代时的值这种奇怪的形式我们已经司空见惯了参数会覆盖循环里的但是因为我们起了同样的名字所以我们不用怎么改循环体里的代码声明现在你已经知道了存在一些问题这恰好说明了为什么用语句来声明变量除了名字不同外与的写法一致主要的区别不在语法上而是语义我们接下来会深入研究块作用域当用声明一个变量它使用的是块作用域不同于使用声明的变量那样可以在包含它们的函数外访问块作用域变量在包含它们的块或循环之外是不能访问的仍然能访问到在这里不存在这里我们定义了个变量和的作用域是函数体内而的作用域是语句块里在语句里声明的变量也具有同样的作用域规则在这里不存在拥有块级作用域的变量的另一个特点是它们不能在被声明之前读或写虽然这些变量始终存在于它们的作用域里但在直到声明它的代码之前的区域都属于暂时性死区它只是用来说明我们不能在语句之前访问它们幸运的是可以告诉我们这些信息注意一点我们仍然可以在一个拥有块作用域变量被声明前获取它只是我们不能在变量声明前去调用那个函数如果生成代码目标为现代的运行时会抛出一个错误然而现今是不会报错的不能在被声明前调用运行时应该抛出错误关于暂时性死区的更多信息查看这里重定义及屏蔽我们提过使用声明时它不在乎你声明多少次你只会得到个在上面的例子里所有的声明实际上都引用一个相同的并且这是完全有效的代码但这经常会成为的来源幸运的是的声明就不会这么宽松了错误不能在个作用域里多次声明并不是要求两个均是块级作用域的声明才会给出一个错误的警告干扰参数声明不能同时具有的两个声明并不是说块级作用域变量不能用函数作用域变量来声明而是块级作用域变量需要在明显不同的块里声明在一个嵌套作用域里引入一个新名字的行为称做屏蔽它是一把双刃剑它可能会不小心地引入新问题同时也可能会解决一些错误例如假设我们现在用重写之前的函数这个版本的循环能得到正确的结果因为内层循环的可以屏蔽掉外层循环的通常来讲应该避免使用屏蔽因为我们需要写出清晰的代码同时也有些场景适合利用它你需要好好权衡一下块级作用域变量的获取每次进入一个作用域时会创建一个变量的环境就算作用域内代码已经执行完毕这个环境与其捕获的变量依然存在回想一下前面的例子我们最后需要使用立即执行的函数表达式来获取每次循环迭代里的状态实际上我们做的是为获取到的变量创建了一个新的变量环境这样做挺痛苦的但是幸运的是你不必在里这样做了当声明出现在循环体里时拥有完全不同的行为不仅是在循环里引入了一个新的变量环境而且针对每次迭代都会创建这样一个新作用域这就相当于我们在使用立即执行的函数表达式时做的事所以在例子里我们仅使用声明就可以了会输出与预料一致的结果声明声明是声明变量的另一种方式它们与声明相似但是就像它的名字所表达的它们被赋值后不能再改变换句话说它们拥有与相同的作用域规则但是不能对它们重新赋值这很好理解它们引用的值是不可变的除非你使用特殊的方法去避免实际上变量的内部状态是可修改的幸运的是允许你将对象的成员设置成只读的接口一章有详细说明现在我们有两种作用域相似的声明方式我们自然会问到底应该使用哪个与大多数泛泛的问题一样答案是依情况而定使用最小特权原则所有变量除了你计划去修改的都应该使用基本原则就是如果一个变量不需要对它写入那么其它使用这些代码的人也不能够写入它们并且要思考为什么会需要对这些变量重新赋值使用也可以让我们更容易的推测数据的流动解构解构数组最简单的解构莫过于数组的解构赋值了这创建了个命名变量和相当于使用了索引但更为方便作用于函数参数你可以在数组里使用语法创建剩余变量你也可以忽略你不关心的尾随元素或其它元素对象解构你也可以解构对象这通过和创建了和注意如果你不需要你可以忽略它你可以在对象里使用语法创建剩余变量属性重命名你也可以给属性以不同的名字这里的语法开始变得混乱你可以将读做作为方向是从左到右好像你写成了以下样子令人困惑的是这里的冒号不是指示类型的如果你想指定它的类型仍然需要在其后写上完整的模式默认值默认值可以让你在属性为时使用缺省值现在即使为函数的变量的属性和都会有值函数声明解构也能用于函数声明看以下简单的情况但是通常情况下更多的是指定默认值解构默认值有些棘手首先你需要在默认值之前设置其格式上面的代码是一个类型推断的例子将在后续章节介绍其次你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表要知道的定义有一个可选属性默认默认一旦传入参数则是必须的要小心使用解构从前面的例子可以看出就算是最简单的解构表达式也是难以理解的尤其当存在深层嵌套解构的时候就算这时没有堆叠在一起的重命名默认值和类型注解也是令人难以理解的解构表达式要尽量保持小而简单展开这会令的值为展开操作创建了和的一份浅拷贝它们不会被展开操作所改变你还可以展开对象的值为对象的展开比数组的展开要复杂的多像数组展开一样它是从左至右进行处理但结果仍为对象这就意味着出现在展开对象后面的属性会覆盖前面的属性因此如果我们修改上面的例子在结尾处进行展开的话那么里的属性会重写在这里这并不是我们想要的结果接口的核心原则之一是对值所具有的结构进行类型检查它有时被称做鸭式辨型法或结构性子类型化在里接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约接口初探下面通过一个简单示例来观察接口是如何工作的类型检查器会查看的调用有一个参数并要求这个对象参数有一个名为类型为的属性需要注意的是我们传入的对象参数实际上会包含很多属性但是编译器只会检查那些必需的属性是否存在以及其类型是否匹配然而有些时候却并不会这么宽松我们下面会稍做讲解下面我们重写上面的例子这次使用接口来描述必须包含一个属性且类型为接口就好比一个名字用来描述上面例子里的结构它代表了有一个属性且类型为的对象需要注意的是我们在这里并不能像在其它语言里一样说传给的对象实现了这个接口我们只会去关注值的外形只要传入的对象满足上面提到的必要条件那么它就是被允许的还有一点值得提的是类型检查器不会去检查属性的顺序只要相应的属性存在并且类型也是对的就可以可选属性接口里的属性不全都是必需的有些是只在某些条件下存在或者根本不存在例如给函数传入的参数对象中只有部分属性赋值了带有可选属性的接口与普通的接口定义差不多只是在可选属性名字定义的后面加一个符号可选属性的好处之一是可以对可能存在的属性进行预定义好处之二是可以捕获引用了不存在的属性时的错误比如我们故意将里的属性名拼错就会得到一个错误提示属性不存在于类型中只读属性一些对象属性只能在对象刚刚创建的时候修改其值你可以在属性名前用来指定只读属性你可以通过赋值一个对象字面量来构造一个赋值后和再也不能被改变了具有类型它与相似只是把所有可变方法去掉了因此可以确保数组创建后再也不能被修改上面代码的最后一行可以看到就算把整个赋值到一个普通数组也是不可以的但是你可以用类型断言重写最简单判断该用还是的方法是看要把它做为变量使用还是做为一个属性做为变量使用的话用若做为属性则使用额外的属性检查我们在第一个例子里使用了接口让我们传入到仅期望得到的函数里并且我们已经学过了可选属性然而天真地将这两者结合的话就会像在里那样搬起石头砸自己的脚比如拿例子来说注意传入的参数拼写为而不是在里这会默默地失败你可能会争辩这个程序已经正确地类型化了因为属性是兼容的不存在属性而且额外的属性是无意义的然而会认为这段代码可能存在对象字面量会被特殊对待而且会经过额外属性检查当将它们赋值给变量或作为参数传递的时候如果一个对象字面量存在任何目标类型不包含的属性时你会得到一个错误不存在于类型中绕开这些检查非常简单最简便的方法是使用类型断言然而最佳的方式是能够添加一个字符串索引签名前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性如果带有上面定义的类型的和属性并且还会带有任意数量的其它属性那么我们可以这样定义它我们稍后会讲到索引签名但在这我们要表示的是可以有任意数量的属性并且只要它们不是和那么就无所谓它们的类型是什么还有最后一种跳过这些检查的方式这可能会让你感到惊讶它就是将这个对象赋值给一个另一个变量因为不会经过额外属性检查所以编译器不会报错要留意在像上面一样的简单代码里你可能不应该去绕开这些检查对于包含方法和内部状态的复杂对象字面量来讲你可能需要使用这些技巧但是大多数额外属性检查错误是真正的也就是说你遇到了额外类型检查出的错误你应该去审查一下你的类型声明在这里如果支持传入或属性到你应该修改定义来体现出这一点函数类型接口能够描述中对象拥有的各种各样的外形除了描述带有属性的普通对象外接口也可以描述函数类型为了使用接口表示函数类型我们需要给接口定义一个调用签名它就像是一个只有参数列表和返回值类型的函数定义参数列表里的每个参数都需要名字和类型这样定义后我们可以像使用其它接口一样使用这个函数类型的接口下例展示了如何创建一个函数类型的变量并将一个同类型的函数赋值给这个变量对于函数类型的类型检查来说函数的参数名不需要与接口里定义的名字相匹配比如我们使用下面的代码重写上面的例子函数的参数会逐个进行检查要求对应位置上的参数类型是兼容的如果你不想指定类型的类型系统会推断出参数类型因为函数直接赋值给了类型变量函数的返回值类型是通过其返回值推断出来的此例是和如果让这个函数返回数字或字符串类型检查器会警告我们函数的返回值类型与接口中的定义不匹配可索引的类型与使用接口描述函数类型差不多我们也可以描述那些能够通过索引得到的类型比如或可索引类型具有一个索引签名它描述了对象索引的类型还有相应的索引返回值类型让我们看一个例子上面例子里我们定义了接口它具有索引签名这个索引签名表示了当用去索引时会得到类型的返回值支持两种索引签名字符串和数字可以同时使用两种类型的索引但是数字索引的返回值必须是字符串索引返回值类型的子类型这是因为当使用来索引时会将它转换成然后再去索引对象也就是说用一个去索引等同于使用一个去索引因此两者需要保持一致错误使用数值型的字符串索引有时会得到完全不同的字符串索引签名能够很好的描述模式并且它们也会确保所有属性与其返回值类型相匹配因为字符串索引声明了和两种形式都可以下面的例子里的类型与字符串索引类型不匹配所以类型检查器给出一个错误提示可以是类型错误的类型与索引类型返回值的类型不匹配最后你可以将索引签名设置为只读这样就防止了给索引赋值类类型实现接口与或里接口的基本作用一样也能够用它来明确的强制一个类去符合某种契约你也可以在接口中描述一个方法在类里实现它如同下面的方法一样接口描述了类的公共部分而不是公共和私有两部分它不会帮你检查类是否具有某些私有成员类静态部分与实例部分的区别当你操作类和接口的时候你要知道类是具有两个类型的静态部分的类型和实例的类型你会注意到当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误这里因为当一个类实现了一个接口时只对其实例部分进行类型检查存在于类的静态部分所以不在检查的范围内看下面的例子我们定义了两个接口为构造函数所用和为实例方法所用为了方便我们定义一个构造函数它用传入的类型创建实例因为的第一个参数是类型在里会检查是否符合构造函数签名继承接口和类一样接口也可以相互继承这让我们能够从一个接口里复制成员到另一个接口里可以更灵活地将接口分割到可重用的模块里一个接口可以继承多个接口创建出多个接口的合成接口混合类型先前我们提过接口能够描述里丰富的类型因为其动态灵活的特点有时你会希望一个对象可以同时具有上面提到的多种类型一个例子就是一个对象可以同时做为函数和对象使用并带有额外的属性在使用第三方库的时候你可能需要像上面那样去完整地定义类型这门课要重构的库就是一个很好的例子接口继承类当接口继承了一个类类型时它会继承类的成员但不包括其实现就好像接口声明了所有类中存在的成员但并没有提供具体实现一样接口同样会继承到类的和成员这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时这个接口类型只能被这个类或其子类所实现当你有一个庞大的继承结构时这很有用但要指出的是你的代码只在子类拥有特定属性时起作用这个子类除了继承至基类外与基类没有任何关系例类型缺少属性在上面的例子里包含了的所有成员包括私有成员因为是私有成员所以只能够是的子类们才能实现接口因为只有的子类才能够拥有一个声明于的私有成员这对私有成员的兼容性是必需的在类内部是允许通过的实例来访问私有成员的实际上接口和拥有方法的类是一样的和类是的子类因为它们都继承自并有方法但类并不是这样的类对于传统的程序我们会使用函数和基于原型的继承来创建可重用的组件但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手因为他们用的是基于类的继承并且对象是由类构建出来的从也就是开始程序员将能够使用基于类的面向对象的方式使用我们允许开发者现在就使用这些特性并且编译后的可以在所有主流浏览器和平台上运行而不需要等到下个版本基本示例下面看一个使用类的例子如果你使用过或你会对这种语法非常熟悉我们声明一个类这个类有个成员一个叫做的属性一个构造函数和一个方法你会注意到我们在引用任何一个类成员的时候都用了它表示我们访问的是类的成员最后一行我们使用构造了类的一个实例它会调用之前定义的构造函数创建一个类型的新对象并执行构造函数初始化它继承在里我们可以使用常用的面向对象模式基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类看下面的例子这个例子展示了最基本的继承类从基类中继承了属性和方法这里是一个派生类它派生自基类通过关键字派生类通常被称作子类基类通常被称作超类因为继承了的功能因此我们可以创建一个的实例它能够和下面我们来看个更加复杂的例子这个例子展示了一些上面没有提到的特性这一次我们使用关键字创建了的两个子类和与前一个例子的不同点是派生类包含了一个构造函数它必须调用它会执行基类的构造函数而且在构造函数里访问的属性之前我们一定要调用这个是强制执行的一条重要规则这个例子演示了如何在子类里可以重写父类的方法类和类都创建了方法它们重写了从继承来的方法使得方法根据不同的类而具有不同的功能注意即使被声明为类型但因为它的值是调用时它会调用里重写的方法公共私有与受保护的修饰符默认为在上面的例子里我们可以自由的访问程序里定义的成员如果你对其它语言中的类比较了解就会注意到我们在之前的代码里并没有使用来做修饰例如要求必须明确地使用指定成员是可见的在里成员都默认为你也可以明确的将一个成员标记成我们可以用下面的方式来重写上面的类理解当成员被标记成时它就不能在声明它的类的外部访问比如错误是私有的使用的是结构性类型系统当我们比较两种不同的类型时并不在乎它们从何处而来如果所有成员的类型都是兼容的我们就认为它们的类型是兼容的然而当我们比较带有或成员的类型的时候情况就不同了如果其中一个类型里包含一个成员那么只有当另外一个类型中也存在这样一个成员并且它们都是来自同一处声明时我们才认为这两个类型是兼容的对于成员也使用这个规则下面来看一个例子更好地说明了这一点错误与不兼容这个例子中有和两个类是类的子类还有一个类其类型看上去与是相同的我们创建了几个这些类的实例并相互赋值来看看会发生什么因为和共享了来自里的私有成员定义因此它们是兼容的然而却不是这样当把赋值给的时候得到一个错误说它们的类型不兼容尽管里也有一个私有成员但它明显不是里面定义的那个理解修饰符与修饰符的行为很相似但有一点不同成员在派生类中仍然可以访问例如注意我们不能在类外使用但是我们仍然可以通过类的实例方法访问因为是由派生而来的构造函数也可以被标记成这意味着这个类不能在包含它的类外被实例化但是能被继承比如能够继承错误的构造函数是被保护的修饰符你可以使用关键字将属性设置为只读的只读属性必须在声明时或构造函数里被初始化参数属性在上面的例子中我们必须在类里定义一个只读成员和一个参数为的构造函数并且立刻将的值赋给这种情况经常会遇到参数属性可以方便地让我们在一个地方定义并初始化一个成员下面的例子是对之前类的修改版使用了参数属性注意看我们是如何舍弃参数仅在构造函数里使用参数来创建和初始化成员我们把声明和赋值合并至一处参数属性通过给构造函数参数前面添加一个访问限定符来声明使用限定一个参数属性会声明并初始化一个私有成员对于和来说也是一样存取器支持通过来截取对对象成员的访问它能帮助你有效的控制对对象成员的访问下面来看如何把一个简单的类改写成使用和首先我们从一个没有使用存取器的例子开始我们可以设置因为它是的有时候当我们去修改它的时候触发一些额外逻辑存取器就派上用场了下面这个版本里我们先检查用户密码是否正确然后再允许其修改员工信息我们把对的直接访问改成了可以检查密码的方法我们也加了一个方法让上面的例子仍然可以工作我们可以修改一下密码来验证一下存取器是否是工作的当密码不对时会提示我们没有权限去修改员工对于存取器有下面几点需要注意的首先存取器要求你将编译器设置为输出或更高不支持降级到其次只带有不带有的存取器自动被推断为这在从代码生成文件时是有帮助的因为利用这个属性的用户会看到不允许够改变它的值静态属性到目前为止我们只讨论了类的实例成员那些仅当类被实例化的时候才会被初始化的属性我们也可以创建类的静态成员这些属性存在于类本身上面而不是类的实例上在这个例子里我们使用定义因为它是所有网格都会用到的属性每个实例想要访问这个属性的时候都要在前面加上类名如同在实例属性上使用来访问属性一样这里我们使用来访问静态属性抽象类抽象类做为其它派生类的基类使用它们一般不会直接被实例化不同于接口抽象类可以包含成员的实现细节关键字是用于定义抽象类和在抽象类内部定义抽象方法抽象类中的抽象方法不包含具体实现并且必须在派生类中实现抽象方法的语法与接口方法相似两者都是定义方法签名但不包含方法体然而抽象方法必须包含关键字并且可以包含访问修饰符必须在派生类中实现在派生类的构造函数中必须调用允许创建一个对抽象类型的引用错误不能创建一个抽象类的实例允许对一个抽象子类进行实例化和赋值错误方法在声明的抽象类中不存在高级技巧构造函数当你在里声明了一个类的时候实际上同时声明了很多东西首先就是类的实例的类型这里我们写了意思是类的实例的类型是这对于用过其它面向对象语言的程序员来讲已经是老习惯了我们也创建了一个叫做构造函数的值这个函数会在我们使用创建类实例的时候被调用下面我们来看看上面的代码被编译成后是什么样子的上面的代码里将被构造函数赋值当我们调用并执行了这个函数后便会得到一个类的实例这个构造函数也包含了类的所有静态属性换个角度说我们可以认为类具有实例部分与静态部分这两个部分让我们稍微改写一下这个例子看看它们之间的区别这个例子里与之前看到的一样我们实例化类并使用这个对象与我们之前看到的一样再之后我们直接使用类我们创建了一个叫做的变量这个变量保存了这个类或者说保存了类构造函数然后我们使用意思是取类的类型而不是实例的类型或者更确切的说告诉我标识符的类型也就是构造函数的类型这个类型包含了类的所有静态成员和构造函数之后就和前面一样我们在上使用创建的实例把类当做接口使用如上一节里所讲的类定义会创建两个东西类的实例类型和一个构造函数因为类可以创建出类型所以你能够在允许使用接口的地方使用类函数函数是应用程序的基础它帮助你实现抽象层模拟类信息隐藏和模块在里虽然已经支持类命名空间和模块但函数仍然是主要的定义行为的地方为函数添加了额外的功能让我们可以更容易地使用基本示例和一样函数可以创建有名字的函数和匿名函数你可以随意选择适合应用程序的方式不论是定义一系列函数还是只使用一次的函数通过下面的例子可以迅速回想起这两种中的函数命名函数匿名函数在里函数可以使用函数体外部的变量当函数这么做时我们说它捕获了这些变量至于为什么可以这样做以及其中的利弊超出了本文的范围但是深刻理解这个机制对学习和会很有帮助函数类型为函数定义类型让我们为上面那个函数添加类型我们可以给每个参数添加类型之后再为函数本身添加返回值类型能够根据返回语句自动推断出返回值类型书写完整函数类型现在我们已经为函数指定了类型下面让我们写出函数的完整类型函数类型包含两部分参数类型和返回值类型当写出完整函数类型的时候这两部分都是需要的我们以参数列表的形式写出参数类型为每个参数指定一个名字和类型这个名字只是为了增加可读性我们也可以这么写只要参数类型是匹配的那么就认为它是有效的函数类型而不在乎参数名是否正确第二部分是返回值类型对于返回值我们在函数和返回值类型之前使用符号使之清晰明了如之前提到的返回值类型是函数类型的必要部分如果函数没有返回任何值你也必须指定返回值类型为而不能留空函数的类型只是由参数类型和返回值组成的函数中使用的捕获变量不会体现在类型里实际上这些变量是函数的隐藏状态并不是组成的一部分推断类型尝试这个例子的时候你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话编译器会自动识别出类型这叫做按上下文归类是类型推论的一种它帮助我们更好地为程序指定类型可选参数和默认参数里的每个函数参数都是必须的这不是指不能传递或作为参数而是说编译器检查用户是否为每个参数都传入了值编译器还会假设只有这些参数会被传递进函数简短地说传递给一个函数的参数个数必须与函数期望的参数个数一致参数过少参数过多里每个参数都是可选的可传可不传没传参的时候它的值就是在里我们可以在参数名旁使用实现可选参数的功能比如我们想让是可选的现在正常了参数过多可选参数必须跟在必须参数后面如果上例我们想让是可选的那么就必须调整它们的位置把放在后面在里我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是时它们叫做有默认初始化值的参数让我们修改上例把的默认值设置为返回正常同样错误参数过多与普通可选参数不同的是带默认值的参数不需要放在必须参数的后面如果带默认值的参数出现在必须参数前面用户必须明确的传入值来获得默认值例如我们重写最后一个例子让是带默认值的参数参数过少参数过多返回返回剩余参数必要参数默认参数和可选参数有个共同点它们表示某一个参数有时你想同时操作多个参数或者你并不知道会有多少参数传递进来在里你可以使用来访问所有传入的参数在里你可以把所有参数收集到一个变量里剩余参数会被当做个数不限的可选参数可以一个都没有同样也可以有任意个编译器创建参数数组名字是你在省略号后面给定的名字你可以在函数体内使用这个数组这个省略号也会在带有剩余参数的函数类型定义上使用到学习如何在里正确使用就好比一场成年礼由于是的超集程序员也需要弄清工作机制并且当有的时候能够找出错误所在幸运的是能通知你错误地使用了的地方如果你想了解里的是如何工作的那么首先阅读写的的文章详细的阐述了的内部工作原理因此我们这里只做简单介绍和箭头函数里的值在函数被调用的时候才会指定这是个既强大又灵活的特点但是你需要花点时间弄清楚函数调用的上下文是什么但众所周知这不是一件很简单的事尤其是在返回一个函数或将函数当做参数传递的时候下面看一个例子可以看到是个函数并且它又返回了一个函数如果我们尝试运行这个程序会发现它并没有输出而是报错了因为返回的函数里的被设置成了而不是对象因为我们只是独立的调用了顶级的非方法式调用会将视为为了解决这个问题我们可以在函数被返回时就绑好正确的这样的话无论之后怎么使用它都会引用绑定的对象我们需要改变函数表达式来使用箭头语法箭头函数能保存函数创建时的值而不是调用时的值注意这里使用箭头函数参数在上述的例子中的类型为这是因为来自对象字面量里的函数表达式修改的方法是提供一个显式的参数参数是个假的参数它出现在参数列表的最前面确保在此独立函数中不可用让我们往例子里添加一些接口和让类型重用能够变得清晰简单些函数现在显式指定其被调用方必须是类型现在知道期望在某个对象上调用也就是说是类型的而非参数在回调函数里你可以也看到过在回调函数里的报错当你将一个函数传递到某个库函数里稍后会被调用时因为当回调被调用的时候它们会被当成一个普通函数调用将为稍做改动你就可以通过参数来避免错误首先库函数的作者要指定的类型意味着期望传入的方法不需要指定了类型后你显式声明必须在的实例上调用然后会检测到要求函数带有改变类型来修复这个错误因为指定了类型为因此传递是合法的当然了这也意味着不能使用如果你两者都想要你不得不使用箭头函数了这是可行的因为箭头函数不会捕获所以你总是可以把它们传给期望的函数重载本身是个动态语言里函数根据传入不同的参数而返回不同类型的数据的场景是很常见的方法根据传入参数的不同会返回两种不同的类型如果传入的是代表纸牌的对象数组函数作用是从中抓一张牌如果用户想抓牌我们告诉他抓到了什么牌但是这怎么在类型系统里表示呢方法是为同一个函数提供多个函数类型定义来进行函数重载编译器会根据这个列表去处理函数的调用下面我们来重载函数这样改变后重载的函数在调用的时候会进行正确的类型检查为了让编译器能够选择正确的检查类型它与里的处理流程相似它查找重载列表尝试使用第一个重载定义如果匹配的话就使用这个因此在定义重载的时候一定要把最精确的定义放在最前面注意并不是重载列表的一部分因此这里只有两个重载一个是接收对象数组另一个接收数字以其它参数调用会产生错误泛型软件工程中我们不仅要创建定义良好且一致的同时也要考虑可重用性组件不仅能够支持当前的数据类型同时也能支持未来的数据类型这在创建大型系统时为你提供了十分灵活的功能在像和这样的语言中可以使用泛型来创建可重用的组件一个组件可以支持多种类型的数据这样用户就可以以自己的数据类型来使用组件基础示例下面来创建第一个使用泛型的例子函数这个函数会返回任何传入它的值你可以把这个函数当成是命令不用泛型的话这个函数可能是下面这样或者我们使用类型来定义函数使用类型会导致这个函数可以接收任何类型的参数但是这样就丢失了一些信息传入的类型与返回的类型应该是相同的如果我们传入一个数字我们只知道任何类型的值都有可能被返回因此我们需要一种方法使返回值的类型与传入参数的类型是相同的这里我们使用了类型变量它是一种特殊的变量只用于表示类型而不是值我们给添加了类型变量帮助我们捕获用户传入的类型比如之后我们就可以使用这个类型之后我们再次使用了当做返回值类型现在我们可以知道参数类型与返回值类型是相同的了这允许我们跟踪函数里使用的类型的信息我们把这个版本的函数叫做泛型因为它可以适用于多个类型不同于使用它不会丢失信息像第一个例子那像保持准确性传入数值类型并返回数值类型我们定义了泛型函数后可以用两种方法使用第一种是传入所有的参数包含类型参数这里我们明确的指定了是类型并做为一个参数传给函数使用了括起来而不是第二种方法更普遍利用了类型推论即编译器会根据传入的参数自动地帮助我们确定的类型注意我们没必要使用尖括号来明确地传入类型编译器可以查看的值然后把设置为它的类型类型推论帮助我们保持代码精简和高可读性如果编译器不能够自动地推断出类型的话只能像上面那样明确的传入的类型在一些复杂的情况下这是可能出现的使用泛型变量使用泛型创建像这样的泛型函数时编译器要求你在函数体必须正确的使用这个通用的类型换句话说你必须把这些参数当做是任意或所有类型看下之前例子如果我们想打印出的长度我们很可能会这样做如果这么做编译器会报错说我们使用了的属性但是没有地方指明具有这个属性记住这些类型变量代表的是任意类型所以使用这个函数的人可能传入的是个数字而数字是没有属性的现在假设我们想操作类型的数组而不直接是由于我们操作的是数组所以属性是应该存在的我们可以像创建其它数组一样创建这个数组你可以这样理解的类型泛型函数接收类型参数和参数它是个元素类型是的数组并返回元素类型是的数组如果我们传入数字数组将返回一个数字数组因为此时的的类型为这可以让我们把泛型变量当做类型的一部分使用而不是整个类型增加了灵活性泛型类型上一节我们创建了通用函数可以适用于不同的类型在这节我们研究一下函数本身的类型以及如何创建泛型接口泛型函数的类型与非泛型函数的类型没什么不同只是有一个类型参数在最前面像函数声明一样我们也可以使用不同的泛型参数名只要在数量上和使用方式上能对应上就可以我们还可以使用带有调用签名的对象字面量来定义泛型函数这引导我们去写第一个泛型接口了我们把上面例子里的对象字面量拿出来做为一个接口我们甚至可以把泛型参数当作整个接口的一个参数这样我们就能清楚的知道使用的具体是哪个泛型类型比如而不只是这样接口里的其它成员也能知道这个参数的类型了注意我们的示例做了少许改动不再描述泛型函数而是把非泛型函数签名作为泛型类型一部分当我们使用的时候还得传入一个类型参数来指定泛型类型这里是锁定了之后代码里使用的类型对于描述哪部分类型属于泛型部分来说理解何时把参数放在调用签名里和何时放在接口上是很有帮助的除了泛型接口我们还可以创建泛型类注意无法创建泛型枚举和泛型命名空间泛型类泛型类看上去与泛型接口差不多泛型类使用括起泛型类型跟在类名后面类的使用是十分直观的并且你可能已经注意到了没有什么去限制它只能使用类型也可以使用字符串或其它更复杂的类型与接口一样直接把泛型类型放在类后面可以帮助我们确认类的所有属性都在使用相同的类型我们在类那节说过类有两部分静态部分和实例部分泛型类指的是实例部分的类型所以类的静态属性不能使用这个泛型类型泛型约束我们有时候想操作某类型的一组值并且我们知道这组值具有什么样的属性在例子中我们想访问的属性但是编译器并不能证明每种类型都有属性所以就报错了相比于操作所有类型我们想要限制函数去处理任意带有属性的所有类型只要传入的类型有这个属性我们就允许就是说至少包含这一属性为此我们需要列出对于的约束要求我们定义一个接口来描述约束条件创建一个包含属性的接口使用这个接口和关键字来实现约束现在这个泛型函数被定义了约束因此它不再是适用于任意类型我们需要传入符合约束类型的值必须包含必须的属性在泛型约束中使用类型参数你可以声明一个类型参数且它被另一个类型参数所约束比如现在我们想要用属性名从对象里获取这个属性并且我们想要确保这个属性存在于对象上因此我们需要在这两个类型之间使用约束类型推断类型推断这节介绍里的类型推断即类型是在哪里如何被推断的基础里在有些没有明确指出类型的地方类型推断会帮助提供类型如下面的例子变量的类型被推断为数字这种推断发生在初始化变量和成员设置默认参数值和决定函数返回值时大多数情况下类型推断是直截了当地后面的小节我们会浏览类型推断时的细微差别最佳通用类型有些时候我们需要从几个表达式中推断类型会使用这些表达式的类型来推断出一个最合适的通用类型例如为了推断的类型我们必须考虑所有元素的类型这里有两种选择和计算通用类型算法会考虑所有的候选类型并给出一个兼容所有候选类型的类型由于最终的通用类型取自候选类型有些时候候选类型共享一个公共结构但是却没有一个类型能做为所有候选类型的超级类型例如这里我们想让被推断为类型但是这个数组里没有对象是类型的因此不能推断出这个结果为了更正我们可以明确的声明我们期望的类型如果没有找到最佳通用类型的话类型推断的结果为联合数组类型上下文类型有些时候类型推断会按另外一种方式我们称作上下文类型上下文类型的出现和表达式的类型以及所处的位置相关比如这个例子会得到一个类型错误类型检查器使用函数的类型来推断右边函数表达式的类型因此就能推断出参数的类型了所以访问了一个不存在的属性就报错了如果上下文类型表达式包含了明确的类型信息上下文的类型被忽略重写上面的例子这个函数表达式有明确的参数类型注解上下文类型被忽略这样的话就不报错了因为这里不会使用到上下文类型上下文类型会在很多情况下使用到通常包含函数的参数赋值表达式的右边类型断言对象成员数组字面量和返回值语句上下文类型也会做为最佳通用类型的候选类型比如这个例子里最佳通用类型有个候选者和其中会被做为最佳通用类型高级类型交叉类型交叉类型是将多个类型合并为一个类型这让我们可以把现有的多种类型叠加到一起成为一种类型它包含了所需的所有类型的特性例如同时是和就是说这个类型的对象同时拥有了这两种类型的成员我们大多是在混入或其它不适合典型面向对象模型的地方看到交叉类型的使用在里发生这种情况的场合很多下面是如何创建混入的一个简单例子联合类型联合类型与交叉类型很有关联但是使用上却完全不同偶尔你会遇到这种情况一个代码库希望传入或类型的参数例如下面的函数存在一个问题参数的类型指定成了这就是说我们可以传入一个既不是也不是类型的参数但是却不报错编译阶段通过运行时报错为了解决这个问题我们可以使用联合类型做为的参数编译阶段报错联合类型表示一个值可以是几种类型之一我们用竖线分隔每个类型所以表示一个值可以是或如果一个值是联合类型我们只能访问此联合类型的所有类型里共有的成员这里的联合类型可能有点复杂如果一个值的类型是我们能够确定的是它包含了和中共有的成员这个例子里具有一个方法我们不能确定一个类型的变量是否有方法如果变量在运行时是类型那么调用就出错了类型保护联合类型适合于那些值可以为不同类型的情况但当我们想确切地了解是否为或者是时怎么办里常用来区分这个可能值的方法是检查成员是否存在如之前提及的我们只能访问联合类型中共同拥有的成员每一个成员访问都会报错为了让这段代码工作我们要使用类型断言用户自定义的类型保护这里可以注意到我们不得不多次使用类型断言如果我们一旦检查过类型就能在之后的每个分支里清楚地知道的类型的话就好了里的类型保护机制让它成为了现实类型保护就是一些表达式它们会在运行时检查以确保在某个作用域里的类型定义一个类型保护我们只要简单地定义一个函数它的返回值是一个类型谓词在这个例子里就是类型谓词谓词为这种形式必须是来自于当前函数签名里的一个参数名每当使用一些变量调用时会将变量缩减为那个具体的类型注意不仅知道在分支里是类型它还清楚在分支里一定不是类型而是类型类型保护现在我们回过头来看看怎么使用联合类型书写代码我们可以像下面这样利用类型断言来写然而你必须要定义一个函数来判断类型是否是原始类型但这并不必要其实我们不必将抽象成一个函数因为可以将它识别为一个类型保护也就是说我们可以直接在代码里检查类型了这些类型保护只有两种形式能被识别和必须是或但是并不会阻止你与其它字符串比较只是不会把那些表达式识别为类型保护类型保护如果你已经阅读了类型保护并且对里的操作符熟悉的话你可能已经猜到了这节要讲的内容类型保护是通过构造函数来细化类型的一种方式我们把之前的例子做一个小小的改造可以为的类型具有两种特殊的类型和它们分别具有值和我们在基础类型一节里已经做过简要说明默认情况下类型检查器认为与可以赋值给任何类型与是所有其它类型的一个有效值这也意味着你阻止不了将它们赋值给其它类型就算是你想要阻止这种情况也不行的发明者称它为价值亿万美金的错误标记可以解决此错误当你声明一个变量时它不会自动地包含或你可以使用联合类型明确的包含它们错误不能赋值给可以不能赋值给注意按照的语义会把和区别对待和是不同的类型可选参数和可选属性使用了可选参数会被自动地加上不能赋值给可选属性也会有同样的处理不能赋值给不能赋值给类型保护和类型断言由于可以为的类型能和其它类型定义为联合类型那么你需要使用类型保护来去除幸运地是这与在里写的代码一致这里很明显地去除了你也可以使用短路运算符如果编译器不能够去除或你可以使用类型断言手动去除语法是添加后缀从的类型里去除了和可能为本例使用了嵌套函数因为编译器无法去除嵌套函数的除非是立即调用的函数表达式因为它无法跟踪所有对嵌套函数的调用尤其是你将内层函数做为外层函数的返回值如果无法知道函数在哪里被调用就无法知道调用时的类型字符串字面量类型字符串字面量类型允许你指定字符串必须具有的确切值在实际应用中字符串字面量类型可以与联合类型类型保护很好的配合通过结合使用这些特性你可以实现类似枚举类型的字符串不能传入或者你只能从三种允许的字符中选择其一来做为参数传递传入其它值则会产生错误",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-01-09 05:43:16",postMainColor:""}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W3DLGJMJDY"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-W3DLGJMJDY")</script><meta name="generator" content="Hexo 7.0.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/yueyun.jpg"><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"><script async src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">月晕</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>留言</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size:.9em"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size:.9em"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size:.9em"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size:.9em"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><div class="nav-change" id="nav-darkmode"><a class="darkmode_switchbutton" title="显示模式切换" onclick="darkmo" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><input id="center-console" type="checkbox"><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url">前端</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/JavaScript/" tabindex="-1" itemprop="url"> <span><i class="anzhiyufont anzhiyu-icon-hashtag"></i>JavaScript</span></a><a class="article-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/" tabindex="-1" itemprop="url"> <span><i class="anzhiyufont anzhiyu-icon-hashtag"></i>前端</span></a><a class="article-meta__tags" href="/tags/TypeScript/" tabindex="-1" itemprop="url"> <span><i class="anzhiyufont anzhiyu-icon-hashtag"></i>TypeScript</span></a></span></div></div><h1 class="post-title" itemprop="name headline">TypeScript语言学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="post-meta-icon anzhiyufont anzhiyu-icon-calendar-days"></i><span class="post-meta-label">发表于</span><time itemprop="dateCreated datePublished" datetime="2023-12-22T17:46:54.000Z" title="发表于 2023-12-22 17:46:54">2023-12-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">23.2k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>86分钟</span></span><span class="post-meta-separator"> </span><span class="post-meta-position" title="作者IP属地为杭州"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>杭州</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/d681bdaf.html#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/liang.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blog.yueyun.site/posts/d681bdaf.html"><header><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url">前端</a><a href="/tags/JavaScript/" tabindex="-1" itemprop="url">JavaScript</a><a href="/tags/%E5%89%8D%E7%AB%AF/" tabindex="-1" itemprop="url">前端</a><a href="/tags/TypeScript/" tabindex="-1" itemprop="url">TypeScript</a><h1 id="CrawlerTitle" itemprop="name headline">TypeScript语言学习</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">月晕</span><time itemprop="dateCreated datePublished" datetime="2023-12-22T17:46:54.000Z" title="undefined 2023-12-22 17:46:54">2023-12-22</time></header><h1 id="TypeScript-简介"><a href="#TypeScript-简介" class="headerlink" title="TypeScript 简介"></a>TypeScript 简介</h1><p>TypeScript 作为 Javascript 语言的超集、为 JavaScript 添加可选择的类型标注，大大的增加了代码的可维护性和迭代性。同时会不断的发展 javascript 的新特性，是现在流行的前端技术</p><h1 id="TypeScript-的特点"><a href="#TypeScript-的特点" class="headerlink" title="TypeScript 的特点"></a>TypeScript 的特点</h1><ul><li>始于 JavaScript，归于 JavaScript<br>TypeScript 终归是通过编译形成 Javascript 可以运行在任何浏览器上和 nodejs 等运行时环境中</li><li><strong>强大的工具构建大型应用程序</strong></li></ul><p>类型允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。</p><p>类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有 JavaScript 库的行为。</p><ul><li><strong>先进的 JavaScript</strong></li></ul><p>TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。</p><p>这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ECMAScript3（或更新版本）的 JavaScript。</p><h1 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h1><p>TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>最基本的数据类型就是简单的 true&#x2F;false 值，在 JavaScript 和 TypeScript 里叫做 <code>boolean</code>（其它语言中也一样）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015 中引入的二进制和八进制字面量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">decLiteral</span>: <span class="built_in">number</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">hexLiteral</span>: <span class="built_in">number</span> = <span class="number">0x14</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">binaryLiteral</span>: <span class="built_in">number</span> = <span class="number">0b10100</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">octalLiteral</span>: <span class="built_in">number</span> = <span class="number">0o24</span></span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 <code>string</code> 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>&#39;</code>）表示字符串。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;bob&#x27;</span></span><br><span class="line">name = <span class="string">&#x27;smith&#x27;</span></span><br></pre></td></tr></table></figure><p>你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ <code>`</code>），并且以 <code>$&#123; expr &#125;</code> 这种形式嵌入表达式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">`Yee`</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">37</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">sentence</span>: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123;name&#125;</span>.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I&#x27;ll be <span class="subst">$&#123;age + <span class="number">1</span>&#125;</span> years old next month.`</span></span><br></pre></td></tr></table></figure><p>这与下面定义 <code>sentence</code> 的方式效果相同：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">sentence</span>: <span class="built_in">string</span> =</span><br><span class="line">  <span class="string">&#x27;Hello, my name is &#x27;</span> +</span><br><span class="line">  name +</span><br><span class="line">  <span class="string">&#x27;.\n\n&#x27;</span> +</span><br><span class="line">  <span class="string">&quot;I&#x27;ll be &quot;</span> +</span><br><span class="line">  (age + <span class="number">1</span>) +</span><br><span class="line">  <span class="string">&#x27; years old next month.&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="元祖-Tuple"><a href="#元祖-Tuple" class="headerlink" title="元祖 Tuple"></a>元祖 Tuple</h2><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code>string</code> 和 <code>number</code> 类型的元组。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>]</span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>] <span class="comment">// OK</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>] <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>当访问一个已知索引的元素，会得到正确的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">0</span>].<span class="title function_">substr</span>(<span class="number">1</span>)) <span class="comment">// OK</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">1</span>].<span class="title function_">substr</span>(<span class="number">1</span>)) <span class="comment">// Error, &#x27;number&#x27; 不存在 &#x27;substr&#x27; 方法</span></span><br></pre></td></tr></table></figure><p>当访问一个越界的元素，会使用联合类型替代：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">&#x27;world&#x27;</span> <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">5</span>].<span class="title function_">toString</span>()) <span class="comment">// OK, &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span> <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure><p>联合类型是高级主题，我们会在以后的章节里讨论它。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><code>enum</code> 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span></span><br></pre></td></tr></table></figure><p>默认情况下，从 <code>0</code> 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code> 开始编号：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span></span><br></pre></td></tr></table></figure><p>或者，全部都采用手动赋值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Green</span> = <span class="number">2</span>,</span><br><span class="line">  <span class="title class_">Blue</span> = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span></span><br></pre></td></tr></table></figure><p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">colorName</span>: <span class="built_in">string</span> = <span class="title class_">Color</span>[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colorName) <span class="comment">// 显示&#x27;Green&#x27;因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code> 类型来标记这些变量：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span></span><br><span class="line">notSure = <span class="string">&#x27;maybe a string instead&#x27;</span></span><br><span class="line">notSure = <span class="literal">false</span> <span class="comment">// 也可以是个 boolean</span></span><br></pre></td></tr></table></figure><p>在对现有代码进行改写的时候，<code>any</code> 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，<code>any</code> 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>某种程度上来说，<code>void</code> 类型像是与 <code>any</code> 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">warnUser</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is my warning message&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个 <code>void</code> 类型的变量没有什么大用，因为你只能为它赋予 <code>undefined</code> 和 <code>null</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">unusable</span>: <span class="built_in">void</span> = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><h2 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h2><p>TypeScript 里，<code>undefined</code> 和 <code>null</code> 两者各自有自己的类型分别叫做 <code>undefined</code> 和 <code>null</code>。 和 <code>void</code> 相似，它们的本身的类型用处不是很大：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。</p><p>然而，当你指定了 <code>--strictNullChecks</code> 标记，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 <code>string</code> 或 <code>null</code> 或 <code>undefined</code>，你可以使用联合类型 <code>string | null | undefined</code>。 再次说明，稍后我们会介绍联合类型。</p><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如， <code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code> 类型，当它们被永不为真的类型保护所约束时。</p><p><code>never</code> 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 <code>never</code> 的子类型或可以赋值给<code>never</code> 类型（除了 <code>never</code> 本身之外）。 即使 <code>any</code> 也不可以赋值给 <code>never</code>。</p><p>下面是一些返回 <code>never</code> 类型的函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">error</span>(<span class="string">&#x27;Something failed&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">infiniteLoop</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><p><code>object</code> 表示非原始类型，也就是除 <code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code> 之外的类型。</p><p>使用 <code>object</code> 类型，就可以更好的表示像 <code>Object.create</code> 这样的 <code>API</code>。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">o: <span class="built_in">object</span> | <span class="literal">null</span></span>): <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">create</span>(&#123; <span class="attr">prop</span>: <span class="number">0</span> &#125;) <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">null</span>) <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">create</span>(<span class="number">42</span>) <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="string">&#x27;string&#x27;</span>) <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">false</span>) <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">undefined</span>) <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p><p>类型断言有两种形式。 其一是“尖括号”语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&#x27;this is a string&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).<span class="property">length</span></span><br></pre></td></tr></table></figure><p>另一个为 <code>as</code> 语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&#x27;this is a string&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span></span><br></pre></td></tr></table></figure><p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 <code>as</code> 语法断言是被允许的。</p><h1 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h1><p><code>let</code> 和 <code>const</code> 是 JavaScript 里相对较新的变量声明方式。<code>let</code> 在很多方面与 <code>var</code> 是相似的，但是可以帮助大家避免在 JavaScript 里常见一些问题。<code>const</code> 是对 <code>let</code> 的一个增强，它能阻止对一个变量再次赋值。</p><p>因为 TypeScript 是 JavaScript 的超集，所以它本身就支持 <code>let</code> 和 <code>const</code>。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 <code>var</code>。</p><p>如果你已经对 <code>var</code> 声明的怪异之处了如指掌，那么你可以轻松地略过这节。</p><h2 id="var-声明"><a href="#var-声明" class="headerlink" title="var 声明"></a>var 声明</h2><p>在 ES5 的时代，我们都是通过 <code>var</code> 关键字定义 JavaScript 变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>大家都能理解，这里定义了一个名为 <code>a</code> 值为 <code>10</code> 的变量。</p><p>我们也可以在函数内部定义变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且我们也可以在其它函数内部访问相同的变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = a + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">f</span>()</span><br><span class="line"><span class="title function_">g</span>() <span class="comment">// returns 11</span></span><br></pre></td></tr></table></figure><p>上面的例子是一个典型的闭包场景，<code>g</code> 可以获取到 <code>f</code> 函数里定义的 <code>a</code> 变量。 每当 <code>g</code> 被调用时，它都可以访问到 <code>f</code> 里的 <code>a</code> 变量。 即使当 <code>g</code> 在 <code>f</code> 已经执行完后才被调用，它仍然可以访问 <code>a</code>。</p><h3 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h3><p><code>var</code> 声明有些奇怪的作用域规则。 看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">shouldInitialize</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldInitialize) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="literal">true</span>) <span class="comment">// returns &#x27;10&#x27;</span></span><br><span class="line"><span class="title function_">f</span>(<span class="literal">false</span>) <span class="comment">// returns &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure><p>有些同学可能要多看几遍这个例子。 变量 <code>x</code> 是定义在 <code>if</code> 语句里面，但是我们却可以在语句的外面访问它。 这是因为 <code>var</code> 声明的作用域是函数作用域，函数参数也使用函数作用域。</p><p>这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sumMatrix</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; matrix.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentRow = matrix[i]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; currentRow.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      sum += currentRow[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很容易看出一些问题，里层的 <code>for</code> 循环会覆盖变量 <code>i</code>，因为所有 <code>i</code> 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。</p><h3 id="捕获变量怪异之处"><a href="#捕获变量怪异之处" class="headerlink" title="捕获变量怪异之处"></a>捕获变量怪异之处</h3><p>猜一下下面的代码会返回什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, <span class="number">100</span> * i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是，<code>setTimeout</code> 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>很多 JavaScript 程序员对这种行为已经很熟悉了，但如果你很不解也没有关系，因为你并不是一个人。 大多数人期望输出结果是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><blockquote><p>我们传给 <code>setTimeout</code> 的每一个函数表达式实际上都引用了相同作用域里的同一个 <code>i</code>。</p></blockquote><p>让我们花点时间思考一下这是为什么。 <code>setTimeout</code> 在若干毫秒后执行一个函数，并且是在 <code>for</code> 循环结束后。<code>for</code> 循环结束后，<code>i</code> 的值为 <code>10</code>。 所以当函数被调用的时候，它会打印出 <code>10</code>。</p><p>一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时 <code>i</code> 的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  ;(<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">    &#125;, <span class="number">100</span> * i)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种奇怪的形式我们已经司空见惯了。 参数 <code>i</code> 会覆盖 <code>for</code> 循环里的 <code>i</code>，但是因为我们起了同样的名字，所以我们不用怎么改 <code>for</code> 循环体里的代码。</p><h2 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a>let 声明</h2><p>现在你已经知道了 <code>var</code> 存在一些问题，这恰好说明了为什么用 <code>let</code> 语句来声明变量。 除了名字不同外， <code>let</code> 与 <code>var</code> 的写法一致：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">&#x27;Hello!&#x27;</span></span><br></pre></td></tr></table></figure><p>主要的区别不在语法上，而是语义，我们接下来会深入研究。</p><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>当用 <code>let</code> 声明一个变量，它使用的是块作用域。 不同于使用 <code>var</code> 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 <code>for</code> 循环之外是不能访问的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">input: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (input) &#123;</span><br><span class="line">    <span class="comment">// OK: 仍然能访问到 a</span></span><br><span class="line">    <span class="keyword">let</span> b = a + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Error: &#x27;b&#x27; 在这里不存在</span></span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义了 2 个变量 <code>a</code> 和 <code>b</code>。 <code>a</code> 的作用域是 <code>f</code> 函数体内，而 <code>b</code> 的作用域是 <code>if</code> 语句块里。</p><p>在 <code>catch</code> 语句里声明的变量也具有同样的作用域规则。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;Oh no!&#x27;</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Catch it.&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: &#x27;e&#x27; 在这里不存在</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br></pre></td></tr></table></figure><p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于<em>暂时性死区</em>。 它只是用来说明我们不能在 <code>let</code> 语句之前访问它们，幸运的是 <code>TypeScript</code> 可以告诉我们这些信息。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a++ <span class="comment">// TS2448: Block-scoped variable &#x27;a&#x27; used before its declaration.</span></span><br><span class="line"><span class="keyword">let</span> a</span><br></pre></td></tr></table></figure><p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 ES2015，现代的运行时会抛出一个错误；然而，现今 TypeScript 是不会报错的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// okay to capture &#x27;a&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能在&#x27;a&#x27;被声明前调用&#x27;foo&#x27;</span></span><br><span class="line"><span class="comment">// 运行时应该抛出错误</span></span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a</span><br></pre></td></tr></table></figure><p>关于<em>暂时性死区</em>的更多信息，查看这里 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let">Mozilla Developer Network</a>。</p><h3 id="重定义及屏蔽"><a href="#重定义及屏蔽" class="headerlink" title="重定义及屏蔽"></a>重定义及屏蔽</h3><p>我们提过使用 <code>var</code> 声明时，它不在乎你声明多少次；你只会得到 1 个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x</span><br><span class="line">  <span class="keyword">var</span> x</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子里，所有 <code>x</code> 的声明实际上都引用一个相同的<code>x</code>，并且这是完全有效的代码，但这经常会成为 <code>bug</code> 的来源。幸运的是 <code>let</code> 的声明就不会这么宽松了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">20</span> <span class="comment">// 错误，不能在 1 个作用域里多次声明 x</span></span><br></pre></td></tr></table></figure><p>并不是要求两个均是块级作用域的声明 TypeScript 才会给出一个错误的警告。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">100</span> <span class="comment">// Error: 干扰参数声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">100</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">100</span> <span class="comment">// Error: 不能同时具有 x 的两个声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">condition, x</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">100</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="literal">false</span>, <span class="number">0</span>) <span class="comment">// returns 0</span></span><br><span class="line"><span class="title function_">f</span>(<span class="literal">true</span>, <span class="number">0</span>) <span class="comment">// returns 100</span></span><br></pre></td></tr></table></figure><p>在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 <code>let</code> 重写之前的 <code>sumMatrix</code> 函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sumMatrix</span>(<span class="params">matrix: <span class="built_in">number</span>[][]</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; matrix.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentRow = matrix[i]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; currentRow.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      sum += currentRow[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本的循环能得到正确的结果，因为内层循环的 <code>i</code> 可以屏蔽掉外层循环的 <code>i</code>。</p><p>通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好权衡一下。</p><h3 id="块级作用域变量的获取"><a href="#块级作用域变量的获取" class="headerlink" title="块级作用域变量的获取"></a>块级作用域变量的获取</h3><p>每次进入一个作用域时，<code>let</code> 会创建一个变量的环境。就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p><p>回想一下前面 <code>setTimeout</code> 的例子，我们最后需要使用立即执行的函数表达式来获取每次 <code>for</code> 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 <code>TypeScript</code> 里这样做了。</p><p>当 <code>let</code> 声明出现在循环体里时拥有完全不同的行为。不仅是在循环里引入了一个新的变量环境，而且针对每次迭代都会创建这样一个新作用域，这就相当于我们在使用立即执行的函数表达式时做的事。所以在 <code>setTimeout</code> 例子里我们仅使用 <code>let</code> 声明就可以了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, <span class="number">100</span> * i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会输出与预料一致的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="const-声明"><a href="#const-声明" class="headerlink" title="const 声明"></a>const 声明</h2><p><code>const</code> 声明是声明变量的另一种方式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numLivesForCat = <span class="number">9</span></span><br></pre></td></tr></table></figure><p>它们与 <code>let</code> 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 <code>let</code> 相同的作用域规则，但是不能对它们重新赋值。</p><p>这很好理解，它们引用的值是不可变的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numLivesForCat = <span class="number">9</span></span><br><span class="line"><span class="keyword">const</span> kitty = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Kitty&#x27;</span>,</span><br><span class="line">  <span class="attr">numLives</span>: numLivesForCat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line">kitty = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tommy&#x27;</span>,</span><br><span class="line">  <span class="attr">numLives</span>: numLivesForCat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line">kitty.<span class="property">name</span> = <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line">kitty.<span class="property">numLives</span>--</span><br></pre></td></tr></table></figure><p>除非你使用特殊的方法去避免，实际上 <code>const</code> 变量的内部状态是可修改的。 幸运的是，<code>TypeScript</code> 允许你将对象的成员设置成只读的。接口一章有详细说明。</p><h2 id="let-vs-const"><a href="#let-vs-const" class="headerlink" title="let vs. const"></a>let vs. const</h2><p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。与大多数泛泛的问题一样，答案是：依情况而定。</p><p>使用最小特权原则，所有变量除了你计划去修改的都应该使用 <code>const</code>。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。使用 <code>const</code> 也可以让我们更容易的推测数据的流动。</p><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><h3 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a>解构数组</h3><p>最简单的解构莫过于数组的解构赋值了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> [first, second] = input</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first) <span class="comment">// outputs 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(second) <span class="comment">// outputs 2</span></span><br></pre></td></tr></table></figure><p>这创建了 2 个命名变量 <code>first</code> 和 <code>second</code>。 相当于使用了索引，但更为方便：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> first = input[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> second = input[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>作用于函数参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">input</span>: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">[first, second]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(first)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(input)</span><br></pre></td></tr></table></figure><p>你可以在数组里使用 <code>...</code> 语法创建剩余变量：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first) <span class="comment">// outputs 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rest) <span class="comment">// outputs [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure><p>你也可以忽略你不关心的尾随元素：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [first] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first) <span class="comment">// outputs 1</span></span><br></pre></td></tr></table></figure><p>或其它元素：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [, second, , fourth] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>你也可以解构对象：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = o</span><br></pre></td></tr></table></figure><p>这通过 <code>o.a</code> 和 <code>o.b</code> 创建了 <code>a</code> 和 <code>b</code> 。 注意，如果你不需要 <code>c</code> 你可以忽略它。</p><p>你可以在对象里使用 <code>...</code> 语法创建剩余变量：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; a, ...passthrough &#125; = o</span><br><span class="line"><span class="keyword">let</span> total = passthrough.<span class="property">b</span> + passthrough.<span class="property">c</span>.<span class="property">length</span></span><br></pre></td></tr></table></figure><h3 id="属性重命名"><a href="#属性重命名" class="headerlink" title="属性重命名"></a>属性重命名</h3><p>你也可以给属性以不同的名字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">a</span>: newName1, <span class="attr">b</span>: newName2 &#125; = o</span><br></pre></td></tr></table></figure><p>这里的语法开始变得混乱。 你可以将 <code>a: newName1</code> 读做 <code>&quot;a 作为 newName1&quot;</code>。 方向是从左到右，好像你写成了以下样子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newName1 = o.<span class="property">a</span></span><br><span class="line"><span class="keyword">let</span> newName2 = o.<span class="property">b</span></span><br></pre></td></tr></table></figure><p>令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型，仍然需要在其后写上完整的模式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; a, b &#125;: &#123; <span class="attr">a</span>: <span class="built_in">string</span>; <span class="attr">b</span>: <span class="built_in">number</span> &#125; = o</span><br></pre></td></tr></table></figure><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>默认值可以让你在属性为 <code>undefined</code> 时使用缺省值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">keepWholeObject</span>(<span class="params">wholeObject: &#123; a: <span class="built_in">string</span>; b?: <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; a, b = <span class="number">1001</span> &#125; = wholeObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，即使 <code>b</code> 为 <code>undefined</code> ， <code>keepWholeObject</code> 函数的变量 <code>wholeObject</code> 的属性 <code>a</code> 和 <code>b</code> 都会有值。</p><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>解构也能用于函数声明。 看以下简单的情况：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> C = &#123; <span class="attr">a</span>: <span class="built_in">string</span>; b?: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123; a, b &#125;: C</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123; a = <span class="string">&#x27;&#x27;</span>, b = <span class="number">0</span> &#125; = &#123;&#125;</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>()</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码是一个类型推断的例子，将在后续章节介绍。</p></blockquote><p>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123; a, b = <span class="number">0</span> &#125; = &#123; a: <span class="string">&#x27;&#x27;</span> &#125;</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(&#123; <span class="attr">a</span>: <span class="string">&#x27;yes&#x27;</span> &#125;) <span class="comment">// OK, 默认 b = 0</span></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// OK, 默认 a: &#x27;&#x27;, b = 0</span></span><br><span class="line"><span class="title function_">f</span>(&#123;&#125;) <span class="comment">// Error, 一旦传入参数则 a 是必须的</span></span><br></pre></td></tr></table></figure><p>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。</p><h2 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> first = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> second = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> bothPlus = [<span class="number">0</span>, ...first, ...second, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>这会令 <code>bothPlus</code> 的值为 <code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了 <code>first</code> 和 <code>second的</code> 一份浅拷贝。 它们不会被展开操作所改变。</p><p>你还可以展开对象：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaults = &#123; <span class="attr">food</span>: <span class="string">&#x27;spicy&#x27;</span>, <span class="attr">price</span>: <span class="string">&#x27;$10&#x27;</span>, <span class="attr">ambiance</span>: <span class="string">&#x27;noisy&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> search = &#123; ...defaults, <span class="attr">food</span>: <span class="string">&#x27;rich&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>search 的值为 <code>&#123; food: &#39;rich&#39;, price: &#39;$10&#39;, ambiance: &#39;noisy&#39; &#125;</code>。 对象的展开比数组的展开要复杂的多。像数组展开一样，它是从左至右进行处理，但结果仍为对象。这就意味着出现在展开对象后面的属性会覆盖前面的属性。因此，如果我们修改上面的例子，在结尾处进行展开的话：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaults = &#123; <span class="attr">food</span>: <span class="string">&#x27;spicy&#x27;</span>, <span class="attr">price</span>: <span class="string">&#x27;$10&#x27;</span>, <span class="attr">ambiance</span>: <span class="string">&#x27;noisy&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> search = &#123; <span class="attr">food</span>: <span class="string">&#x27;rich&#x27;</span>, ...defaults &#125;</span><br></pre></td></tr></table></figure><p>那么，<code>defaults</code> 里的 <code>food</code> 属性会重写 <code>food: &#39;rich&#39;</code>，在这里这并不是我们想要的结果。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p><h2 id="接口初探"><a href="#接口初探" class="headerlink" title="接口初探"></a>接口初探</h2><p>下面通过一个简单示例来观察接口是如何工作的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printLabel</span>(<span class="params">labelledObj: &#123; label: <span class="built_in">string</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(labelledObj.<span class="property">label</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">size</span>: <span class="number">10</span>, <span class="attr">label</span>: <span class="string">&#x27;Size 10 Object&#x27;</span> &#125;</span><br><span class="line"><span class="title function_">printLabel</span>(myObj)</span><br></pre></td></tr></table></figure><p>类型检查器会查看 <code>printLabel</code> 的调用。<code>printLabel</code> 有一个参数，并要求这个对象参数有一个名为 <code>label</code> 类型为 <code>string</code> 的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，以及其类型是否匹配。 然而，有些时候 TypeScript 却并不会这么宽松，我们下面会稍做讲解。</p><p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个<code>label</code> 属性且类型为 <code>string</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">LabelledValue</span> &#123;</span><br><span class="line">  <span class="attr">label</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printLabel</span>(<span class="params">labelledObj: LabelledValue</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(labelledObj.<span class="property">label</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">size</span>: <span class="number">10</span>, <span class="attr">label</span>: <span class="string">&#x27;Size 10 Object&#x27;</span> &#125;</span><br><span class="line"><span class="title function_">printLabel</span>(myObj)</span><br></pre></td></tr></table></figure><p><code>LabelledValue</code> 接口就好比一个名字，用来描述上面例子里的结构。 它代表了有一个 <code>label</code> 属性且类型为<code>string</code> 的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 <code>printLabel</code> 的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p><p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p><h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。例如给函数传入的参数对象中只有部分属性赋值了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">area</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareConfig</span> &#123;</span><br><span class="line">  color?: <span class="built_in">string</span></span><br><span class="line">  width?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createSquare</span>(<span class="params">config: SquareConfig</span>): <span class="title class_">Square</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> newSquare = &#123; <span class="attr">color</span>: <span class="string">&#x27;white&#x27;</span>, <span class="attr">area</span>: <span class="number">100</span> &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.<span class="property">color</span>) &#123;</span><br><span class="line">    newSquare.<span class="property">color</span> = config.<span class="property">color</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.<span class="property">width</span>) &#123;</span><br><span class="line">    newSquare.<span class="property">area</span> = config.<span class="property">width</span> * config.<span class="property">width</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newSquare</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(&#123; <span class="attr">color</span>: <span class="string">&#x27;black&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 <code>?</code> 符号。</p><p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 <code>createSquare</code> 里的 <code>color</code> 属性名拼错，就会得到一个错误提示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">area</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareConfig</span> &#123;</span><br><span class="line">  color?: <span class="built_in">string</span></span><br><span class="line">  width?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createSquare</span>(<span class="params">config: SquareConfig</span>): <span class="title class_">Square</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> newSquare = &#123; <span class="attr">color</span>: <span class="string">&#x27;white&#x27;</span>, <span class="attr">area</span>: <span class="number">100</span> &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.<span class="property">clor</span>) &#123;</span><br><span class="line">    <span class="comment">// Error: 属性 &#x27;clor&#x27; 不存在于类型 &#x27;SquareConfig&#x27; 中</span></span><br><span class="line">    newSquare.<span class="property">color</span> = config.<span class="property">clor</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.<span class="property">width</span>) &#123;</span><br><span class="line">    newSquare.<span class="property">area</span> = config.<span class="property">width</span> * config.<span class="property">width</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newSquare</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(&#123; <span class="attr">color</span>: <span class="string">&#x27;black&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure><h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 <code>readonly</code> 来指定只读属性:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以通过赋值一个对象字面量来构造一个 <code>Point</code>。 赋值后，<code>x</code> 和 <code>y</code> 再也不能被改变了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">p1</span>: <span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;</span><br><span class="line">p1.<span class="property">x</span> = <span class="number">5</span> <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>TypeScript 具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">ro</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">number</span>&gt; = a</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span> <span class="comment">// error!</span></span><br><span class="line">ro.<span class="title function_">push</span>(<span class="number">5</span>) <span class="comment">// error!</span></span><br><span class="line">ro.<span class="property">length</span> = <span class="number">100</span> <span class="comment">// error!</span></span><br><span class="line">a = ro <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一行，可以看到就算把整个 <code>ReadonlyArray</code> 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ro <span class="keyword">as</span> <span class="built_in">number</span>[]</span><br></pre></td></tr></table></figure><h3 id="readonly-vs-const"><a href="#readonly-vs-const" class="headerlink" title="readonly vs const"></a>readonly vs const</h3><p>最简单判断该用 <code>readonly</code> 还是 <code>const</code> 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 <code>const</code>，若做为属性则使用 <code>readonly</code>。</p><h2 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h2><p>我们在第一个例子里使用了接口，TypeScript 让我们传入 <code>&#123; size: number; label: string; &#125;</code> 到仅期望得到 <code>&#123; label: string; &#125;</code> 的函数里, 并且我们已经学过了可选属性。</p><p>然而，天真地将这两者结合的话就会像在 JavaScript 里那样搬起石头砸自己的脚。 比如，拿 <code>createSquare</code> 例子来说：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareConfig</span> &#123;</span><br><span class="line">  color?: <span class="built_in">string</span></span><br><span class="line">  width?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createSquare</span>(<span class="params">config: SquareConfig</span>): &#123; <span class="attr">color</span>: <span class="built_in">string</span>; <span class="attr">area</span>: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> newSquare = &#123; <span class="attr">color</span>: <span class="string">&#x27;white&#x27;</span>, <span class="attr">area</span>: <span class="number">100</span> &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.<span class="property">color</span>) &#123;</span><br><span class="line">    newSquare.<span class="property">color</span> = config.<span class="property">color</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.<span class="property">width</span>) &#123;</span><br><span class="line">    newSquare.<span class="property">area</span> = config.<span class="property">width</span> * config.<span class="property">width</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newSquare</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(&#123; <span class="attr">colour</span>: <span class="string">&#x27;red&#x27;</span>, <span class="attr">width</span>: <span class="number">100</span> &#125;)</span><br></pre></td></tr></table></figure><p>注意传入 <code>createSquare</code> 的参数拼写为 <code>colour</code> 而不是 <code>color</code>。 在 JavaScript 里，这会默默地失败。</p><p>你可能会争辩这个程序已经正确地类型化了，因为 <code>width</code> 属性是兼容的，不存在 <code>color</code> 属性，而且额外的 <code>colour</code> 属性是无意义的。</p><p>然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error: &#x27;colour&#x27; 不存在于类型 &#x27;SquareConfig&#x27; 中</span></span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(&#123; <span class="attr">colour</span>: <span class="string">&#x27;red&#x27;</span>, <span class="attr">width</span>: <span class="number">100</span> &#125;)</span><br></pre></td></tr></table></figure><p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(&#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">opacity</span>: <span class="number">0.5</span> &#125; <span class="keyword">as</span> <span class="title class_">SquareConfig</span>)</span><br></pre></td></tr></table></figure><p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 <code>SquareConfig</code> 带有上面定义的类型的 <code>color</code> 和 <code>width</code> 属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareConfig</span> &#123;</span><br><span class="line">  color?: <span class="built_in">string</span></span><br><span class="line">  width?: <span class="built_in">number</span></span><br><span class="line">  [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们稍后会讲到索引签名，但在这我们要表示的是<code>SquareConfig</code> 可以有任意数量的属性，并且只要它们不是 <code>color</code> 和 <code>width</code>，那么就无所谓它们的类型是什么。</p><p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 <code>squareOptions</code> 不会经过额外属性检查，所以编译器不会报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squareOptions = &#123; <span class="attr">colour</span>: <span class="string">&#x27;red&#x27;</span>, <span class="attr">width</span>: <span class="number">100</span> &#125;</span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(squareOptions)</span><br></pre></td></tr></table></figure><p>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大多数额外属性检查错误是真正的 bug。也就是说你遇到了额外类型检查出的错误，你应该去审查一下你的类型声明。 在这里，如果支持传入 <code>color</code> 或 <code>colour</code> 属性到 <code>createSquare</code>，你应该修改 <code>SquareConfig</code> 定义来体现出这一点。</p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p><p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SearchFunc</span> &#123;</span><br><span class="line">  (<span class="attr">source</span>: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">mySearch</span>: <span class="title class_">SearchFunc</span></span><br><span class="line">mySearch = <span class="keyword">function</span> (<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.<span class="title function_">search</span>(subString)</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">mySearch</span>: <span class="title class_">SearchFunc</span></span><br><span class="line">mySearch = <span class="keyword">function</span> (<span class="params">src: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = src.<span class="title function_">search</span>(sub)</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了 <code>SearchFunc</code> 类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 <code>false</code> 和 <code>true</code>）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 <code>SearchFunc</code> 接口中的定义不匹配。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">mySearch</span>: <span class="title class_">SearchFunc</span></span><br><span class="line">mySearch = <span class="keyword">function</span> (<span class="params">src, sub</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = src.<span class="title function_">search</span>(sub)</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h2><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 <code>a[10]</code> 或 <code>ageMap[&#39;daniel&#39;]</code>。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">StringArray</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myArray</span>: <span class="title class_">StringArray</span></span><br><span class="line">myArray = [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Fred&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myStr</span>: <span class="built_in">string</span> = myArray[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>上面例子里，我们定义了 <code>StringArray</code> 接口，它具有索引签名。 这个索引签名表示了当用 <code>number</code> 去索引 <code>StringArray</code> 时会得到 <code>string</code> 类型的返回值。</p><p>TypeScript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 <code>number</code> 来索引时，JavaScript 会将它转换成<code>string</code> 然后再去索引对象。 也就是说用 <code>100</code>（一个 <code>number</code>）去索引等同于使用<code>&#39;100&#39;</code>（一个 <code>string</code> ）去索引，因此两者需要保持一致。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="attr">breed</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NotOkay</span> &#123;</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">number</span>]: <span class="title class_">Animal</span></span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="title class_">Dog</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串索引签名能够很好的描述 <code>dictionary</code> 模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 <code>obj.property</code> 和 <code>obj[&#39;property&#39;]</code> 两种形式都可以。 下面的例子里， <code>name</code> 的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">NumberDictionary</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">string</span>]: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span> <span class="comment">// 可以，length是number类型</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> <span class="comment">// 错误，`name`的类型与索引类型返回值的类型不匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadonlyStringArray</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myArray</span>: <span class="title class_">ReadonlyStringArray</span> = [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>]</span><br><span class="line">myArray[<span class="number">2</span>] = <span class="string">&#x27;Mallory&#x27;</span> <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">  <span class="attr">currentTime</span>: <span class="title class_">Date</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> <span class="keyword">implements</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">  <span class="attr">currentTime</span>: <span class="title class_">Date</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以在接口中描述一个方法，在类里实现它，如同下面的 <code>setTime</code> 方法一样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">  <span class="attr">currentTime</span>: <span class="title class_">Date</span></span><br><span class="line">  <span class="title function_">setTime</span>(<span class="attr">d</span>: <span class="title class_">Date</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> <span class="keyword">implements</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">  <span class="attr">currentTime</span>: <span class="title class_">Date</span></span><br><span class="line">  <span class="title function_">setTime</span>(<span class="params">d: <span class="built_in">Date</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentTime</span> = d</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p><h3 id="类静态部分与实例部分的区别"><a href="#类静态部分与实例部分的区别" class="headerlink" title="类静态部分与实例部分的区别"></a>类静态部分与实例部分的区别</h3><p>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClockConstructor</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> (<span class="attr">hour</span>: <span class="built_in">number</span>, <span class="attr">minute</span>: <span class="built_in">number</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> <span class="keyword">implements</span> <span class="title class_">ClockConstructor</span> &#123;</span><br><span class="line">  <span class="attr">currentTime</span>: <span class="title class_">Date</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。<code>constructor</code> 存在于类的静态部分，所以不在检查的范围内。</p><p>看下面的例子，我们定义了两个接口， <code>ClockConstructor</code> 为构造函数所用和 <code>ClockInterface</code> 为实例方法所用。 为了方便我们定义一个构造函数 <code>createClock</code>，它用传入的类型创建实例。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClockConstructor</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> (<span class="attr">hour</span>: <span class="built_in">number</span>, <span class="attr">minute</span>: <span class="built_in">number</span>): <span class="title class_">ClockInterface</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">  <span class="title function_">tick</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createClock</span>(<span class="params"></span></span><br><span class="line"><span class="params">  ctor: ClockConstructor,</span></span><br><span class="line"><span class="params">  hour: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  minute: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">ctor</span>(hour, minute)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DigitalClock</span> <span class="keyword">implements</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beep beep&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnalogClock</span> <span class="keyword">implements</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;tick tock&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> digital = <span class="title function_">createClock</span>(<span class="title class_">DigitalClock</span>, <span class="number">12</span>, <span class="number">17</span>)</span><br><span class="line"><span class="keyword">let</span> analog = <span class="title function_">createClock</span>(<span class="title class_">AnalogClock</span>, <span class="number">7</span>, <span class="number">32</span>)</span><br></pre></td></tr></table></figure><p>因为 <code>createClock</code> 的第一个参数是 <code>ClockConstructor</code> 类型，在 <code>createClock(AnalogClock, 7, 32)</code> 里，会检查 <code>AnalogClock</code> 是否符合构造函数签名。</p><h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">sideLength</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &#123;&#125; <span class="keyword">as</span> <span class="title class_">Square</span></span><br><span class="line">square.<span class="property">color</span> = <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">square.<span class="property">sideLength</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PenStroke</span> &#123;</span><br><span class="line">  <span class="attr">penWidth</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>, <span class="title class_">PenStroke</span> &#123;</span><br><span class="line">  <span class="attr">sideLength</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &#123;&#125; <span class="keyword">as</span> <span class="title class_">Square</span></span><br><span class="line">square.<span class="property">color</span> = <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">square.<span class="property">sideLength</span> = <span class="number">10</span></span><br><span class="line">square.<span class="property">penWidth</span> = <span class="number">5.0</span></span><br></pre></td></tr></table></figure><h2 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h2><p>先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p><p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">  (<span class="attr">start</span>: <span class="built_in">number</span>): <span class="built_in">string</span></span><br><span class="line">  <span class="attr">interval</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">reset</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCounter</span>(<span class="params"></span>): <span class="title class_">Counter</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) &#123;&#125; <span class="keyword">as</span> <span class="title class_">Counter</span></span><br><span class="line">  counter.<span class="property">interval</span> = <span class="number">123</span></span><br><span class="line">  counter.<span class="property">reset</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="title function_">getCounter</span>()</span><br><span class="line"><span class="title function_">c</span>(<span class="number">10</span>)</span><br><span class="line">c.<span class="title function_">reset</span>()</span><br><span class="line">c.<span class="property">interval</span> = <span class="number">5.0</span></span><br></pre></td></tr></table></figure><p>在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。这门课要重构的 <code>axios</code> 库就是一个很好的例子。</p><h2 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h2><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 <code>private</code> 和 <code>protected</code> 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p><p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Control</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">state</span>: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SelectableControl</span> <span class="keyword">extends</span> <span class="title class_">Control</span> &#123;</span><br><span class="line">  <span class="title function_">select</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Control</span> <span class="keyword">implements</span> <span class="title class_">SelectableControl</span> &#123;</span><br><span class="line">  <span class="title function_">select</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBox</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Control</span> &#123;</span><br><span class="line">  <span class="title function_">select</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error：“ImageC”类型缺少“state”属性。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageC</span> <span class="keyword">implements</span> <span class="title class_">SelectableControl</span> &#123;</span><br><span class="line">  <span class="title function_">select</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子里，<code>SelectableControl</code> 包含了 <code>Control</code> 的所有成员，包括私有成员 <code>state</code>。 因为 <code>state</code> 是私有成员，所以只能够是 <code>Control</code> 的子类们才能实现 <code>SelectableControl</code> 接口。 因为只有 <code>Control</code> 的子类才能够拥有一个声明于<code>Control</code> 的私有成员 <code>state</code>，这对私有成员的兼容性是必需的。</p><p>在 <code>Control</code> 类内部，是允许通过 <code>SelectableControl</code> 的实例来访问私有成员 <code>state</code> 的。 实际上，<code>SelectableControl</code> 接口和拥有 <code>select</code> 方法的 <code>Control</code> 类是一样的。<code>Button</code>和 <code>TextBox</code> 类是 <code>SelectableControl</code> 的子类（因为它们都继承自<code>Control</code> 并有 <code>select</code> 方法），但 <code>ImageC</code> 类并不是这样的。</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>对于传统的 JavaScript 程序我们会使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ES6 开始， JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。</p><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><p>下面看一个使用类的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&#x27;world&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果你使用过 C# 或 Java，你会对这种语法非常熟悉。 我们声明一个 <code>Greeter</code> 类。这个类有 3 个成员：一个叫做 <code>greeting</code> 的属性，一个构造函数和一个 <code>greet</code> 方法。</p><p>你会注意到，我们在引用任何一个类成员的时候都用了 <code>this</code>。 它表示我们访问的是类的成员。</p><p>最后一行，我们使用 <code>new</code> 构造了 <code>Greeter</code> 类的一个实例。它会调用之前定义的构造函数，创建一个 <code>Greeter</code> 类型的新对象，并执行构造函数初始化它。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p><p>看下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">move</span>(<span class="params">distance: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Animal moved <span class="subst">$&#123;distance&#125;</span>m.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">bark</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Woof! Woof!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>()</span><br><span class="line">dog.<span class="title function_">bark</span>()</span><br><span class="line">dog.<span class="title function_">move</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，<code>Dog</code> 是一个 派生类，它派生自 <code>Animal</code> 基类，通过 <code>extends</code> 关键字。 派生类通常被称作<em>子类</em>，基类通常被称作<em>超类</em>。</p><p>因为 <code>Dog</code> 继承了 <code>Animal</code> 的功能，因此我们可以创建一个 <code>Dog</code> 的实例，它能够 <code>bark()</code> 和 <code>move()</code>。</p><p>下面我们来看个更加复杂的例子。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">move</span>(<span class="params">distance: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> moved <span class="subst">$&#123;distance&#125;</span>m.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snake</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">move</span>(<span class="params">distance: <span class="built_in">number</span> = <span class="number">5</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Slithering...&#x27;</span>)</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">move</span>(distance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Horse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">move</span>(<span class="params">distance: <span class="built_in">number</span> = <span class="number">45</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Galloping...&#x27;</span>)</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">move</span>(distance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sam = <span class="keyword">new</span> <span class="title class_">Snake</span>(<span class="string">&#x27;Sammy&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Animal</span> = <span class="keyword">new</span> <span class="title class_">Horse</span>(<span class="string">&#x27;Tommy&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sam.<span class="title function_">move</span>()</span><br><span class="line">tom.<span class="title function_">move</span>(<span class="number">34</span>)</span><br></pre></td></tr></table></figure><p>这个例子展示了一些上面没有提到的特性。 这一次，我们使用 <code>extends</code> 关键字创建了 Animal 的两个子类：<code>Horse</code> 和 <code>Snake</code>。</p><p>与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 <code>super()</code>，它会执行基类的构造函数。 而且，在构造函数里访问 <code>this</code> 的属性之前，我们 一定要调用 <code>super()</code>。 这个是 TypeScript 强制执行的一条重要规则。</p><p>这个例子演示了如何在子类里可以重写父类的方法。<code>Snake</code>类和 <code>Horse</code> 类都创建了 <code>move</code> 方法，它们重写了从 <code>Animal</code> 继承来的 <code>move</code> 方法，使得 <code>move</code> 方法根据不同的类而具有不同的功能。注意，即使 <code>tom</code> 被声明为 <code>Animal</code> 类型，但因为它的值是 <code>Horse</code>，调用 <code>tom.move(34)</code> 时，它会调用 <code>Horse</code> 里重写的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Slithering...</span><br><span class="line">Sammy moved 5m.</span><br><span class="line">Galloping...</span><br><span class="line">Tommy moved 34m.</span><br></pre></td></tr></table></figure><h2 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="headerlink" title="公共，私有与受保护的修饰符"></a>公共，私有与受保护的修饰符</h2><h3 id="默认为-public"><a href="#默认为-public" class="headerlink" title="默认为 public"></a>默认为 public</h3><p>在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 <code>public</code> 来做修饰；例如，C# 要求必须明确地使用 <code>public</code> 指定成员是可见的。 在 TypeScript 里，成员都默认为 <code>public</code>。</p><p>你也可以明确的将一个成员标记成 <code>public</code>。 我们可以用下面的方式来重写上面的 <code>Animal</code> 类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">move</span>(<span class="params">distance: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> moved <span class="subst">$&#123;distance&#125;</span>m.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="理解-private"><a href="#理解-private" class="headerlink" title="理解 private"></a>理解 private</h3><p>当成员被标记成 <code>private</code> 时，它就不能在声明它的类的外部访问。比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Cat&#x27;</span>).<span class="property">name</span> <span class="comment">// 错误: &#x27;name&#x27; 是私有的.</span></span><br></pre></td></tr></table></figure><p>TypeScript 使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。</p><p>然而，当我们比较带有 <code>private</code> 或 <code>protected</code> 成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 <code>private</code> 成员，那么只有当另外一个类型中也存在这样一个 <code>private</code> 成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 <code>protected</code> 成员也使用这个规则。</p><p>下面来看一个例子，更好地说明了这一点：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rhino</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(<span class="string">&#x27;Rhino&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Goat&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> rhino = <span class="keyword">new</span> <span class="title class_">Rhino</span>()</span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line"></span><br><span class="line">animal = rhino</span><br><span class="line">animal = employee <span class="comment">// 错误: Animal 与 Employee 不兼容.</span></span><br></pre></td></tr></table></figure><p>这个例子中有 <code>Animal</code> 和 <code>Rhino</code> 两个类， <code>Rhino</code> 是 <code>Animal</code> 类的子类。 还有一个 <code>Employee</code> 类，其类型看上去与 <code>Animal</code> 是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 <code>Animal</code> 和 <code>Rhino</code> 共享了来自 <code>Animal</code> 里的私有成员定义 <code>private name: string</code>，因此它们是兼容的。然而 <code>Employee</code> 却不是这样。当把 <code>Employee</code> 赋值给 <code>Animal</code> 的时候，得到一个错误，说它们的类型不兼容。尽管 <code>Employee</code> 里也有一个私有成员 <code>name</code>，但它明显不是 <code>Animal</code> 里面定义的那个。</p><h3 id="理解-protected"><a href="#理解-protected" class="headerlink" title="理解 protected"></a>理解 protected</h3><p><code>protected</code> 修饰符与 <code>private</code> 修饰符的行为很相似，但有一点不同，<code>protected</code>成员在派生类中仍然可以访问。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">department</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">department</span> = department</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getElevatorPitch</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="variable language_">this</span>.department&#125;</span>.`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&#x27;Howard&#x27;</span>, <span class="string">&#x27;Sales&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(howard.<span class="title function_">getElevatorPitch</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(howard.<span class="property">name</span>) <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>注意，我们不能在 <code>Person</code> 类外使用 <code>name</code>，但是我们仍然可以通过 <code>Employee</code> 类的实例方法访问，因为 <code>Employee</code> 是由 <code>Person</code> 派生而来的。</p><p>构造函数也可以被标记成 <code>protected</code>。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee 能够继承 Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">department</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">department</span> = department</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">getElevatorPitch</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="variable language_">this</span>.department&#125;</span>.`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&#x27;Howard&#x27;</span>, <span class="string">&#x27;Sales&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;John&#x27;</span>) <span class="comment">// 错误: &#x27;Person&#x27; 的构造函数是被保护的.</span></span><br></pre></td></tr></table></figure><h2 id="readonly-修饰符"><a href="#readonly-修饰符" class="headerlink" title="readonly 修饰符"></a>readonly 修饰符</h2><p>你可以使用 <code>readonly</code> 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;John&#x27;</span>)</span><br><span class="line">john.<span class="property">name</span> = <span class="string">&#x27;peter&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>在上面的例子中，我们必须在 <code>Person</code> 类里定义一个只读成员 <code>name</code> 和一个参数为 <code>name</code> 的构造函数，并且立刻将 <code>name</code> 的值赋给 <code>this.name</code>，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 <code>Person</code> 类的修改版，使用了参数属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">readonly</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看我们是如何舍弃参数 <code>name</code>，仅在构造函数里使用 <code>readonly name: string</code> 参数来创建和初始化 <code>name</code> 成员。 我们把声明和赋值合并至一处。</p><p>参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 <code>private</code> 限定一个参数属性会声明并初始化一个私有成员；对于 <code>public</code> 和 <code>protected</code> 来说也是一样。</p><h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><p><code>TypeScript</code> 支持通过 <code>getters/setters</code> 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p><p>下面来看如何把一个简单的类改写成使用 <code>get</code> 和 <code>set</code>。 首先，我们从一个没有使用存取器的例子开始。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="attr">fullName</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> <span class="title class_">Employee</span>()</span><br><span class="line">employee.<span class="property">fullName</span> = <span class="string">&#x27;Bob Smith&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (employee.<span class="property">fullName</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(employee.<span class="property">fullName</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以设置 <code>fullName</code>，因为它是 <code>public</code> 的，有时候当我们去修改它的时候触发一些额外逻辑，存取器就派上用场了。</p><p>下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。我们把对 <code>fullName</code> 的直接访问改成了可以检查密码的 <code>set</code> 方法。 我们也加了一个 <code>get</code> 方法，让上面的例子仍然可以工作。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">&#x27;secret passcode&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_fullName</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_fullName</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">fullName</span>(<span class="params">newName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">&#x27;secret passcode&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_fullName</span> = newName</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error: Unauthorized update of employee!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> <span class="title class_">Employee</span>()</span><br><span class="line">employee.<span class="property">fullName</span> = <span class="string">&#x27;Bob Smith&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (employee.<span class="property">fullName</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(employee.<span class="property">fullName</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。</p><p>对于存取器有下面几点需要注意的：</p><p>首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。其次，只带有 <code>get</code> 不带有 <code>set</code> 的存取器自动被推断为 <code>readonly</code>。这在从代码生成 <code>.d.ts</code> 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</p><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 <code>static</code> 定义 <code>origin</code>，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 <code>origin</code> 前面加上类名。 如同在实例属性上使用 <code>this.xxx</code> 来访问属性一样，这里我们使用 <code>Grid.xxx</code> 来访问静态属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grid</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> origin = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attr">scale</span>: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">scale: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">scale</span> = scale</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">calculateDistanceFromOrigin</span>(<span class="params">point: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> xDist = point.<span class="property">x</span> - <span class="title class_">Grid</span>.<span class="property">origin</span>.<span class="property">x</span></span><br><span class="line">    <span class="keyword">let</span> yDist = point.<span class="property">y</span> - <span class="title class_">Grid</span>.<span class="property">origin</span>.<span class="property">y</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(xDist * xDist + yDist * yDist) * <span class="variable language_">this</span>.<span class="property">scale</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> grid1 = <span class="keyword">new</span> <span class="title class_">Grid</span>(<span class="number">1.0</span>) <span class="comment">// 1x scale</span></span><br><span class="line"><span class="keyword">let</span> grid2 = <span class="keyword">new</span> <span class="title class_">Grid</span>(<span class="number">5.0</span>) <span class="comment">// 5x scale</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(grid1.<span class="title function_">calculateDistanceFromOrigin</span>(&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">4</span> &#125;))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(grid2.<span class="title function_">calculateDistanceFromOrigin</span>(&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">4</span> &#125;))</span><br></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。 <code>abstract</code> 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">makeSound</span>(): <span class="built_in">void</span></span><br><span class="line">  <span class="title function_">move</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;roaming the earth...&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 <code>abstract</code> 关键字并且可以包含访问修饰符。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">printName</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Department name: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">printMeeting</span>(): <span class="built_in">void</span> <span class="comment">// 必须在派生类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountingDepartment</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Department</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(<span class="string">&#x27;Accounting and Auditing&#x27;</span>) <span class="comment">// 在派生类的构造函数中必须调用 super()</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">printMeeting</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The Accounting Department meets each Monday at 10am.&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">generateReports</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Generating accounting reports...&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">department</span>: <span class="title class_">Department</span> <span class="comment">// 允许创建一个对抽象类型的引用</span></span><br><span class="line">department = <span class="keyword">new</span> <span class="title class_">Department</span>() <span class="comment">// 错误: 不能创建一个抽象类的实例</span></span><br><span class="line">department = <span class="keyword">new</span> <span class="title class_">AccountingDepartment</span>() <span class="comment">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class="line">department.<span class="title function_">printName</span>()</span><br><span class="line">department.<span class="title function_">printMeeting</span>()</span><br><span class="line">department.<span class="title function_">generateReports</span>() <span class="comment">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure><h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>当你在 TypeScript 里声明了一个类的时候，实际上同时声明了很多东西。首先就是类的<em>实例</em>的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> standardGreeting = <span class="string">&#x27;Hello, there&#x27;</span></span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">greeter</span>: <span class="title class_">Greeter</span></span><br><span class="line">greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeter.<span class="title function_">greet</span>())</span><br></pre></td></tr></table></figure><p>这里，我们写了 <code>let greeter: Greeter</code>，意思是 <code>Greeter</code> 类的实例的类型是 <code>Greeter</code>。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。</p><p>我们也创建了一个叫做<em>构造函数的值</em>。 这个函数会在我们使用 <code>new</code> 创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成 JavaScript 后是什么样子的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Greeter</span> = <span class="comment">/** <span class="doctag">@class</span> */</span> (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Greeter</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Greeter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Greeter</span>.<span class="property">standardGreeting</span> = <span class="string">&#x27;Hello, there&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Greeter</span></span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">var</span> greeter</span><br><span class="line">greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeter.<span class="title function_">greet</span>())</span><br></pre></td></tr></table></figure><p>上面的代码里，<code>var Greeter</code> 将被构造函数赋值。 当我们调用 <code>new</code> 并执行了这个函数后，便会得到一个类的实例。这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有<em>实例部分</em>与<em>静态部分</em>这两个部分。</p><p>让我们稍微改写一下这个例子，看看它们之间的区别：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> standardGreeting = <span class="string">&#x27;Hello, there&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">greeting</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Greeter</span>.<span class="property">standardGreeting</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">greeter</span>: <span class="title class_">Greeter</span></span><br><span class="line">greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeter.<span class="title function_">greet</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">greeterMaker</span>: <span class="keyword">typeof</span> <span class="title class_">Greeter</span> = <span class="title class_">Greeter</span></span><br><span class="line">greeterMaker.<span class="property">standardGreeting</span> = <span class="string">&#x27;Hey there&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">greeter2</span>: <span class="title class_">Greeter</span> = <span class="keyword">new</span> <span class="title function_">greeterMaker</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeter2.<span class="title function_">greet</span>())</span><br></pre></td></tr></table></figure><p>这个例子里， <code>greeter1</code> 与之前看到的一样。 我们实例化 Greeter 类，并使用这个对象。 与我们之前看到的一样。</p><p>再之后，我们直接使用类。 我们创建了一个叫做 <code>greeterMaker</code> 的变量。这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 <code>typeof Greeter</code>，意思是取 <code>Greeter</code> 类的类型，而不是实例的类型。或者更确切的说，”告诉我 <code>Greeter</code> 标识符的类型”，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 <code>greeterMaker</code> 上使用 <code>new</code>，创建 <code>Greeter</code> 的实例。</p><h3 id="把类当做接口使用"><a href="#把类当做接口使用" class="headerlink" title="把类当做接口使用"></a>把类当做接口使用</h3><p>如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3</span>d <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">point3d</span>: <span class="title class_">Point3</span>d = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。</p><h2 id="基本示例-1"><a href="#基本示例-1" class="headerlink" title="基本示例"></a>基本示例</h2><p>和 JavaScript 一样，TypeScript 函数可以创建有名字的函数和匿名函数。你可以随意选择适合应用程序的方式，不论是定义一系列 API 函数还是只使用一次的函数。</p><p>通过下面的例子可以迅速回想起这两种 JavaScript 中的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 JavaScript 里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习 JavaScript 和 TypeScript 会很有帮助。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addToZ</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数类型-1"><a href="#函数类型-1" class="headerlink" title="函数类型"></a>函数类型</h2><h3 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h3><p>让我们为上面那个函数添加类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript 能够根据返回语句自动推断出返回值类型。</p><h3 id="书写完整函数类型"><a href="#书写完整函数类型" class="headerlink" title="书写完整函数类型"></a>书写完整函数类型</h3><p>现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myAdd</span>: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  x: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。这个名字只是为了增加可读性。 我们也可以这么写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myAdd</span>: <span class="function">(<span class="params">baseValue: <span class="built_in">number</span>, increment: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  x: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。</p><p>第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用(<code>=&gt;</code>)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 <code>void</code> 而不能留空。</p><p>函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成 API 的一部分。</p><h3 id="推断类型"><a href="#推断类型" class="headerlink" title="推断类型"></a>推断类型</h3><p>尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myAdd = <span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myAdd</span>: <span class="function">(<span class="params">baseValue: <span class="built_in">number</span>, increment: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这叫做“按上下文归类”，是类型推论的一种。它帮助我们更好地为程序指定类型。</p><h2 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h2><p>TypeScript 里的每个函数参数都是必须的。 这不是指不能传递 <code>null</code> 或 <code>undefined</code> 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="title function_">buildName</span>(<span class="string">&#x27;Bob&#x27;</span>) <span class="comment">// Error, 参数过少</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title function_">buildName</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Adams&#x27;</span>, <span class="string">&#x27;Sr.&#x27;</span>) <span class="comment">// Error, 参数过多</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="title function_">buildName</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Adams&#x27;</span>) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 <code>undefined</code>。 在 TypeScript 里我们可以在参数名旁使用 <code>?</code> 实现可选参数的功能。 比如，我们想让 <code>lastName</code> 是可选的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (lastName) <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> firstName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="title function_">buildName</span>(<span class="string">&#x27;Bob&#x27;</span>) <span class="comment">// 现在正常了</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title function_">buildName</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Adams&#x27;</span>, <span class="string">&#x27;Sr.&#x27;</span>) <span class="comment">// Error, 参数过多</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="title function_">buildName</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Adams&#x27;</span>) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>可选参数必须跟在必须参数后面。 如果上例我们想让 <code>firstName</code> 是可选的，那么就必须调整它们的位置，把 <code>firstName</code> 放在后面。</p><p>在 TypeScript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 <code>undefined</code> 时。 它们叫做有默认初始化值的参数。 让我们修改上例，把<code>lastName</code> 的默认值设置为 <code>&quot;Smith&quot;</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName = <span class="string">&#x27;Smith&#x27;</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="title function_">buildName</span>(<span class="string">&#x27;Bob&#x27;</span>) <span class="comment">// 返回 &quot;Bob Smith&quot;</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title function_">buildName</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="literal">undefined</span>) <span class="comment">// 正常, 同样 &quot;Bob Smith&quot;</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="title function_">buildName</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Adams&#x27;</span>, <span class="string">&#x27;Sr.&#x27;</span>) <span class="comment">// 错误, 参数过多</span></span><br><span class="line"><span class="keyword">let</span> result4 = <span class="title function_">buildName</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Adams&#x27;</span>) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 <code>undefined</code> 值来获得默认值。 例如，我们重写最后一个例子，让 <code>firstName</code> 是带默认值的参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName = <span class="string">&#x27;Will&#x27;</span>, lastName: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="title function_">buildName</span>(<span class="string">&#x27;Bob&#x27;</span>) <span class="comment">// Error, 参数过少</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title function_">buildName</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Adams&#x27;</span>, <span class="string">&#x27;Sr.&#x27;</span>) <span class="comment">// Error, 参数过多</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="title function_">buildName</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Adams&#x27;</span>) <span class="comment">// OK， 返回 &quot;Bob Adams&quot;</span></span><br><span class="line"><span class="keyword">let</span> result4 = <span class="title function_">buildName</span>(<span class="literal">undefined</span>, <span class="string">&#x27;Adams&#x27;</span>) <span class="comment">// OK，  返回 &quot;Will Adams&quot;</span></span><br></pre></td></tr></table></figure><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 JavaScript 里，你可以使用 <code>arguments</code> 来访问所有传入的参数。</p><p>在 TypeScript 里，你可以把所有参数收集到一个变量里：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + restOfName.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employeeName = <span class="title function_">buildName</span>(<span class="string">&#x27;Joseph&#x27;</span>, <span class="string">&#x27;Samuel&#x27;</span>, <span class="string">&#x27;Lucas&#x27;</span>, <span class="string">&#x27;MacKinzie&#x27;</span>)</span><br></pre></td></tr></table></figure><p>剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ <code>...</code>）后面给定的名字，你可以在函数体内使用这个数组。</p><p>这个省略号也会在带有剩余参数的函数类型定义上使用到：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + restOfName.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">buildNameFun</span>: <span class="function">(<span class="params">fname: <span class="built_in">string</span>, ...rest: <span class="built_in">string</span>[]</span>) =&gt;</span> <span class="built_in">string</span> = buildName</span><br></pre></td></tr></table></figure><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>学习如何在 JavaScript 里正确使用 <code>this</code> 就好比一场成年礼。由于 TypeScript 是 JavaScript 的超集，TypeScript 程序员也需要弄清 <code>this</code> 工作机制并且当有 bug 的时候能够找出错误所在。 幸运的是，TypeScript 能通知你错误地使用了 <code>this</code> 的地方。 如果你想了解 JavaScript 里的 this 是如何工作的，那么首先阅读 Yehuda Katz 写的 <a target="_blank" rel="noopener" href="http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/">Understanding JavaScript Function Invocation and “this”</a>。 Yehuda 的文章详细的阐述了 <code>this</code> 的内部工作原理，因此我们这里只做简单介绍。</p><h3 id="this-和箭头函数"><a href="#this-和箭头函数" class="headerlink" title="this 和箭头函数"></a>this 和箭头函数</h3><p>JavaScript 里，<code>this</code> 的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。</p><p>下面看一个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">  <span class="attr">suits</span>: [<span class="string">&#x27;hearts&#x27;</span>, <span class="string">&#x27;spades&#x27;</span>, <span class="string">&#x27;clubs&#x27;</span>, <span class="string">&#x27;diamonds&#x27;</span>],</span><br><span class="line">  <span class="attr">cards</span>: <span class="title class_">Array</span>(<span class="number">52</span>),</span><br><span class="line">  <span class="attr">createCardPicker</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> pickedCard = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">52</span>)</span><br><span class="line">      <span class="keyword">let</span> pickedSuit = <span class="title class_">Math</span>.<span class="title function_">floor</span>(pickedCard / <span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">suit</span>: <span class="variable language_">this</span>.<span class="property">suits</span>[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.<span class="title function_">createCardPicker</span>()</span><br><span class="line"><span class="keyword">let</span> pickedCard = <span class="title function_">cardPicker</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;card: &#x27;</span> + pickedCard.<span class="property">card</span> + <span class="string">&#x27; of &#x27;</span> + pickedCard.<span class="property">suit</span>)</span><br></pre></td></tr></table></figure><p>可以看到 <code>createCardPicker</code> 是个函数，并且它又返回了一个函数。如果我们尝试运行这个程序，会发现它并没有输出而是报错了。 因为 <code>createCardPicker</code> 返回的函数里的 <code>this</code> 被设置成了 <code>global</code> 而不是 <code>deck</code> 对象。 因为我们只是独立的调用了 <code>cardPicker()</code>。 顶级的非方法式调用会将 <code>this</code> 视为 <code>global</code>。</p><p>为了解决这个问题，我们可以在函数被返回时就绑好正确的<code>this</code>。 这样的话，无论之后怎么使用它，都会引用绑定的<code>deck</code> 对象。 我们需要改变函数表达式来使用 ECMAScript 6 箭头语法。 箭头函数能保存函数创建时的 <code>this</code> 值，而不是调用时的值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">  <span class="attr">suits</span>: [<span class="string">&#x27;hearts&#x27;</span>, <span class="string">&#x27;spades&#x27;</span>, <span class="string">&#x27;clubs&#x27;</span>, <span class="string">&#x27;diamonds&#x27;</span>],</span><br><span class="line">  <span class="attr">cards</span>: <span class="title class_">Array</span>(<span class="number">52</span>),</span><br><span class="line">  <span class="attr">createCardPicker</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 注意：这里使用箭头函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> pickedCard = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">52</span>)</span><br><span class="line">      <span class="keyword">let</span> pickedSuit = <span class="title class_">Math</span>.<span class="title function_">floor</span>(pickedCard / <span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">suit</span>: <span class="variable language_">this</span>.<span class="property">suits</span>[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.<span class="title function_">createCardPicker</span>()</span><br><span class="line"><span class="keyword">let</span> pickedCard = <span class="title function_">cardPicker</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;card: &#x27;</span> + pickedCard.<span class="property">card</span> + <span class="string">&#x27; of &#x27;</span> + pickedCard.<span class="property">suit</span>)</span><br></pre></td></tr></table></figure><h3 id="this-参数"><a href="#this-参数" class="headerlink" title="this 参数"></a>this 参数</h3><p>在上述的例子中 <code>this.suits[pickedSuit]</code> 的类型为 <code>any</code>，这是因为 <code>this</code> 来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 <code>this</code> 参数。 <code>this</code> 参数是个假的参数，它出现在参数列表的最前面：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">void</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 确保“this”在此独立函数中不可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们往例子里添加一些接口，<code>Card</code> 和 <code>Deck</code>，让类型重用能够变得清晰简单些：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Card</span> &#123;</span><br><span class="line">  <span class="attr">suit</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">card</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Deck</span> &#123;</span><br><span class="line">  <span class="attr">suits</span>: <span class="built_in">string</span>[]</span><br><span class="line">  <span class="attr">cards</span>: <span class="built_in">number</span>[]</span><br><span class="line"></span><br><span class="line">  <span class="title function_">createCardPicker</span>(<span class="attr">this</span>: <span class="title class_">Deck</span>): <span class="function">() =&gt;</span> <span class="title class_">Card</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">deck</span>: <span class="title class_">Deck</span> = &#123;</span><br><span class="line">  <span class="attr">suits</span>: [<span class="string">&#x27;hearts&#x27;</span>, <span class="string">&#x27;spades&#x27;</span>, <span class="string">&#x27;clubs&#x27;</span>, <span class="string">&#x27;diamonds&#x27;</span>],</span><br><span class="line">  <span class="attr">cards</span>: <span class="title class_">Array</span>(<span class="number">52</span>),</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> 函数现在显式指定其被调用方必须是 deck 类型</span></span><br><span class="line">  <span class="attr">createCardPicker</span>: <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: Deck</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> pickedCard = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">52</span>)</span><br><span class="line">      <span class="keyword">let</span> pickedSuit = <span class="title class_">Math</span>.<span class="title function_">floor</span>(pickedCard / <span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">suit</span>: <span class="variable language_">this</span>.<span class="property">suits</span>[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.<span class="title function_">createCardPicker</span>()</span><br><span class="line"><span class="keyword">let</span> pickedCard = <span class="title function_">cardPicker</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;card: &#x27;</span> + pickedCard.<span class="property">card</span> + <span class="string">&#x27; of &#x27;</span> + pickedCard.<span class="property">suit</span>)</span><br></pre></td></tr></table></figure><p>现在 TypeScrip t 知道 <code>createCardPicker</code> 期望在某个 <code>Deck</code> 对象上调用。也就是说 <code>this</code> 是 <code>Deck</code> 类型的，而非 <code>any</code>。</p><h3 id="this-参数在回调函数里"><a href="#this-参数在回调函数里" class="headerlink" title="this 参数在回调函数里"></a>this 参数在回调函数里</h3><p>你可以也看到过在回调函数里的 <code>this</code> 报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用，<code>this</code> 将为 <code>undefined</code>。 稍做改动，你就可以通过 <code>this</code> 参数来避免错误。 首先，库函数的作者要指定 <code>this</code> 的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UIElement</span> &#123;</span><br><span class="line">  <span class="title function_">addClickListener</span>(<span class="attr">onclick</span>: <span class="function">(<span class="params"><span class="variable language_">this</span>: <span class="built_in">void</span>, e: Event</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this: void</code> 意味着 <code>addClickListener</code> 期望传入的 <code>onclick</code> 方法不需要 <code>this</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UIElement</span> &#123;</span><br><span class="line">  <span class="title function_">addClickListener</span>(<span class="attr">onclick</span>: <span class="function">(<span class="params"><span class="variable language_">this</span>: <span class="built_in">void</span>, e: Event</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">onClickBad</span>(<span class="params"><span class="variable language_">this</span>: Handler, e: Event</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = e.<span class="property">type</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> <span class="title class_">Handler</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">uiElement</span>: <span class="title class_">UIElement</span> = &#123;</span><br><span class="line">  <span class="title function_">addClickListener</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uiElement.<span class="title function_">addClickListener</span>(h.<span class="property">onClickBad</span>) <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>指定了 <code>this</code> 类型后，你显式声明 <code>onClickBad</code> 必须在 <code>Handler</code> 的实例上调用。 然后 TypeScript 会检测到 <code>addClickListener</code> 要求函数带有 <code>this: void</code>。 改变 <code>this</code> 类型来修复这个错误：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">onClickBad</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">void</span>, e: Event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;clicked!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> <span class="title class_">Handler</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">uiElement</span>: <span class="title class_">UIElement</span> = &#123;</span><br><span class="line">  <span class="title function_">addClickListener</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uiElement.<span class="title function_">addClickListener</span>(h.<span class="property">onClickBad</span>)</span><br></pre></td></tr></table></figure><p>因为 <code>onClickGood</code> 指定了 <code>this</code> 类型为 <code>void</code>，因此传递 <code>addClickListener</code> 是合法的。 当然了，这也意味着不能使用 <code>this.info</code>。 如果你两者都想要，你不得不使用箭头函数了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="built_in">string</span></span><br><span class="line">  onClickGood = <span class="function">(<span class="params">e: Event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = e.<span class="property">type</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是可行的因为箭头函数不会捕获 <code>this</code>，所以你总是可以把它们传给期望 <code>this: void</code> 的函数。</p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>JavaScript 本身是个动态语言。JavaScript 里函数根据传入不同的参数而返回不同类型的数据的场景是很常见的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">&#x27;hearts&#x27;</span>, <span class="string">&#x27;spades&#x27;</span>, <span class="string">&#x27;clubs&#x27;</span>, <span class="string">&#x27;diamonds&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params">x</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(x)) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedCard = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * x.<span class="property">length</span>)</span><br><span class="line">    <span class="keyword">return</span> pickedCard</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedSuit = <span class="title class_">Math</span>.<span class="title function_">floor</span>(x / <span class="number">13</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">suit</span>: suits[pickedSuit], <span class="attr">card</span>: x % <span class="number">13</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [</span><br><span class="line">  &#123; <span class="attr">suit</span>: <span class="string">&#x27;diamonds&#x27;</span>, <span class="attr">card</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">suit</span>: <span class="string">&#x27;spades&#x27;</span>, <span class="attr">card</span>: <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">suit</span>: <span class="string">&#x27;hearts&#x27;</span>, <span class="attr">card</span>: <span class="number">4</span> &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[<span class="title function_">pickCard</span>(myDeck)]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;card: &#x27;</span> + pickedCard1.<span class="property">card</span> + <span class="string">&#x27; of &#x27;</span> + pickedCard1.<span class="property">suit</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = <span class="title function_">pickCard</span>(<span class="number">15</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;card: &#x27;</span> + pickedCard2.<span class="property">card</span> + <span class="string">&#x27; of &#x27;</span> + pickedCard2.<span class="property">suit</span>)</span><br></pre></td></tr></table></figure><p><code>pickCard</code> 方法根据传入参数的不同会返回两种不同的类型。如果传入的是代表纸牌的对象数组，函数作用是从中抓一张牌。如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。</p><p>方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载 <code>pickCard</code> 函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">&#x27;hearts&#x27;</span>, <span class="string">&#x27;spades&#x27;</span>, <span class="string">&#x27;clubs&#x27;</span>, <span class="string">&#x27;diamonds&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params">x: &#123; suit: <span class="built_in">string</span>; card: <span class="built_in">number</span> &#125;[]</span>): <span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params">x: <span class="built_in">number</span></span>): &#123; <span class="attr">suit</span>: <span class="built_in">string</span>; <span class="attr">card</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pickCard</span>(<span class="params">x</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(x)) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedCard = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * x.<span class="property">length</span>)</span><br><span class="line">    <span class="keyword">return</span> pickedCard</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pickedSuit = <span class="title class_">Math</span>.<span class="title function_">floor</span>(x / <span class="number">13</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">suit</span>: suits[pickedSuit], <span class="attr">card</span>: x % <span class="number">13</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [</span><br><span class="line">  &#123; <span class="attr">suit</span>: <span class="string">&#x27;diamonds&#x27;</span>, <span class="attr">card</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">suit</span>: <span class="string">&#x27;spades&#x27;</span>, <span class="attr">card</span>: <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">suit</span>: <span class="string">&#x27;hearts&#x27;</span>, <span class="attr">card</span>: <span class="number">4</span> &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[<span class="title function_">pickCard</span>(myDeck)]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;card: &#x27;</span> + pickedCard1.<span class="property">card</span> + <span class="string">&#x27; of &#x27;</span> + pickedCard1.<span class="property">suit</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = <span class="title function_">pickCard</span>(<span class="number">15</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;card: &#x27;</span> + pickedCard2.<span class="property">card</span> + <span class="string">&#x27; of &#x27;</span> + pickedCard2.<span class="property">suit</span>)</span><br></pre></td></tr></table></figure><p>这样改变后，重载的 <code>pickCard</code> 函数在调用的时候会进行正确的类型检查。</p><p>为了让编译器能够选择正确的检查类型，它与 JavaScript 里的处理流程相似。它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。因此，在定义重载的时候，一定要把最精确的定义放在最前面。</p><p>注意，<code>function pickCard(x): any</code> 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象数组，另一个接收数字。 以其它参数调用 <code>pickCard</code> 会产生错误。</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>软件工程中，我们不仅要创建定义良好且一致的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p><p>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p><h2 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h2><p>下面来创建第一个使用泛型的例子：<code>identity</code> 函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 <code>echo</code> 命令。</p><p>不用泛型的话，这个函数可能是下面这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">identity</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，我们使用 <code>any</code> 类型来定义函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">identity</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>any</code> 类型会导致这个函数可以接收任何类型的 <code>arg</code> 参数，但是这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。</p><p>因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。这里，我们使用了<em>类型变量</em>，它是一种特殊的变量，只用于表示类型而不是值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们给 <code>identity</code> 添加了类型变量 <code>T</code>。 <code>T</code> 帮助我们捕获用户传入的类型（比如：<code>number</code>），之后我们就可以使用这个类型。 之后我们再次使用了 <code>T</code> 当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。这允许我们跟踪函数里使用的类型的信息。</p><p>我们把这个版本的 <code>identity</code> 函数叫做泛型，因为它可以适用于多个类型。 不同于使用 <code>any</code>，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。</p><p>我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;myString&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里我们明确的指定了 <code>T</code> 是 <code>string</code> 类型，并做为一个参数传给函数，使用了 <code>&lt;&gt;</code> 括起来而不是 <code>()</code>。</p><p>第二种方法更普遍。利用了<em>类型推论</em> – 即编译器会根据传入的参数自动地帮助我们确定 <code>T</code> 的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> output = <span class="title function_">identity</span>(<span class="string">&#x27;myString&#x27;</span>)</span><br></pre></td></tr></table></figure><p>注意我们没必要使用尖括号（<code>&lt;&gt;</code>）来明确地传入类型；编译器可以查看 <code>myString</code> 的值，然后把 <code>T</code> 设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入 <code>T</code> 的类型，在一些复杂的情况下，这是可能出现的。</p><h2 id="使用泛型变量"><a href="#使用泛型变量" class="headerlink" title="使用泛型变量"></a>使用泛型变量</h2><p>使用泛型创建像 <code>identity</code> 这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。</p><p>看下之前 <code>identity</code> 例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想打印出 <code>arg</code> 的长度。 我们很可能会这样做：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> loggingIdentity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>)</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这么做，编译器会报错说我们使用了 <code>arg</code> 的 <code>.length</code> 属性，但是没有地方指明 <code>arg</code> 具有这个属性。记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 <code>.length</code> 属性的。</p><p>现在假设我们想操作 <code>T</code> 类型的数组而不直接是 <code>T</code>。由于我们操作的是数组，所以 <code>.length</code> 属性是应该存在的。我们可以像创建其它数组一样创建这个数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> loggingIdentity&lt;T&gt;(<span class="attr">arg</span>: T[]): T[] &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>)</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以这样理解 <code>loggingIdentity</code> 的类型：泛型函数 <code>loggingIdentity</code>，接收类型参数 <code>T</code> 和参数 <code>arg</code>，它是个元素类型是 <code>T</code> 的数组，并返回元素类型是<code>T</code> 的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 <code>T</code> 的的类型为 <code>number</code>。 这可以让我们把泛型变量 <code>T</code> 当做类型的一部分使用，而不是整个类型，增加了灵活性。</p><h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><p>上一节，我们创建了 <code>identity</code> 通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。</p><p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: &lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T = identity</span><br></pre></td></tr></table></figure><p>我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: &lt;U&gt;<span class="function">(<span class="params">arg: U</span>) =&gt;</span> U = identity</span><br></pre></td></tr></table></figure><p>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: &#123; &lt;T&gt;(<span class="attr">arg</span>: T): T &#125; = identity</span><br></pre></td></tr></table></figure><p>这引导我们去写第一个泛型接口了。我们把上面例子里的对象字面量拿出来做为一个接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericIdentityFn</span> &#123;</span><br><span class="line">  &lt;T&gt;(<span class="attr">arg</span>: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: <span class="title class_">GenericIdentityFn</span> = identity</span><br></pre></td></tr></table></figure><p>我们甚至可以把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： <code>Dictionary&lt;string&gt;</code> 而不只是<code>Dictionary</code>）。这样接口里的其它成员也能知道这个参数的类型了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericIdentityFn</span>&lt;T&gt; &#123;</span><br><span class="line">  (<span class="attr">arg</span>: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: <span class="title class_">GenericIdentityFn</span>&lt;<span class="built_in">number</span>&gt; = identity</span><br></pre></td></tr></table></figure><p>注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 <code>GenericIdentityFn</code> 的时候，还得传入一个类型参数来指定泛型类型（这里是：<code>number</code>），锁定了之后代码里使用的类型。对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。</p><p>除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。</p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类看上去与泛型接口差不多。 泛型类使用（ <code>&lt;&gt;</code>）括起泛型类型，跟在类名后面。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericNumber</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">zeroValue</span>: T</span><br><span class="line">  <span class="attr">add</span>: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">myGenericNumber.<span class="property">zeroValue</span> = <span class="number">0</span></span><br><span class="line">myGenericNumber.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GenericNumber</code> 类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用 <code>number</code> 类型。 也可以使用字符串或其它更复杂的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringNumeric = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">stringNumeric.<span class="property">zeroValue</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">stringNumeric.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringNumeric.<span class="title function_">add</span>(stringNumeric.<span class="property">zeroValue</span>, <span class="string">&#x27;test&#x27;</span>))</span><br></pre></td></tr></table></figure><p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p><p>我们在<a href="/chapter2/class">类</a>那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。在 <code>loggingIdentity</code> 例子中，我们想访问 <code>arg</code> 的 <code>length</code> 属性，但是编译器并不能证明每种类型都有 <code>length</code> 属性，所以就报错了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> loggingIdentity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>)</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于操作 <code>any</code> 所有类型，我们想要限制函数去处理任意带有 <code>.length</code> 属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。为此，我们需要列出对于 <code>T</code> 的约束要求。</p><p>我们定义一个接口来描述约束条件，创建一个包含 <code>.length</code> 属性的接口，使用这个接口和 <code>extends</code> 关键字来实现约束：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lengthwise</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> loggingIdentity&lt;T <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>) <span class="comment">// OK</span></span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">loggingIdentity</span>(<span class="number">3</span>) <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>我们需要传入符合约束类型的值，必须包含必须的属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">loggingIdentity</span>(&#123; <span class="attr">length</span>: <span class="number">10</span>, <span class="attr">value</span>: <span class="number">3</span> &#125;) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h3 id="在泛型约束中使用类型参数"><a href="#在泛型约束中使用类型参数" class="headerlink" title="在泛型约束中使用类型参数"></a>在泛型约束中使用类型参数</h3><p>你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 <code>obj</code> 上，因此我们需要在这两个类型之间使用约束。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getProperty&lt;T, K <span class="keyword">extends</span> keyof T&gt;(<span class="attr">obj</span>: T, <span class="attr">key</span>: K) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getProperty</span>(x, <span class="string">&#x27;a&#x27;</span>) <span class="comment">// okay</span></span><br><span class="line"><span class="title function_">getProperty</span>(x, <span class="string">&#x27;m&#x27;</span>) <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h1 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h1><h1 id="类型推断-1"><a href="#类型推断-1" class="headerlink" title="类型推断"></a>类型推断</h1><p>这节介绍 TypeScript 里的类型推断。即，类型是在哪里如何被推断的。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>TypeScript 里，在有些没有明确指出类型的地方，类型推断会帮助提供类型。如下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>变量 <code>x</code> 的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。</p><p>大多数情况下，类型推断是直截了当地。后面的小节，我们会浏览类型推断时的细微差别。</p><h2 id="最佳通用类型"><a href="#最佳通用类型" class="headerlink" title="最佳通用类型"></a>最佳通用类型</h2><p>有些时候我们需要从几个表达式中推断类型，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = [<span class="number">0</span>, <span class="number">1</span>, <span class="literal">null</span>]</span><br></pre></td></tr></table></figure><p>为了推断 <code>x</code> 的类型，我们必须考虑所有元素的类型。 这里有两种选择：<code>number</code> 和 <code>null</code>。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p><p>由于最终的通用类型取自候选类型，有些时候候选类型共享一个公共结构，但是却没有一个类型能做为所有候选类型的超级类型。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">numLegs</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bee</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lion</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> zoo = [<span class="keyword">new</span> <span class="title class_">Bee</span>(), <span class="keyword">new</span> <span class="title class_">Lion</span>()]</span><br></pre></td></tr></table></figure><p>这里，我们想让 <code>zoo</code> 被推断为 <code>Animal[]</code> 类型，但是这个数组里没有对象是 <code>Animal</code> 类型的，因此不能推断出这个结果。 为了更正，我们可以明确的声明我们期望的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">zoo</span>: <span class="title class_">Animal</span>[] = [<span class="keyword">new</span> <span class="title class_">Bee</span>(), <span class="keyword">new</span> <span class="title class_">Lion</span>()]</span><br></pre></td></tr></table></figure><p>如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，<code>(Bee | Lion)[]</code></p><h2 id="上下文类型"><a href="#上下文类型" class="headerlink" title="上下文类型"></a>上下文类型</h2><p>有些时候，TypeScript 类型推断会按另外一种方式，我们称作“上下文类型”；上下文类型的出现和表达式的类型以及所处的位置相关。比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onmousedown</span> = <span class="keyword">function</span> (<span class="params">mouseEvent</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(mouseEvent.<span class="property">clickTime</span>) <span class="comment">// Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子会得到一个类型错误，TypeScript 类型检查器使用 <code>window.onmousedown</code> 函数的类型来推断右边函数表达式的类型。 因此，就能推断出 <code>mouseEvent</code> 参数的类型了，所以 <code>mouseEvent</code> 访问了一个不存在的属性，就报错了。</p><p>如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。重写上面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onmousedown</span> = <span class="keyword">function</span> (<span class="params">mouseEvent: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(mouseEvent.<span class="property">clickTime</span>) <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数表达式有明确的参数类型注解，上下文类型被忽略。这样的话就不报错了，因为这里不会使用到上下文类型。</p><p>上下文类型会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员，数组字面量和返回值语句。上下文类型也会做为最佳通用类型的候选类型。比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createZoo</span>(<span class="params"></span>): <span class="title class_">Animal</span>[] &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">new</span> <span class="title class_">Bee</span>(), <span class="keyword">new</span> <span class="title class_">Lion</span>()]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> zoo = <span class="title function_">createZoo</span>()</span><br></pre></td></tr></table></figure><p>这个例子里，最佳通用类型有 <code>3</code> 个候选者：<code>Animal</code>，<code>Bee</code> 和 <code>Lion</code>。 其中，<code>Animal</code> 会被做为最佳通用类型。</p><h1 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h1><h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，<code>Person &amp; Loggable</code> 同时是 <code>Person</code> 和 <code>Loggable</code>。 就是说这个类型的对象同时拥有了这两种类型的成员。</p><p>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript 里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> extend&lt;T, U&gt;(<span class="attr">first</span>: T, <span class="attr">second</span>: U): T &amp; U &#123;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;&#125; <span class="keyword">as</span> T &amp; U</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> first) &#123;</span><br><span class="line">    result[id] = first[id] <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> second) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!result.<span class="title function_">hasOwnProperty</span>(id)) &#123;</span><br><span class="line">      result[id] = second[id] <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Loggable</span> &#123;</span><br><span class="line">  <span class="title function_">log</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsoleLogger</span> <span class="keyword">implements</span> <span class="title class_">Loggable</span> &#123;</span><br><span class="line">  <span class="title function_">log</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jim = <span class="title function_">extend</span>(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Jim&#x27;</span>), <span class="keyword">new</span> <span class="title class_">ConsoleLogger</span>())</span><br><span class="line"><span class="keyword">var</span> n = jim.<span class="property">name</span></span><br><span class="line">jim.<span class="title function_">log</span>()</span><br></pre></td></tr></table></figure><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 <code>number</code> 或 <code>string</code> 类型的参数。 例如下面的函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>(padding + <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>) + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Expected string or number, got &#x27;<span class="subst">$&#123;padding&#125;</span>&#x27;.`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">padLeft</span>(<span class="string">&#x27;Hello world&#x27;</span>, <span class="number">4</span>) <span class="comment">// returns &quot;    Hello world&quot;</span></span><br></pre></td></tr></table></figure><p><code>padLeft</code> 存在一个问题，<code>padding</code> 参数的类型指定成了 <code>any</code>。 这就是说我们可以传入一个既不是 <code>number</code> 也不是 <code>string</code> 类型的参数，但是 TypeScript 却不报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> indentedString = <span class="title function_">padLeft</span>(<span class="string">&#x27;Hello world&#x27;</span>, <span class="literal">true</span>) <span class="comment">// 编译阶段通过，运行时报错</span></span><br></pre></td></tr></table></figure><p>为了解决这个问题，我们可以使用 联合类型做为 <code>padding</code> 的参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> indentedString = <span class="title function_">padLeft</span>(<span class="string">&#x27;Hello world&#x27;</span>, <span class="literal">true</span>) <span class="comment">// 编译阶段报错</span></span><br></pre></td></tr></table></figure><p>联合类型表示一个值可以是几种类型之一。我们用竖线（<code>|</code>）分隔每个类型，所以 <code>number | string</code> 表示一个值可以是 <code>number</code> 或 <code>string</code>。</p><p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="title function_">fly</span>()</span><br><span class="line">  <span class="title function_">layEggs</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="title function_">swim</span>()</span><br><span class="line">  <span class="title function_">layEggs</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSmallPet</span>(<span class="params"></span>): <span class="title class_">Fish</span> | <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = <span class="title function_">getSmallPet</span>()</span><br><span class="line">pet.<span class="title function_">layEggs</span>() <span class="comment">// okay</span></span><br><span class="line">pet.<span class="title function_">swim</span>() <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>这里的联合类型可能有点复杂：如果一个值的类型是 <code>A | B</code>，我们能够确定的是它包含了 <code>A</code> 和 <code>B</code> 中共有的成员。这个例子里，<code>Fish</code> 具有一个 <code>swim</code> 方法，我们不能确定一个 <code>Bird | Fish</code> 类型的变量是否有 <code>swim</code>方法。 如果变量在运行时是 <code>Bird</code> 类型，那么调用 <code>pet.swim()</code> 就出错了。</p><h2 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h2><p>联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 <code>Fish</code> 或者是 <code>Bird</code> 时怎么办？ JavaScript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = <span class="title function_">getSmallPet</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个成员访问都会报错</span></span><br><span class="line"><span class="keyword">if</span> (pet.<span class="property">swim</span>) &#123;</span><br><span class="line">  pet.<span class="title function_">swim</span>()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pet.<span class="property">fly</span>) &#123;</span><br><span class="line">  pet.<span class="title function_">fly</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让这段代码工作，我们要使用类型断言：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = <span class="title function_">getSmallPet</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pet <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span>) &#123;</span><br><span class="line">  ;(pet <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="title function_">swim</span>()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ;(pet <span class="keyword">as</span> <span class="title class_">Bird</span>).<span class="title function_">fly</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户自定义的类型保护"><a href="#用户自定义的类型保护" class="headerlink" title="用户自定义的类型保护"></a>用户自定义的类型保护</h3><p>这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 <code>pet</code> 的类型的话就好了。</p><p>TypeScript 里的<em>类型保护</em>机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个<em>类型谓词</em>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params">pet: Fish | Bird</span>): pet is <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (pet <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span> !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子里，<code>pet is Fish</code> 就是类型谓词。谓词为 <code>parameterName is Type</code> 这种形式， <code>parameterName</code> 必须是来自于当前函数签名里的一个参数名。</p><p>每当使用一些变量调用 <code>isFish</code> 时，<code>TypeScript</code> 会将变量缩减为那个具体的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isFish</span>(pet)) &#123;</span><br><span class="line">  pet.<span class="title function_">swim</span>()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  pet.<span class="title function_">fly</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>TypeScript</code> 不仅知道在 <code>if</code> 分支里 <code>pet</code> 是 <code>Fish</code> 类型；它还清楚在 <code>else</code> 分支里，一定不是 Fish 类型而是 <code>Bird</code> 类型。</p><h3 id="typeof-类型保护"><a href="#typeof-类型保护" class="headerlink" title="typeof 类型保护"></a>typeof 类型保护</h3><p>现在我们回过头来看看怎么使用联合类型书写 <code>padLeft</code> 代码。我们可以像下面这样利用类型断言来写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isNumber</span>(<span class="params">x: <span class="built_in">any</span></span>): x is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">x: <span class="built_in">any</span></span>): x is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isNumber</span>(padding)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>(padding + <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>) + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isString</span>(padding)) &#123;</span><br><span class="line">    <span class="keyword">return</span> padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Expected string or number, got &#x27;<span class="subst">$&#123;padding&#125;</span>&#x27;.`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 <code>typeof x === &#39;number&#39;</code>抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>(padding + <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>) + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Expected string or number, got &#x27;<span class="subst">$&#123;padding&#125;</span>&#x27;.`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些 <code>typeof</code> 类型保护只有两种形式能被识别：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>， <code>&quot;typename&quot;</code>必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>，<code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。 但是 TypeScript 并不会阻止你与其它字符串比较，只是 TypeScript 不会把那些表达式识别为类型保护。</p><h3 id="instanceof-类型保护"><a href="#instanceof-类型保护" class="headerlink" title="instanceof 类型保护"></a>instanceof 类型保护</h3><p>如果你已经阅读了 <code>typeof</code> 类型保护并且对 JavaScript 里的 <code>instanceof</code> 操作符熟悉的话，你可能已经猜到了这节要讲的内容。</p><p><code>instanceof</code> 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="title function_">fly</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bird fly&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">layEggs</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bird lay eggs&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="title function_">swim</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fish swim&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">layEggs</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fish lay eggs&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRandomPet</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span> ? <span class="keyword">new</span> <span class="title class_">Bird</span>() : <span class="keyword">new</span> <span class="title class_">Fish</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = <span class="title function_">getRandomPet</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pet <span class="keyword">instanceof</span> <span class="title class_">Bird</span>) &#123;</span><br><span class="line">  pet.<span class="title function_">fly</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pet <span class="keyword">instanceof</span> <span class="title class_">Fish</span>) &#123;</span><br><span class="line">  pet.<span class="title function_">swim</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可以为-null-的类型"><a href="#可以为-null-的类型" class="headerlink" title="可以为 null 的类型"></a>可以为 null 的类型</h2><p>TypeScript 具有两种特殊的类型，<code>null</code> 和 <code>undefined</code>，它们分别具有值 <code>null</code> 和 <code>undefined</code>。我们在<a href="/chapter2/type">基础类型</a>一节里已经做过简要说明。 默认情况下，类型检查器认为 <code>null</code> 与 <code>undefined</code> 可以赋值给任何类型。 <code>null</code> 与 <code>undefined</code> 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。<code>null</code>的发明者，Tony Hoare，称它为<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Null_pointer#History">价值亿万美金的错误</a>。</p><p><code>--strictNullChecks</code> 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 <code>null</code> 或 <code>undefined</code>。 你可以使用联合类型明确的包含它们：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">s = <span class="literal">null</span> <span class="comment">// 错误, &#x27;null&#x27;不能赋值给&#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">sn</span>: <span class="built_in">string</span> | <span class="literal">null</span> = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">sn = <span class="literal">null</span> <span class="comment">// 可以</span></span><br><span class="line"></span><br><span class="line">sn = <span class="literal">undefined</span> <span class="comment">// error, &#x27;undefined&#x27;不能赋值给&#x27;string | null&#x27;</span></span><br></pre></td></tr></table></figure><p>注意，按照 JavaScript 的语义，TypeScript 会把 <code>null</code> 和 <code>undefined</code> 区别对待。<code>string | null</code>，<code>string | undefined</code> 和 <code>string | undefined | null</code> 是不同的类型。</p><h3 id="可选参数和可选属性"><a href="#可选参数和可选属性" class="headerlink" title="可选参数和可选属性"></a>可选参数和可选属性</h3><p>使用了 <code>--strictNullChecks</code>，可选参数会被自动地加上 <code>| undefined</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + (y || <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>)</span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="literal">undefined</span>)</span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="literal">null</span>) <span class="comment">// error, &#x27;null&#x27; 不能赋值给 &#x27;number | undefined&#x27;</span></span><br></pre></td></tr></table></figure><p>可选属性也会有同样的处理：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">number</span></span><br><span class="line">  b?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title function_">C</span>()</span><br><span class="line">c.<span class="property">a</span> = <span class="number">12</span></span><br><span class="line">c.<span class="property">a</span> = <span class="literal">undefined</span> <span class="comment">// error, &#x27;undefined&#x27; 不能赋值给 &#x27;number&#x27;</span></span><br><span class="line">c.<span class="property">b</span> = <span class="number">13</span></span><br><span class="line">c.<span class="property">b</span> = <span class="literal">undefined</span> <span class="comment">// ok</span></span><br><span class="line">c.<span class="property">b</span> = <span class="literal">null</span> <span class="comment">// error, &#x27;null&#x27; 不能赋值给 &#x27;number | undefined&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="类型保护和类型断言"><a href="#类型保护和类型断言" class="headerlink" title="类型保护和类型断言"></a>类型保护和类型断言</h3><p>由于可以为 <code>null</code> 的类型能和其它类型定义为联合类型，那么你需要使用类型保护来去除 <code>null</code>。幸运地是这与在 <code>JavaScript</code> 里写的代码一致：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">sn: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (sn === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;default&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很明显地去除了 <code>null</code>，你也可以使用短路运算符：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">sn: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> sn || <span class="string">&#x27;default&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果编译器不能够去除 <code>null</code> 或 <code>undefined</code>，你可以使用类型断言手动去除。语法是添加 <code>!</code> 后缀： <code>identifier!</code> 从 <code>identifier</code> 的类型里去除了 <code>null</code> 和 <code>undefined</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">broken</span>(<span class="params">name: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">postfix</span>(<span class="params">epithet: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name.<span class="title function_">charAt</span>(<span class="number">0</span>) + <span class="string">&#x27;.  the &#x27;</span> + epithet <span class="comment">// error, &#x27;name&#x27; 可能为 null</span></span><br><span class="line">  &#125;</span><br><span class="line">  name = name || <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">postfix</span>(<span class="string">&#x27;great&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fixed</span>(<span class="params">name: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">postfix</span>(<span class="params">epithet: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name!.<span class="title function_">charAt</span>(<span class="number">0</span>) + <span class="string">&#x27;.  the &#x27;</span> + epithet <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line">  name = name || <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">postfix</span>(<span class="string">&#x27;great&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">broken</span>(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>本例使用了嵌套函数，因为编译器无法去除嵌套函数的 <code>null</code>（除非是立即调用的函数表达式）。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 <code>name</code> 的类型。</p><h2 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h2><p>字符串字面量类型允许你指定字符串必须具有的确切值。在实际应用中，字符串字面量类型可以与联合类型，类型保护很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Easing</span> = <span class="string">&#x27;ease-in&#x27;</span> | <span class="string">&#x27;ease-out&#x27;</span> | <span class="string">&#x27;ease-in-out&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UIElement</span> &#123;</span><br><span class="line">  <span class="title function_">animate</span>(<span class="params">dx: <span class="built_in">number</span>, dy: <span class="built_in">number</span>, easing: Easing</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (easing === <span class="string">&#x27;ease-in&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">&#x27;ease-out&#x27;</span>) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">&#x27;ease-in-out&#x27;</span>) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// error! 不能传入 null 或者 undefined.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> <span class="title class_">UIElement</span>()</span><br><span class="line">button.<span class="title function_">animate</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;ease-in&#x27;</span>)</span><br><span class="line">button.<span class="title function_">animate</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;uneasy&#x27;</span>) <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Argument of type &#x27;&quot;uneasy&quot;&#x27; is not assignable to parameter of type &#x27;&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;&#x27;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/yueyun.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/yueyun.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">月晕</div><div class="post-copyright__author_desc">生命是有光的</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.yueyun.site/posts/d681bdaf.html">原创</a><a class="post-copyright-title"><span onclick='rm.copyPageUrl("https://blog.yueyun.site/posts/d681bdaf.html")'>TypeScript语言学习</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.yueyun.site/posts/d681bdaf.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><script>function copyCurrentPageUrl(){var e=window.location.href,t=document.createElement("input");t.setAttribute("value",e),document.body.appendChild(t),t.select(),t.setSelectionRange(0,99999),document.execCommand("copy"),document.body.removeChild(t)}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.yueyun.site" target="_blank">月晕</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="categoryes-punctuation"><i class="anzhiyufont anzhiyu-icon-inbox"></i></span>前端<span class="categoryesPageCount">6</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/JavaScript/"><span class="tags-punctuation"><i class="anzhiyufont anzhiyu-icon-tag"></i></span>JavaScript<span class="tagsPageCount">9</span></a><a class="post-meta__box__tags" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>前端<span class="tagsPageCount">7</span></a><a class="post-meta__box__tags" href="/tags/TypeScript/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>TypeScript<span class="tagsPageCount">1</span></a></div></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/49ae955a.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/wallpaper/2.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">React 源码分析</div></div></a></div><div class="next-post pull-right"><a href="/posts/9c0aba3e.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/wallpaper/1703262863447.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">leetcode 刷题(每日一题) 记录</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size:1.5rem;margin-right:4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/938f2f9c.html" title="React Native开坑"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1702557508740.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-15</div><div class="title">React Native开坑</div></div></a></div><div><a href="/posts/9ac48510.html" title="React学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1701613946910.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-12</div><div class="title">React学习</div></div></a></div><div><a href="/posts/49ae955a.html" title="React 源码分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/wallpaper/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-15</div><div class="title">React 源码分析</div></div></a></div><div><a href="/posts/317b894e.html" title="Vue学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1702396713207.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-12</div><div class="title">Vue学习</div></div></a></div><div><a href="/posts/ea5e4ee3.html" title="Vue部分源码分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1700908595951.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-25</div><div class="title">Vue部分源码分析</div></div></a></div><div><a href="/posts/8b326882.html" title="常见前端面试题详解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1702557879900.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-14</div><div class="title">常见前端面试题详解</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)" style="display:none">匿名评论</a><a href="/privacy" style="margin-left:4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/yueyun.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"><div class="author-info__decoration"><img class="avatar-decoration-1" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/avatar_desc/avatar_d1.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="decoration"><img class="avatar-decoration-2" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/avatar_desc/avatar_d2.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="decoration"><img class="avatar-decoration-3" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/avatar_desc/avatar_d3.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="decoration"><img class="avatar-decoration-4" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/avatar_desc/avatar_d4.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="decoration"></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><h1 class="author-info__name">月晕</h1><div class="author-info__desc">生命是有光的</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=3514392356&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="anzhiyufont anzhiyu-icon-qq"></i></a><a class="social-icon faa-parent animated-hover" href="https://github.com/apprehen" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/554370301" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">TypeScript 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">TypeScript 的特点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">基础类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%80%BC"><span class="toc-number">3.1.</span> <span class="toc-text">布尔值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97"><span class="toc-number">3.2.</span> <span class="toc-text">数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.3.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">3.4.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%A5%96-Tuple"><span class="toc-number">3.5.</span> <span class="toc-text">元祖 Tuple</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.6.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#any"><span class="toc-number">3.7.</span> <span class="toc-text">any</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#void"><span class="toc-number">3.8.</span> <span class="toc-text">void</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null-%E5%92%8C-undefined"><span class="toc-number">3.9.</span> <span class="toc-text">null 和 undefined</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#never"><span class="toc-number">3.10.</span> <span class="toc-text">never</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object"><span class="toc-number">3.11.</span> <span class="toc-text">object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">3.12.</span> <span class="toc-text">类型断言</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">4.</span> <span class="toc-text">变量声明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#var-%E5%A3%B0%E6%98%8E"><span class="toc-number">4.1.</span> <span class="toc-text">var 声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99"><span class="toc-number">4.1.1.</span> <span class="toc-text">作用域规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F%E6%80%AA%E5%BC%82%E4%B9%8B%E5%A4%84"><span class="toc-number">4.1.2.</span> <span class="toc-text">捕获变量怪异之处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let-%E5%A3%B0%E6%98%8E"><span class="toc-number">4.2.</span> <span class="toc-text">let 声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.2.1.</span> <span class="toc-text">块作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%B1%8F%E8%94%BD"><span class="toc-number">4.2.2.</span> <span class="toc-text">重定义及屏蔽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%98%E9%87%8F%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">4.2.3.</span> <span class="toc-text">块级作用域变量的获取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-%E5%A3%B0%E6%98%8E"><span class="toc-number">4.3.</span> <span class="toc-text">const 声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let-vs-const"><span class="toc-number">4.4.</span> <span class="toc-text">let vs. const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84"><span class="toc-number">4.5.</span> <span class="toc-text">解构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E6%95%B0%E7%BB%84"><span class="toc-number">4.5.1.</span> <span class="toc-text">解构数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-number">4.5.2.</span> <span class="toc-text">对象解构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E9%87%8D%E5%91%BD%E5%90%8D"><span class="toc-number">4.5.3.</span> <span class="toc-text">属性重命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">4.5.4.</span> <span class="toc-text">默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">4.5.5.</span> <span class="toc-text">函数声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%95%E5%BC%80"><span class="toc-number">4.6.</span> <span class="toc-text">展开</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%88%9D%E6%8E%A2"><span class="toc-number">5.1.</span> <span class="toc-text">接口初探</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-number">5.2.</span> <span class="toc-text">可选属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">5.3.</span> <span class="toc-text">只读属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#readonly-vs-const"><span class="toc-number">5.3.1.</span> <span class="toc-text">readonly vs const</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84%E5%B1%9E%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="toc-number">5.4.</span> <span class="toc-text">额外的属性检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.5.</span> <span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.6.</span> <span class="toc-text">可索引的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.7.</span> <span class="toc-text">类类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.7.1.</span> <span class="toc-text">实现接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E9%9D%99%E6%80%81%E9%83%A8%E5%88%86%E4%B8%8E%E5%AE%9E%E4%BE%8B%E9%83%A8%E5%88%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.7.2.</span> <span class="toc-text">类静态部分与实例部分的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.8.</span> <span class="toc-text">继承接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.9.</span> <span class="toc-text">混合类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E7%B1%BB"><span class="toc-number">5.10.</span> <span class="toc-text">接口继承类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.1.</span> <span class="toc-text">基本示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">6.2.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%EF%BC%8C%E7%A7%81%E6%9C%89%E4%B8%8E%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">6.3.</span> <span class="toc-text">公共，私有与受保护的修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E4%B8%BA-public"><span class="toc-number">6.3.1.</span> <span class="toc-text">默认为 public</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-private"><span class="toc-number">6.3.2.</span> <span class="toc-text">理解 private</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-protected"><span class="toc-number">6.3.3.</span> <span class="toc-text">理解 protected</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#readonly-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">6.4.</span> <span class="toc-text">readonly 修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%B1%9E%E6%80%A7"><span class="toc-number">6.4.1.</span> <span class="toc-text">参数属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%8F%96%E5%99%A8"><span class="toc-number">6.5.</span> <span class="toc-text">存取器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7"><span class="toc-number">6.6.</span> <span class="toc-text">静态属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">6.7.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7"><span class="toc-number">6.8.</span> <span class="toc-text">高级技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">6.8.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E7%B1%BB%E5%BD%93%E5%81%9A%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8"><span class="toc-number">6.8.2.</span> <span class="toc-text">把类当做接口使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">7.1.</span> <span class="toc-text">基本示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">7.2.</span> <span class="toc-text">函数类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.2.1.</span> <span class="toc-text">为函数定义类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A6%E5%86%99%E5%AE%8C%E6%95%B4%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.2.2.</span> <span class="toc-text">书写完整函数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E6%96%AD%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.2.3.</span> <span class="toc-text">推断类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E5%92%8C%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">7.3.</span> <span class="toc-text">可选参数和默认参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="toc-number">7.3.1.</span> <span class="toc-text">剩余参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-number">7.4.</span> <span class="toc-text">this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E5%92%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">7.4.1.</span> <span class="toc-text">this 和箭头函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E5%8F%82%E6%95%B0"><span class="toc-number">7.4.2.</span> <span class="toc-text">this 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E5%8F%82%E6%95%B0%E5%9C%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E9%87%8C"><span class="toc-number">7.4.3.</span> <span class="toc-text">this 参数在回调函数里</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">7.5.</span> <span class="toc-text">重载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.1.</span> <span class="toc-text">基础示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-number">8.2.</span> <span class="toc-text">使用泛型变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.3.</span> <span class="toc-text">泛型类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">8.4.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">8.5.</span> <span class="toc-text">泛型约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">8.5.1.</span> <span class="toc-text">在泛型约束中使用类型参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">9.</span> <span class="toc-text">类型推断</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD-1"><span class="toc-number">10.</span> <span class="toc-text">类型推断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">10.1.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.2.</span> <span class="toc-text">最佳通用类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.3.</span> <span class="toc-text">上下文类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.</span> <span class="toc-text">高级类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.1.</span> <span class="toc-text">交叉类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.2.</span> <span class="toc-text">联合类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4"><span class="toc-number">11.3.</span> <span class="toc-text">类型保护</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4"><span class="toc-number">11.3.1.</span> <span class="toc-text">用户自定义的类型保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof-%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4"><span class="toc-number">11.3.2.</span> <span class="toc-text">typeof 类型保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof-%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4"><span class="toc-number">11.3.3.</span> <span class="toc-text">instanceof 类型保护</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E4%B8%BA-null-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.4.</span> <span class="toc-text">可以为 null 的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-number">11.4.1.</span> <span class="toc-text">可选参数和可选属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">11.4.2.</span> <span class="toc-text">类型保护和类型断言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.5.</span> <span class="toc-text">字符串字面量类型</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/9c0aba3e.html" title="leetcode 刷题(每日一题) 记录"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/wallpaper/1703262863447.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="leetcode 刷题(每日一题) 记录"></a><div class="content"><a class="title" href="/posts/9c0aba3e.html" title="leetcode 刷题(每日一题) 记录">leetcode 刷题(每日一题) 记录</a><time datetime="2023-12-27T10:47:16.000Z" title="发表于 2023-12-27 10:47:16">2023-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d681bdaf.html" title="TypeScript语言学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/liang.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="TypeScript语言学习"></a><div class="content"><a class="title" href="/posts/d681bdaf.html" title="TypeScript语言学习">TypeScript语言学习</a><time datetime="2023-12-22T17:46:54.000Z" title="发表于 2023-12-22 17:46:54">2023-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/49ae955a.html" title="React 源码分析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/wallpaper/2.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="React 源码分析"></a><div class="content"><a class="title" href="/posts/49ae955a.html" title="React 源码分析">React 源码分析</a><time datetime="2023-12-15T02:05:37.000Z" title="发表于 2023-12-15 02:05:37">2023-12-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/938f2f9c.html" title="React Native开坑"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1702557508740.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="React Native开坑"></a><div class="content"><a class="title" href="/posts/938f2f9c.html" title="React Native开坑">React Native开坑</a><time datetime="2023-12-15T01:53:25.000Z" title="发表于 2023-12-15 01:53:25">2023-12-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/34b82b37.html" title="vscode常用插件和配置"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1702557863466.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="vscode常用插件和配置"></a><div class="content"><a class="title" href="/posts/34b82b37.html" title="vscode常用插件和配置">vscode常用插件和配置</a><time datetime="2023-12-14T20:55:27.000Z" title="发表于 2023-12-14 20:55:27">2023-12-14</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/apprehen" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/apprehen" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/apprehen" title="facebook"><i class="anzhiyufont anzhiyu-icon-facebook1"></i></a><a class="deal_link" href="/atom.xml" title="RSS"><i class="anzhiyufont anzhiyu-icon-rss"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0,500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/yueyun.jpg" size="50px"><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/apprehen" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/apprehen" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/apprehen" title="抖音"><i class="anzhiyufont anzhiyu-icon-tiktok"></i></a><a class="deal_link" href="/copyright" title="CC"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i></a></div><div class="copyright">&copy;2023 - 2024 By 月晕</div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">13</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>留言</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size:.9em"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size:.9em"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size:.9em"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size:.9em"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Clash/" style="font-size:.88rem">Clash<sup>1</sup></a><a href="/tags/Git/" style="font-size:.88rem">Git<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size:.88rem">JavaScript<sup>9</sup></a><a href="/tags/Linux/" style="font-size:.88rem">Linux<sup>2</sup></a><a href="/tags/NestJS/" style="font-size:.88rem">NestJS<sup>1</sup></a><a href="/tags/Nginx/" style="font-size:.88rem">Nginx<sup>1</sup></a><a href="/tags/PM2/" style="font-size:.88rem">PM2<sup>1</sup></a><a href="/tags/Python/" style="font-size:.88rem">Python<sup>1</sup></a><a href="/tags/React/" style="font-size:.88rem">React<sup>3</sup></a><a href="/tags/React-Native/" style="font-size:.88rem">React Native<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size:.88rem">TypeScript<sup>1</sup></a><a href="/tags/Vite/" style="font-size:.88rem">Vite<sup>1</sup></a><a href="/tags/Vue/" style="font-size:.88rem">Vue<sup>2</sup></a><a href="/tags/leetcode/" style="font-size:.88rem">leetcode<sup>1</sup></a><a href="/tags/vscode/" style="font-size:.88rem">vscode<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size:.88rem">代理<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size:.88rem;font-weight:500;color:var(--anzhiyu-lighttext)">前端<sup>7</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" style="font-size:.88rem">前端框架<sup>2</sup></a><a href="/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/" style="font-size:.88rem">反向代理<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size:.88rem">后端<sup>1</sup></a><a href="/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/" style="font-size:.88rem">打包工具<sup>1</sup></a><a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size:.88rem">插件<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size:.88rem">数据结构<sup>2</sup></a><a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" style="font-size:.88rem">浏览器工作原理<sup>1</sup></a><a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size:.88rem">源码分析<sup>2</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size:.88rem">爬虫<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size:.88rem">算法<sup>1</sup></a><a href="/tags/%E7%BC%96%E8%BE%91%E5%99%A8/" style="font-size:.88rem">编辑器<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size:.88rem;font-weight:500;color:var(--anzhiyu-lighttext)">计算机基础<sup>3</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size:.88rem">计算机操作系统<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size:.88rem">计算机网络<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size:.88rem">面试题<sup>1</sup></a></div></div><hr></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size:1rem"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display:none"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://chat.yueyun.site',
      region: 'ap-hangzhou',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.21/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://chat.yueyun.site',
      region: 'ap-hangzhou',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: true,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', 'G-W3DLGJMJDY', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginModelPath:"assets/",model:{jsonPath:"/live2dw/assets/unitychan.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html>