<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>浏览器原理 | 月晕</title><meta name="keywords" content="浏览器工作原理,浏览器"><meta name="author" content="月晕"><meta name="copyright" content="月晕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="浏览器原理"><meta name="application-name" content="浏览器原理"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="浏览器原理"><meta property="og:url" content="https://blog.yueyun.site/posts/e28d3347.html"><meta property="og:site_name" content="月晕"><meta property="og:description" content="浏览器原理的初步了解"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/boqixiduo.jpg"><meta property="article:author" content="月晕"><meta property="article:tag" content="JS,前端,前端开发,TS,TypeScript,Node,Node.js,Nodejs,Node,后端"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/boqixiduo.jpg"><meta name="description" content="浏览器原理的初步了解"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.yueyun.site/posts/e28d3347"><link rel="preconnect" href="//cdn.cbd.int"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><meta name="google-site-verification" content="QmqYgcPLCjEZmEbdJVKduTaxnvd3OFJRyp3BLB2f0VQ"><meta name="baidu-site-verification" content="codeva-XPqAkKFOID"><meta name="msvalidate.01" content="xxx"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload='this.media="all"'><script async src="https://www.googletagmanager.com/gtag/js?id=G-W3DLGJMJDY"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-W3DLGJMJDY")</script><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"T^T","backTitle":"Ciallo~"},
  LA51: {"enable":true,"ck":"3GbfdCFGvNdWoQg1","LingQueMonitorID":"3GbfdCFGvNdWoQg1"},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://chat.yueyun.site',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🖥️ JavaScript爱好者","🔍 前沿技术追随者","🩵 吃饭睡觉看动漫","🔨 前端后端一把梭","🤓 玉玉郁郁第一名","🧟 间歇性发奋图强","😵 持续性混吃等死","🥰 欢迎找我来聊天"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 月晕","link":"链接: ","source":"来源: 月晕","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={configTitle:"月晕",title:"浏览器原理",postAI:"",pageFillDescription:"浏览器事件循环, 浏览器的进程模型, 何为进程, 何为线程, 浏览器有哪些进程和线程, 渲染主线程是如何工作的, 一些解释, 异步, JS为何会阻碍渲染, 任务优先级, 浏览器渲染原理, 1. 解析 HTML - Parse HTML, 2. 计算, 3. 布局, 4.分层, 5.绘制, 6.分块, 7.光栅化, 8.画, 什么是 reflow, 什么是 repaint, 浏览器存储, 概念, Web Storage, Cookie, Cookie 特点, Cookie 属性, Domain, Path, Expiresx2FMax-size, Secure, HTTPOnly, IndexedDB, 相关术语, 特点, 浏览器中的网络传输, 网络, 常见状态码, HTTP 中常见字段, GET 和 POST, HTTP 缓存技术, 强制缓存(权重高), 协商缓存, HTTP 特性, HTTP, HTTPx2F1.1 性能, HTTPS, HTTPx2F2, HTTPx2F3, HTTP 优化, RPC, WebSocket, 浏览器中怎么建立的 x 连接, WebSocket 使用场景, TCP, TCP 的基本格式, TCP 特点, TCP 连接, TCP 建立连接过程, 为什么需要三次握手, TCP 断开连接的过程, 为什么需要四次挥手, TCP 功能, IP 层, IP 地址分类, 无分类地址 CIDR, IP 地址和路由控制, 同源策略和跨域, 同源策略, 如何解决跨域问题, CORS, JSONP, nginx 代理跨域, nodejs 中间件代理跨域浏览器事件循环浏览器的进程模型何为进程程序运行需要它自己的专属的内存空间可以简单的把这块内存空间理解为进程每个应用至少有一个进程进程之间相互独立即使通信需要同意何为线程有了进程之后就可以运行程序代码了运行代码的容器称之为线程一个进程至少有一个线程所以在进程开启后会自动创建一个线程来运行代码该线程称之为主线程如果程序需要同时执行多块代码主线程就会开启更多的线程来执行代码所以一个进程总可以包含多个线程浏览器有哪些进程和线程浏览器内部工作复杂为了避免相互影响当启动浏览器后会自动开启多个进程如浏览器进程网络进程渲染进程其中主要的线程有浏览器进程主要负责界面显示用户交互子进程管理浏览器进程内部会启动多个线程处理不同的任务网络进程负责加载网络资源网络进程内部会启动多个线程来处理不同的网络任务渲染进程渲染进程启动后会开启一个渲染主线程主线程负责执行代码默认情况下浏览器会为每个标签页开启一个新的渲染进程以保证不同标签页之间的不相互影响渲染主线程是如何工作的渲染主线程是浏览器中最繁忙的线程需要处理的任务包括但不限于解析计算样式布局处理图层执行全局代码执行事件处理函数和一些回调函数为什么渲染进程不使用多个线程来处理这些事情主线程执行的时候该如何调度任务排队即事件循环使用消息队列来处理在最开始的时候渲染主线程会进入一个无限循环每一次循环会检查消息队列中是否有任务存在如果有就取出第一个任务执行执行完一个后进入下一次循环如果没有则进入休眠状态其他所有线程包括其他进程的线程可以随时向消息队列添加任务新任务会加消息队列的末尾在添加新任务的时如果主状态是休眠状态则会将其唤醒以继续循环拿任务整个过程被称之为事件循环消息循环一些解释异步代码执行的过程中会遇到一些无法立即执行的任务比如计时完成后需要执行的任务网络通信完成后需要执行的任务用户操作后执行的任务如果让渲染主进程等待这些任务的时机到达就会导致主线程长期处于阻塞状态从而导致浏览器卡死渲染主线程承担着极其重要的工作无论如何都不能阻塞因此浏览器选择异步来解决这个问题使用异步的方式渲染主线程永不会阻塞如何理解的异步是一门单线程的语言这是因为它运行在浏览器的渲染主线程中而渲染主线程只有一个而渲染主线程承担着很多的工作比如渲染执行等如果采用同步的方式就极有可能导致主线程产生阻塞从而导致消息队列中的很多其他任务无法得到执行这样一来一方面会导致繁忙的主线程效率低另一方面导致页面无法更新用户体验不好所以浏览器采用异步的方式来避免具体做法是当某些任务发送时比如计算器网络请求事件监听主线程将任务交给其他线程去处理自身立即结束任务的执行转而执行后面的代码当其他线程完成时将事先传递的回调函数包装成任务加入消息队列的末尾排队等待主线程调度执行在这种异步模式下浏览器永不阻塞从而最大限度的保证了单线程的流畅运行为何会阻碍渲染点击按钮会卡后才会重新绘制任务优先级任务没有优先级在消息队列中先进先出但是消息队列是有优先级的的最新解释每一个任务都有任务类型同一个类型的任务必须在一个队列不同类型的任务可以分属于不同的队列在一次事件循环中浏览器可以根据实际情况从不同的队列中取出任务执行浏览器必须准备好一个微队列微队列中的任务优先所有其他任务执行随着浏览器的复杂度提升不在使用宏队列的说法在目前的实现中至少包含下面的队列延时队列用于存放计时器到达过的回调任务优先级中交互队列用于存放用户操作后产生的事件处理任务优先级高微队列用户存放需要最快执行的任务优先级最高添加任务到微队列的主要方式是使用例如立即把一个函数添加到微队列函数的事件循环事件循环又叫消息循环是浏览器渲染主线程的工作方式在的源码中会开启一个不会结束的循环每次循环从消息队列中取出第一个任务执行而其他线程只需要在合适的时候将任务加入到队列末尾即可过去简单的把消息队列分为宏任务和微任务这种说法已经不能满足浏览器的复杂性取而代之的是一种更加灵活多变的处理方式根据官方的解释每个任务有不同的类型同类型的任务必须在同一个队列不同的任务可以属于不同的队列不同任务队列有不同的优先级再一次事件循环中由浏览器自行决定那一个队列的任务但浏览器必须有一个微队列微队列的任务一定具有最高的优先级必须优先调度执行中的计时器能做到精确计时吗为什么不能因为计算机硬件没有原子钟无法做到精确计时操作系统的计时函数本身就会有偏差是调用的操作系统的函数按照的标准如果嵌套层级超过层则会有毫秒的最少事件受事件循环的影响计时器的回调函数只能在主线程空闲的时去运行浏览器渲染原理渲染时间点当浏览器的网络线程收到文档后会产生一个渲染任务并将其传递给渲染主线程的消息队列在事件循环机制的作用下渲染主线程取出消息队列中的渲染任务开启渲染流程整个渲染的流程分为多个阶段分别是解析样式计算布局分层绘制分块光栅化画每个阶段都有明确的输入和输出上一个阶段的输出会成为下一个阶段的输入这样整个渲染流程就形成了一套组织严密的生产流水线解析渲染的第一步是解析解析过程中遇到解析遇到执行为了提高解析效率浏览器在开始解析前会启动一个预解析的线程率先下载中的外部文件和外部的文件如果主线程解析到位置此时外部的文件还没有下载解析好主线程不会等待继续解析后续的这是因为下载和解析的工作是在预解析线程中进行的这就是不会阻塞解析的根本原因如果主线程遇到时必须暂停一切的任务等待下载执行完后才能继续解析线程可以分担一点下载的任务主线程遇到位置会停止解析转而等待文件下载好并将全局代码解析执行完成后才继续解析这是因为代码的执行过程可能会修改当前的树所以树的生成必须暂停这就是会阻塞解析的根本原因在第一步完成后会得到树和树浏览器的默认样式内部样式外部样式行内样式会包含在树中计算主线程会遍历得到的树依次为树中的每个节点计算出它的最终样式称之为在这一过程中很多预设值会变成绝对值比如会变成相对单位会变成绝对单位比如会变成这一步完成后会得到一棵带样式的树布局布局阶段会依次遍历树的每一个节点计算每一个节点的几何信息例如节点的高度相对包含块的位置大部分的时候树和布局树并非一一对应比如的节点没有几何信息因此不会生成到布局树又比如使用了伪元素选择器虽然树中不存在这些伪元素节点但它们拥有几何信息所以会生成到布局树中还有匿名行盒匿名快盒等会导致无法一一对应分层主线程会使用一套复杂的策略对整个布局树进行分层分层的好处在于将来某一个层改变后仅会对该层进行后续处理从而提高效率滚动条推叠上下文等样式都会影响分层的结果可以通过属性更大程序的影响分层结果绘制主线程会为每个层单独产生绘制指令集用于描述这一层的内容该如何画出来完成绘制之后主线程将每个图层的绘制信息提交给合成线程剩余的工作将由合成线程完成分块将每层分为多个小区域分块的工作是交给多个线程同时进行的合成线程首先对每个图层进行分块将其划分为更多的小区域会从线程池中拿取多个线程来完成分块工作光栅化合成线程会将信息交给进程以极高的速度完成光栅化进程会开启多个线程来完成光栅化并且优先处理靠近视口区域的块光栅化的结果就是一块一块的位图画合成线程拿到每个层每个块的位图后生成一个个指引信息指引会标识出每个位图应该画到屏幕的那个位置以及会考虑到旋转缩放等变形变形发生在合成线程与渲染主线程无关这就是高效率的本质原因合成线程会把提交给进程有进程产生系统调用提交给硬件最终完成屏幕的成像什么是的本质就是重新计算树当进行了会影响布局树的操作后需要重新计算布局树会引发为了避免连续的多次操作导致布局树反复计算浏览器会合并这些操作当代码全部完成后在进行统一计算所以改动属性造成的是异步的也同样因为如此当获取布局属性时就可能造成无法获取到最新的布局信息决定立即获取属性立即什么是的本质就是重新根据分层信息计算了绘制指令当改动了可见样式后就需要重新计算会引发由于元素的布局信息也属于可见样式所以一定会引发浏览器存储概念现代浏览器中提供了多种的存储机制比如常见的等等数据存储在浏览器中的使用场景有那些呢比如浏览器存储中保持应用状态如用户偏好设置等的创建离线工作的任务缓存静态应用资源比如等的保存上次的会话比如记录登录状态购物车内容等的引入了这让浏览器存储和检索数据变得很容易提供了两个来获取纯字符串的键值对用于存储持久数据除非是手动删除或者无痕模式否则数据会一直保持存在用于存储临时会话数据页面重写加载后仍然存在选项卡关闭时数据丢失存储特点浏览器中有相关的存储同时可以去去监听事件存储限制为同时只能存字符串可以降对象等特殊数据采用转换去保持和无法访问容易被攻击不能存敏感信息同步操作会存在阻塞主要用于身份验证和用户数据持久性与请求一起发送到服务器并在响应时发送给客户端每次请求都会与服务器交换服务器可以使用向客户端发送个性化的内容可以在一段时间后自动使数据过期的方式每个请求和响应都会发送数据存储过多的数据会使请求变得更加冗长特点浏览器限制的大小是特定域允许的的数量是个并且只能是字符串操作同步不能使用来访问通过全局的对象访问常用于会话管理个性化以及跨网站限制用户行为会话没有指定或等属性关闭浏览器会被删除持久指定了或属性在浏览器关闭的时候不会过期属性属性告诉浏览器允许那些主机访问如果未指定则默认为设置的同一主机因此当使用客户端的去访问的时只能访问与域相同的同样与请求的域共享相同域的可以与请求头一起发送到服务器可以设计顶域方便获取属性指定访问必须存在的请求中的路径除了将限制到域之外还可以通过路径来限制它路径属性为的只能在路径及其子路径等上访问属性用来设置的过期时间若设置其值为一个时间那么当到达此时间后就会失效不设置的话默认值是意思是会和一起失效当浏览器关闭不是浏览器标签页后就会失效具有属性的仅可以通过安全的协议发送到服务器而不会通过协议这有助于通过使无法通过不安全的连接访问来防止中间人攻击属性使只能通过服务端访问因此只有服务断可以通过响应头设置它们然后浏览器会将它们与每个后续请求的头一起发送到服务器并且它们将无法通过客户端访问提供了一个类似的数据库可以存储大量结构化数据甚至是文件和每个域至少有的可用空间数据库意味着存储的所有数据都必须分配给一个它将与相关联用作该值的唯一标识符这意味着可以使用该跟踪该值如果应用需要不断获取数据数据库使用非常高效且紧凑的索引结构来快速可靠地通过定位值使用该不仅可以检索存储的值还可以删除更新和替换该值相关术语数据库一个域可以创建任意数量的数据库只有同一域内的页面才能访问数据库相关数据项的存储类似于数据库中的表用于引用中每条记录值的唯一名称它可以使用自动增量数字生成也可以设置为记录中的任何唯一值在中组织数据的另一种方式搜索查询只能检查或和的定义分配给的版本号整数提供自动版本控制因此可以将数据库更新到最新特点特点如下可以将任何类型的数据存储为键值对例如对象文件或数组等是异步的不会在数据加载时停止页面的渲染可以存储结构化数据例如视频图像对象等支持数据库事务和版本控制可以存储大量数据可以在大量数据中快速定位搜索数据数据库是域专用的因此任何其他站点都无法访问其他网站的存储这也称为同源策略使用场景存储用户生成的内容例如表单在填写表单的过程中用户可以离开并稍后再回来完成表单存储之后就不会丢失初始输入的数据存储应用状态当用户首次加载网站或应用时可以使用存储这些初始状态可以是登录身份验证请求或呈现之前所需的任何其他状态因此当用户下次访问该站点时加载速度会增加因为应用已经存储了状态这意味着它可以更快地呈现对于离线工作的应用用户可以在应用离线时编辑和添加数据当应用程序来连接时将处理并清空同步队列中的这些操作浏览器中的网络传输网络网络模型一种通用的网络协议应用层传输层网络层网络应用层物理链路层常见状态码属于提示信息是协议处理中的中间状态用到的少表示服务器成功的处理了客户端的请求预期情况最常见的成功状态码表示一切正常如果是非请求服务器返回的响应头都会有数据表示成功状态码与相同但是没有数据应用于分块下载或者是断点续传表示响应返回的数据并不是资源的全部而是其中的一部分表示客户端的请求资源发生了变动需要客户端用新的去重新发生请求获取资源即是重定向永久重定向说明请求的资源已经不存在了需要用新的去再次访问表示临时重定向说明请求的资源还在但暂时需要改用新的去访问不具有跳转的含义表示资源未修改去重定向已经缓存的文件也称缓存重定向用于缓存控制表示客户端发送的报文有误服务器无法处理表示客户端的请求报文有错误是一个笼统的错误处理表示服务器禁止访问资源而不是客户端错误表示请求的资源在服务器上不存在或未找到所以无法提供给客户端表示客户端请求报文正确但是服务器处理的时候内部发生了错误属于服务端的错误码与一样是一个笼统的错误码表示服务器发生了错误表示客户端的请求还不支付类似于即将开业的情况通常是服务器作为网关或者代理时返回的错误码服务器很忙暂时无法响应中常见字段字段客户端请求用来指定服务器的域名字段表面本次回应的数据长度可以解决中的粘包问题中的粘包问题产生我们不能认为一个用户消息对应一个报文因为在发送报文的过程的时候会经过自己内部的发送窗口拥塞控制和缓冲区大小等等共同解决的所以是面向字节流的协议解决粘包问题在中是有特殊字符作为边界空格换行回车和作为数据长度换行符做的边界作为的边界从而去解决这个问题字段常用于客户端要求服务器使用长连接机制以便其他请求去复用通道长连接的特点是只要任意一端没有明确的提出断开连接特会一直保持连接状态中的和中的中的用户态中的长链接避免建立连接和释放的开销也为流水线技术提供了可实现的基础客户端可以先一次性发送多个请求而在发送的过程中不需等待服务器的回应可以减少整体的响应时间但是此时服务器的响应还是要按照顺序这样就可能前一个请求太慢形成了阻塞也就是常说的队头阻塞问题为了资源浪费也会设置一个的字段去定时断开连接中的的保活机制如果两端一直没有数据交互则达到触发保活机制的条件在内核中的协议栈会发送探测报文去判断报告情况字段用于服务器返回的时候告诉客户端本次的数据格式客户端请求的时候可以加上表示自己应该接受什么类型响应体中可以规定浏览器的默认行为指向这次的媒体类型字段字段说明数据压缩的方式和请求中的可以接受对应和根据规范来说是指从服务器获取指定资源的请求参数是写在上的必须是浏览器会对的长度有限制是指根据请求的负荷对指定的资源做出处理可以是任意格式的幂等意思是执行多次结果是一样的安全请求方法不会破坏服务器上面的资源根据规范来看方法就是安全且幂等的是不安全且不幂等的但是实际开发的过程中和可以实现增删改服务器上面的资源也可以用来查询数据甚至可以带上也可以加上参数缓存技术对于一些重复性的请求比如每次请求到的数据是一样的可以把这样的请求响应的数据缓存在本地避免请求的方法就是使用缓存中的缓存分成强制缓存和协商缓存强制缓存权重高只要浏览器的缓存没过期则直接使用浏览器的本地缓存决定是否使用缓存的主动性在于浏览器强制缓存是利用到下面两个响应头部的字段信息去完成的都用来表示资源在客户端的缓存有效期相对时间也可以设置别的参数如权重高是一个相对时间流程浏览器第一次访问服务器资源的时候服务器会返回某个资源并且在上面设置对应的响应字段浏览器保存后在次请求的时候通过请求资源的时间与中设置的过期时间大小来计算出该资源是否过期如果没有则使用该缓存服务器在次收到请求后会重新更新头部的协商缓存请求响应码是服务端告知客户端是否可以使用缓存的方式叫协商缓存即通过协商缓存结果来判断是否可以使用本地缓存也可以基于两种形式去完成协商缓存的过程资源过期后发现中含有字段则在次发起请求的时候带上发送给服务器服务器去根据这项时间去跟对比返回资源过期后同比较是否相同一般是使用去给内容做一个唯一的值去比较权重高如果不存在则比较时间使用的好处监控的粒度更加深可以精确到毫秒内不会存在手动改写时间的情况协商缓存字段只有在设置了强制缓存字段后未命中强制缓存的时候才能发起带有协商缓存的字段请求特性简单基本报文格式就是头部信息也是简单文本形式易于理解灵活易于扩展中的各种请求方法状态码头字段等都没有被规定死允许开发人员自定义应用广泛和跨平台无状态服务器不会去记忆状态不需要额外的资源去使用减轻服务器的负担但是没有记忆性做到一些关联性操作会非常麻烦于是就引出了关于等技术明文传输不安全通信使用明文不验证通信的双方不能验证报文的完整性性能基于协议请求应答的模式即性能判断就在这两点上面长连接早期的是每发起一个请求都会建立连接断开连接消费资源比较大提出长连接没有一方会一直保持管道网络传输在同一个连接中客户端可以发起多个请求可以减少整体的响应时间但是服务器的响应必须按照请求的顺序这样就造成了队头阻塞的问题队头阻塞是明文传输存在窃听篡改冒充等风险在和之间增加了协议可以很好的解决上面的缺点信息加密混合加密的方式来实现信息的机密性比如算法校验机制摘要算法数字签名来实现完整性为数据生成独一无二的指纹身份证书将服务器公钥放入数字证书中解决冒充的风险协议是基于的相比较有如下的更新头部压缩中会压缩头如果同时发送的请求头是一样的协议栈会消除重复的部分算法去打表二进制格式采用二进制格式去实现头信息和数据体都是二进制统称为帧头信息帧和数据帧并发传输引入概念多个复用一条的连接针对不同的请求使用独一无二的来区分可以交错的发送和请求报文服务器主动推送资源服务端和客户端双方都可以建立使用数字的奇偶来区分缺点是基于协议来传输的数据是基于字节流必须保证接受到的字节流是完整且连续的这样才会从内核缓冲区中取数据去发送给应用当前一个字节没有发送的时候后面的数据只能放在缓冲区中等待第一个字节数据到达才会发送给应用中的管道虽然可以解决请求的问题但是没有解决响应的队头阻塞问题虽然通过多路复用解决了队头阻塞的问题但是一旦发现丢包则会阻塞所有的请求属于层的队头阻塞中的问题是导致的队头阻塞但是的特点就是基于字节流所以就是将传输换成了实现了基于的格式方法机制的协议在上面实现的伪的多路复用协议无队头阻塞协议也有类似的的机制保证传输的可靠性但是多个是没有依赖的相互独立当某个流丢包的时候只会阻塞这个流并不会影响到其他的流更快的建立连接因为内部包含因此仅需个就可以同时完成建立连接与密钥协商甚至在第二次连接的时候应用数据包可以和握手信息连接信息信息一起发送达到的效果连接迁移无感优化尽量避免发送请求通过缓存技术去完成缓存功能包括强制缓存和协商缓存等在需要发送请求的时候考虑如何减少次数减少重定向请求次数通过中间层服务器去完成这个定向请求的功能而不是去跟客户端交互合并请求比如通用的配置生成一个的大请求小的资源图去形成大的精灵图减少次数的请求延迟发送请求懒加载按需请求等减少服务器的响应的数据大小无损压缩和有损压缩本质上就是一种基于传输层的一种通信方式远程过程调用调用方式有很多封装好的协议比如等的是在应用层的一种协议一般是用来在集群内部的通信调用远端的方法可以屏蔽一些网络的细节与的区别服务发现中通过服务去解析背后的和端口一般会有中间服务去保存服务器名和信息等底层连接形式会在底层建立一个连接池在请求量大的时候建立多条连接放在池内传输内容定制程度高不用考虑浏览的行为效率性能高连接的两端是在同一时间双方都可以主动的想对方发送数据即是所谓的全双工然而是基于的同一段时间段内客户端和服务器只能有一方主动的发送消息即是半双工因为最开始的网页设计就是看文本等场景只需要请求应答的模式即可以但是现在场景越多需求越多这样基于的新应用层协议即出来了在早期做到服务器推送消息的时候不断轮询在前端代码中不断地定时发请求到服务器服务器收到请求后给客户端响应信息伪服务器的推送手段只是用户无感而已这种缺点也是非常的明显消耗带宽满屏的请求边缘等长轮询将请求的超时时间设置的很大在这段时间内服务器只要收到了请求的信息就立马返回给客户端如果超时则立马发起下一个请求浏览器中怎么建立的连接为了在浏览器中兼容协议浏览器在进行三次握手后都统一使用协议先进行一次通信如果是普通的请求则继续使用协议进行交互如果是想建立过程则会在中携带一些特殊的头信息如下所示头的意思是浏览器想升级协议并且想升级成同时随机携带一个随机生成的码作为发给服务器如果服务器支持连接协议就会去走的握手流程同时根据客户端生成的码根据公开的算法去生成对应的字符串返回同时变成状态码使用场景完成的实现了的全双工的能力并且也解决了粘包问题适用于服务端和客户端需要大量交互的场景查看默认打开的折叠框协议本身是全双工的但是协议设计的是半双工对大部分服务器要推送的场景使用更合适基于简单的场景的比如登录等场景可以使用长轮询或者定时轮询去实习服务器推送功能正因为各个浏览器都支持协议所以会先利用协议加上一些特殊的头进行握手升级操作升级成功后就跟没有任何关系了的基本格式序列号在建立连接计算机随机生成的随机数去做为初始值通过包发送给接收端的主机每次增加数据字节数去累加判断用来解决网络包乱序的问题确认应答号指下一次期望接受收到的数据序列号用来解决丢包的问题是一个工作在传输层的可靠数据传输的服务能确保接受端接受到的网络包是无损坏无间隔非冗余按序的特点是面向连接可靠的基于字节流的传输层通信协议面向连接一对一才能连接可靠的无论网络链路出现了什么样的变化都可以保证一个报文一定能到达接收端字节流用户消息通过协议传输时消息可能会被操作系统分组成多个报文通过消息边界来确定没接受到的等待重复的丢弃连接用于保证可靠状态和流量传输控制维护的某些状态信息这些信息包括序列号解决乱序问题窗口大小流量控制建立连接过程是面相连接的协议所以必须先建立连接连接是通过三次握手来进行的过程如下刚开始和端都处理状态主动监听端口变成状态客户端会初始化序列号将此序列号置于首部的序列号字段中同时把的字段设置成表示报文之后把这个报文发送给服务端表示发起连接请求该报文并不包含应用层数据发送后的客户端处于状态服务端收到客户端的后首先也直接初始化一个随机数字作为放入序列号字段中同时将确认答应号填成把和的值都变成发送回去同时也不包含任何的应用层数据客户端接受到了服务端数据后还要向服务端去发送一个确认消息确认应答号是将变成之后服务器处于状态这个时候可以携带应用层数据客户端处于状态为什么需要三次握手阻止重复历史连接的初始化在网络拥堵的情况下客户端可以确认自己希望收到的应答号去进行对比确认同步双方的初始序列号去除从重复数据根据数据包的序列号按需接受可以识别发送的数据包是否被接受避免浪费资源断开连接的过程的连接是通过四次挥手来完成客户端打算关闭连接此时会发送一个首部标志位被置位的报文即是报文之后客户端进入的状态服务端接受到报文信息后就向客户端发送应答报文同时自己的状态进入客户端接受到报文后进入的状态等地服务器处理完数据后向客户端发送一个报文之后进入状态客户端接受到报文回答一个报文同时自己的状态进入服务器收到报文后进入状态客户端经过后一段时间后自动进入状态丢包重传的情况为什么需要四次挥手关闭连接时客户端向服务端发送只是代表了客户端不发送数据了但是还是可以去接受数据服务端收到客户端的时回首先回复一个的报文而服务端可能还有数据需要处理和转发等服务器不在发送数据后才会回复一个报文向客户端表示同意关闭连接了故服务端通常是要等待数据发送和处理完所以服务端的和会分开发送即是四次挥手服务器出现大量的状态有那些原因没有使用长连接长连接超时长连接请求达到数量功能重传机制滑动窗口流量控制拥塞控制层层是在网络层主要作用是实现主机与主机之间的通信即是点对点通信网络层和数据链路层的区别和关系的作用是实现直连的两个设备之间的通信而层则负责在没有直连的两个网络之间进行通信传输计算机中是依靠数据链路层和网络层去实现目标的最终通信在网络传输的过程中源和目标地址是不会变化的除了技术只有源和目标的在不断地发生变化不停的在网络中去寻找下一跳要发送的地方在网络通信中为了保证能正常的通信每个设备都要配置正确的地址以便寻址地址分类地址最初被划分成五种类型通过前几位来判断是处于的地方在主机号中有两个是特殊的主机号全为指定某个网络下的所有主机用于广播分本地广播和直接广播主机号为指定某个网络无分类地址由于分类存在一些缺点比如同一个网络下没有地址层次缺少地址的灵活性大类中的数量不能很好的与现实网络匹配等提出了无分类地址的概念位的地址划分成了前面网络号后面是主机号怎么划分网络号和主机号呢变现形式有表示网络号给地址和子网掩码去进行与运算得到网络号为什么存在网络号方便路由寻址工作在路由寻址的时候先进行广播找到网络地址是否相同如果相同则在同一个网段内直接发送数据包到目的主机即可用于路由控制子网掩码的另一个作用可以划分子网将主机地址划分成子网网络地址子网主机地址地址和路由控制地址中的网络地址这一部分是用于进行路由控制路由控制表中记录着网络地址和下一步应该发送至路由器的地址在主机和路由器上都会有各自的路由器控制表在发送包时首先要确定包首部中的目标地址再从路由控制表中找到与该地址具有相同网络地址的记录根据该记录将包转发给相应的下一个路由器如果路由控制表中存在多条相同网络地址的记录就选择相同位数最多的网络地址也就是最长匹配协议相关技术域名解析递归或者循环去取数据去完成查询到最终域名的地址从本地域名开始访问根域不同的向下查询通过协议可以根据地址去查询到对应的地址是借助请求和响应来完成功能的通过广播发送请求设备去查看在形成响应返回得到信息操作系统中存在的反之有协议去获取动态的全程通信使用生成私有用于学校家庭等设备很多的地方可以架设一个池互联网控制报文协议确认包是否成功的送达目标地址报告发送过程中包被废弃的原因和改善网络设施等同源策略和跨域同源策略跨域问题其实就是浏览器的同源策略造成的同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互这是浏览器的一个用于隔离潜在恶意文件的重要安全机制同源策略协议域名端口三者必须一致同源策略主要限制了下面方面当前域下的脚本不能够访问其他域下的当前域下的脚本不能操作其他域下的当前域下无法发送跨域请求同源政策的目的主要是为了保证用户的信息安全它只是对脚本的一种限制并不是对浏览器的限制对于一般的或者脚本请求都不会有跨域的限制这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作如何解决跨域问题跨域资源共享使用额外的头来告诉浏览器让运行在一个上的应用被准许访问来自不同源服务器上的指定的资源当一个资源从与该资源本身所在的服务器不同的域协议或端口请求一个资源时资源会发起一个跨域请求需要浏览器和服务器同时支持整个过程都是浏览器完成的无需用户参与因此实现的关键就是服务器只要服务器实现了请求就可以跨源通信了浏览器将分成简单请求和复杂请求简单请求不会触发预检请求若该请求满足一下两个条件请求方法是中的一种自定义的的头部信息不超过只限于简单请求过程对于简单请求浏览器会直接发出请求会在请求的头信息中增加一个字段字段用来说明是在哪个源服务器会根据这个值来决定是否同意请求在简单请求中在服务器内至少需要设置字段复杂请求复杂请求是对服务器有特殊要求比如请求方法为或等复杂请求会在正式通信之前进行一次查询请求称为预检请求浏览器会询问服务器当前所在的网页是否在服务器允许访问的范围内以及可以使用哪些请求方式和头信息字段只有得到肯定的回复才会进行正式的请求否则就会报错预检请求使用的请求方法是表示这个请求是来询问的他的头信息中的关键字段是表示请求来自哪个源除此之外头信息中还包括两个字段该字段是必须的用来列出浏览器的请求会用到哪些方法该字段是一个逗号分隔的字符串指定浏览器请求会额外发送的头信息字段服务器在收到浏览器的预检请求之后会根据头信息的三个字段来进行判断如果返回的头信息在中有这个字段就是允许跨域请求如果没有就是不同意这个预检请求就会报错允许跨域的源地址服务器支持的所有跨域请求的方法服务器支持的所有头信息字段表示是否允许发送用来指定本次预检请求的有效期单位为秒的原理就是利用标签没有跨域限制通过标签属性发送带有参数的请求服务端将接口返回数据拼凑到函数中返回给浏览器浏览器解析执行从而前端拿到函数返回的数据原生代码传参一个回调函数名给后端方便后端返回时执行这个在前端定义的回调函数回调执行函数后端代码返回设置的缺点具有局限性仅支持方法不安全可能会遭受攻击代理跨域代理静态资源服务端反向代理中间件代理跨域",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-08-29 06:53:36",postMainColor:""}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W3DLGJMJDY"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-W3DLGJMJDY")</script><meta name="generator" content="Hexo 7.0.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/yueyun.jpg"><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"><script async src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">月晕</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>留言</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size:.9em"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size:.9em"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size:.9em"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/resume/"><i class="anzhiyufont anzhiyu-icon-book faa-tada" style="font-size:.9em"></i><span> 简历</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size:.9em"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><div class="nav-change" id="nav-darkmode"><a class="darkmode_switchbutton" title="显示模式切换" onclick="darkmo" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><input id="center-console" type="checkbox"><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/" itemprop="url">浏览器</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/" tabindex="-1" itemprop="url"> <span><i class="anzhiyufont anzhiyu-icon-hashtag"></i>前端</span></a><a class="article-meta__tags" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/" tabindex="-1" itemprop="url"> <span><i class="anzhiyufont anzhiyu-icon-hashtag"></i>浏览器原理</span></a></span></div></div><h1 class="post-title" itemprop="name headline">浏览器原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="post-meta-icon anzhiyufont anzhiyu-icon-calendar-days"></i><span class="post-meta-label">发表于</span><time itemprop="dateCreated datePublished" datetime="2023-11-26T12:15:46.000Z" title="发表于 2023-11-26 12:15:46">2023-11-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">12.8k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator"> </span><span class="post-meta-position" title="作者IP属地为杭州"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>杭州</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/e28d3347.html#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/boqixiduo.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blog.yueyun.site/posts/e28d3347.html"><header><a class="post-meta-categories" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/" itemprop="url">浏览器</a><a href="/tags/%E5%89%8D%E7%AB%AF/" tabindex="-1" itemprop="url">前端</a><a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/" tabindex="-1" itemprop="url">浏览器原理</a><h1 id="CrawlerTitle" itemprop="name headline">浏览器原理</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">月晕</span><time itemprop="dateCreated datePublished" datetime="2023-11-26T12:15:46.000Z" title="undefined 2023-11-26 12:15:46">2023-11-26</time></header><h1 id="浏览器事件循环"><a href="#浏览器事件循环" class="headerlink" title="浏览器事件循环"></a>浏览器事件循环</h1><h2 id="浏览器的进程模型"><a href="#浏览器的进程模型" class="headerlink" title="浏览器的进程模型"></a><strong>浏览器的进程模型</strong></h2><h3 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程"></a>何为进程</h3><p>程序运行需要它自己的专属的内存空间 可以简单的把这块内存空间理解为进程<br>每个应用至少有一个进程，进程之间相互独立，即使通信 需要同意</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/brwose_1.jpg" alt="图片1"></p><h3 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程"></a>何为线程</h3><p>有了进程之后，就可以运行程序代码了<br>运行代码的 <strong>容器</strong> 称之为 <strong>线程</strong><br>一个进程至少有一个线程 所以在进程开启后会自动创建一个线程来运行代码 该线程称之为主线程<br>如果程序需要同时执行多块代码，主线程就会开启更多的线程来执行代码，所以一个进程总可以包含多个线程</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/browse2.jpg"></p><h3 id="浏览器有哪些进程和线程"><a href="#浏览器有哪些进程和线程" class="headerlink" title="浏览器有哪些进程和线程"></a>浏览器有哪些进程和线程</h3><p>浏览器内部工作复杂，为了避免相互影响，当启动浏览器后会自动开启多个进程(如：浏览器进程、网络进程、渲染进程)</p><p>其中主要的线程有：</p><ul><li>浏览器进程<br>主要负责界面显示、用户交互、子进程管理、浏览器进程内部会启动多个线程处理不同的任务</li><li>网络进程<br>负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务</li><li><strong>渲染进程</strong><br>渲染进程启动后，会开启一个渲染主线程，主线程负责执行 <code>HTML、css、JS</code>代码，默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同标签页之间的不相互影响</li></ul><h2 id="渲染主线程是如何工作的"><a href="#渲染主线程是如何工作的" class="headerlink" title="渲染主线程是如何工作的"></a><strong>渲染主线程是如何工作的</strong></h2><p>渲染主线程是浏览器中最繁忙的线程，需要处理的任务包括但不限于</p><ul><li>解析 HTML、CSS</li><li>计算样式，布局</li><li>处理图层</li><li>执行全局 JS 代码</li><li>执行事件处理函数和一些回调函数</li><li>…</li></ul><blockquote><p>为什么渲染进程不使用多个线程来处理这些事情？</p></blockquote><p>主线程执行的时候该 如何调度任务？</p><p><strong>排队：</strong> 即 事件循环(<strong><code>event loop</code></strong>) 使用消息队列来处理(<strong><code>message queue</code></strong>)</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/browse3.jpg"></p><ol><li>在最开始的时候，渲染主线程会进入一个无限循环</li><li>每一次循环会检查消息队列中是否有任务存在，如果有就取出第一个任务执行，执行完一个后进入下一次循环如果没有则进入休眠状态</li><li>其他所有线程(包括其他进程的线程)可以随时向消息队列添加任务，新任务会加消息队列的末尾，在添加新任务的时，如果主状态是休眠状态，则会将其唤醒以继续循环拿任务</li></ol><p>整个过程被称之为 事件循环 (消息循环)</p><h2 id="一些解释"><a href="#一些解释" class="headerlink" title="一些解释"></a>一些解释</h2><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>代码执行的过程中会遇到一些<strong>无法立即执行的任务</strong> 比如:</p><ul><li>计时完成后需要执行的任务 – <code>setTimeout</code>、<code>setInterval</code></li><li>网络通信完成后需要执行的任务 – <code>XHR</code>、<code>FETCH</code></li><li>用户操作后执行的任务 – <code>addEventListener</code></li></ul><p>如果让渲染主进程等待这些任务的时机到达，就会导致主线程长期处于<strong>阻塞</strong>状态从而导致浏览器<strong>卡死</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/browse4.png"></p><p><strong>渲染主线程承担着极其重要的工作,无论如何都不能阻塞</strong></p><p>因此浏览器选择<strong>异步</strong>来解决这个问题<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/browse5.png"></p><p>使用异步的方式，渲染主线程永不会阻塞</p><details class="folding-tag" cyan><summary>如何理解`JS`的异步？</summary><div class="content"><p><code>JS</code>是一门单线程的语言,这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个<br>而渲染主线程承担着很多的工作 比如 渲染<code>html、css</code> 执行<code>js</code>等<br>如果采用同步的方式就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行<br>这样一来 一方面会导致繁忙的主线程效率低，另一方面导致页面无法更新，用户体验不好<br>所以浏览器采用异步的方式来避免，具体做法是当某些任务发送时，比如计算器、网络请求、事件监听、主线程将任务交给其他线程去处理。自身立即结束任务的执行，转而执行后面的代码，当其他线程完成时，将事先传递的回调函数包装成任务，加入消息队列的末尾排队，等待主线程调度执行<br>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行</p></div></details><h3 id="JS为何会阻碍渲染"><a href="#JS为何会阻碍渲染" class="headerlink" title="JS为何会阻碍渲染"></a><code>JS</code>为何会阻碍渲染</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;Megumi&lt;/h1&gt;</span><br><span class="line">  &lt;button&gt; CLICK ME&lt;/button&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const title = document.querySelector(&#x27;h1&#x27;);</span><br><span class="line">    const button = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">    const delay = (duration) =&gt; &#123;</span><br><span class="line">      const start = Date.now();</span><br><span class="line">      while (Date.now() - start &lt; duration) &#123;</span><br><span class="line">        // do nothing</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    button.addEventListener(&#x27;click&#x27;, event =&gt; &#123;</span><br><span class="line">      title.innerHTML = &#x27;EXPLOSION!&#x27;;</span><br><span class="line">      delay(5000)</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>点击按钮会卡 5s 后才会重新绘制</strong></p><h3 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h3><p>任务没有优先级 在消息队列中先进先出</p><p>但是<strong>消息队列</strong>是有优先级的<br>w3c 的最新解释：</p><ul><li>每一个任务都有任务类型，<strong>同一个类型的任务必须在一个队列</strong>，不同类型的任务可以分属于不同的队列，在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行</li><li>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行 (<strong><code>microtask queue</code></strong>)</li></ul><blockquote><p>随着浏览器的复杂度提升，<code>W3C</code>不在使用宏队列的说法</p></blockquote><p>在目前 <strong>chrom</strong>的实现中,至少包含下面的队列:</p><ul><li>延时队列：用于存放计时器到达过的回调任务，优先级 中</li><li>交互队列：用于存放用户操作后产生的事件处理任务 优先级 高</li><li>微队列：用户存放需要最快执行的任务，优先级 最高</li></ul><blockquote><p>添加任务到微队列的主要方式是使用 Promise MutationObserver</p><p>例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 立即把一个函数添加到微队列</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(函数)</span><br></pre></td></tr></table></figure></blockquote><details class="folding-tag" yellow><summary>`JAVASCRIPT`的事件循环</summary><div class="content"><p>事件循环又叫消息循环,是浏览器渲染主线程的工作方式<br>在<code>Chrome</code>的源码中,会开启一个不会结束的<code>for</code>循环,每次循环从消息队列中取出第一个任务执行,而其他线程只需要在合适的时候将任务加入到队列末尾即可<br>过去简单的把消息队列分为宏任务和微任务 这种说法已经不能满足浏览器的复杂性 取而代之的是一种更加灵活多变的处理方式<br>根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列，不同任务队列有不同的优先级 再一次事件循环中，由浏览器自行决定那一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级 必须优先调度执行</p></div></details><details class="folding-tag" red><summary>`JS`中的计时器能做到精确计时吗？为什么？</summary><div class="content"><p>不能，因为</p><ul><li>计算机硬件没有原子钟，无法做到精确计时</li><li>操作系统的计时函数本身就会有偏差，JS 是调用的操作系统的函数</li><li>按照 W3C 的标准，如果嵌套层级超过 5 层，则会有 4 毫秒的最少事件</li><li>受事件循环的影响，计时器的回调函数只能在主线程空闲的时去运行</li></ul></div></details><h1 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h1><p><strong>渲染时间点</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/browse6.png"></p><p>当浏览器的网络线程收到<code>HTML</code>文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列<br>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程</p><p>整个渲染的流程分为多个阶段，分别是：<br><strong>HTML 解析</strong> ——&gt; <strong>样式计算</strong> ——&gt; <strong>布局</strong>——&gt; <strong>分层</strong>——&gt;<strong>绘制</strong>——&gt;<strong>分块</strong>——&gt;<strong>光栅化</strong>——&gt;<strong>画</strong></p><p>每个阶段都有明确的输入和输出，上一个阶段的输出会成为下一个阶段的输入<br>这样，整个渲染流程就形成了一套组织严密的生产流水线</p><h2 id="1-解析-HTML-Parse-HTML"><a href="#1-解析-HTML-Parse-HTML" class="headerlink" title="1. 解析 HTML - Parse HTML"></a>1. 解析 HTML - Parse HTML</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/browse7.png"></p><p><strong>Document Object Modal</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/browse8.png"></p><p><strong>CSS Object Modal</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/browse9.png"></p><p>渲染的第一步是解析<strong>HTML</strong> 解析过程中遇到<strong>CSS</strong>解析遇到<strong>JS</strong>执行<strong>JS</strong> 为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和外部的 JS 文件</p><p>如果主线程解析到 link 位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML，这是因为下载和解析 CSS 的工作是在预解析线程中进行的，这就是 CSS 不会阻塞 HTML 解析的根本原因</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/browse10.png"></p><p>如果主线程遇到 JS 时必须暂停一切的任务，等待下载执行完后才能继续 解析线程可以分担一点下载 JS 的任务 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/browse11.png"></p><p>主线程遇到<code>script</code>位置，会停止解析 HTML,转而等待 JS 文件下载好，并将全局代码解析执行完成后，才继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停，这就是 JS 会阻塞 HTML 解析的根本原因<br>在第一步完成后 会得到 DOM 树和 CSSOM 树 浏览器的默认样式、内部样式、外部样式、行内样式会包含在 CSSOM 树中</p><h2 id="2-计算"><a href="#2-计算" class="headerlink" title="2. 计算"></a><strong>2. 计算</strong></h2><p>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它的最终样式，称之为 <strong>Computed Style</strong></p><p>在这一过程中 很多预设值会变成绝对值 比如 RED 会变成 <code>rgb(255,0,0)</code> 相对单位会变成绝对单位 比如 em 会变成 px</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/browse12.png"></p><p>这一步完成后会得到一棵带样式的 DOM 树</p><h2 id="3-布局"><a href="#3-布局" class="headerlink" title="3. 布局"></a><strong>3. 布局</strong></h2><p>布局阶段会依次遍历 DOM 树的每一个节点,计算每一个节点的几何信息，例如节点的高度，相对包含块的位置</p><p>大部分的时候 DOM 树和布局树并非一一对应</p><p>比如<code>display: none</code>的节点没有几何信息 因此不会生成到布局树 又比如使用了伪元素选择器 虽然<strong>DOM</strong>树中不存在这些伪元素节点 但它们拥有几何信息 所以会生成到布局树中 还有匿名行盒 匿名快盒 等 会导致无法一一对应</p><h2 id="4-分层"><a href="#4-分层" class="headerlink" title="4.分层"></a><strong>4.分层</strong></h2><p>主线程会使用一套复杂的策略对整个布局树进行分层</p><p>分层的好处在于 将来某一个层改变后、仅会对该层进行后续处理 从而提高效率</p><p>滚动条 推叠上下文 <code>transfrom</code> <code>opacity</code>等样式都会影响分层的结果 可以通过<code>will-change</code>属性更大程序的影响分层结果</p><h2 id="5-绘制"><a href="#5-绘制" class="headerlink" title="5.绘制"></a><strong>5.绘制</strong></h2><p>主线程会为每个层单独产生绘制指令集 用于描述这一层的内容该如何画出来<br>完成绘制之后，主线程将每个图层的绘制信息提交给合成线程，剩余的工作将由合成线程完成<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/browse13.png"></p><h2 id="6-分块"><a href="#6-分块" class="headerlink" title="6.分块"></a><strong>6.分块</strong></h2><p>将每层分为多个小区域<br>分块的工作是交给多个线程同时进行的<br>合成线程首先对每个图层进行分块，将其划分为更多的小区域<br>会从线程池中拿取多个线程来完成分块工作</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/browse14.png"></p><h2 id="7-光栅化"><a href="#7-光栅化" class="headerlink" title="7.光栅化"></a><strong>7.光栅化</strong></h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/browse15.png"></p><p>合成线程会将信息交给 GPU 进程 以极高的速度完成光栅化<br>GPU 进程会开启多个线程来完成光栅化 并且优先处理靠近视口区域的块<br>光栅化的结果 就是一块一块的位图</p><h2 id="8-画"><a href="#8-画" class="headerlink" title="8.画"></a><strong>8.画</strong></h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/browse16.png"></p><p>合成线程拿到每个层、每个块的位图后、生成一个个指引(quad)信息<br>指引会标识出每个位图应该画到屏幕的那个位置以及会考虑到旋转 缩放等变形<br>变形发生在合成线程 与渲染主线程无关 这就是<code>transform</code>高效率的本质原因<br>合成线程会把 quad 提交给 GPU 进程 有 GPU 进程产生系统调用 提交给 GPU 硬件 最终完成屏幕的成像</p><h2 id="什么是-reflow"><a href="#什么是-reflow" class="headerlink" title="什么是 reflow"></a><strong>什么是 reflow</strong></h2><p>reflow 的本质就是重新计算 layout 树<br>当进行了会影响布局树的操作后，需要重新计算布局树 会引发 layout<br>为了避免连续的多次操作导致布局树反复计算 浏览器会合并这些操作 当 JS 代码全部完成后在进行统一计算 所以改动属性造成的 reflow 是异步的<br>也同样因为如此 当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息<br>决定立即获取属性立即 reflow</p><h2 id="什么是-repaint"><a href="#什么是-repaint" class="headerlink" title="什么是 repaint"></a><strong>什么是 repaint</strong></h2><p>repaint 的本质就是重新根据分层信息计算了绘制指令<br>当改动了可见样式后 就需要重新计算 会引发 repaint<br>由于元素的布局信息也属于可见样式 所以 reflow 一定会引发 repaint</p><h1 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>现代浏览器中提供了多种的存储机制，比如常见的 localStorage、Session Storage、indexedDB、WebSQL、Cookies 等等<br>数据存储在浏览器中的使用场景有那些呢？比如</p><ul><li>浏览器存储中保持应用状态，如用户偏好、设置等的</li><li>创建离线工作的任务</li><li>缓存静态应用资源，比如 html、css、Js、img 等的</li><li>保存上次的会话，比如记录登录状态，购物车内容等的</li></ul><h2 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h2><p>HTML5 引入了 Web Storage，这让浏览器存储和检索数据变得很容易，WebStorage 提供了两个 API 来获取纯字符串的键值对</p><ul><li><code>localStorage</code>: 用于存储持久数据，除非是手动删除或者无痕模式，否则数据会一直保持存在</li><li><code>sessionStorage</code>: 用于存储临时会话数据，页面重写加载后仍然存在，选项卡关闭时数据丢失</li></ul><p>存储特点</p><ul><li>浏览器中有相关的存储 API，同时可以去 listener 去监听 storage 事件</li><li>存储限制为 5MB，同时只能存字符串，可以降对象等特殊数据采用 JSON 转换去保持</li><li>web worker 和 service work 无法访问，容易被 xss 攻击，不能存敏感信息，同步操作会存在阻塞</li></ul><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie 主要用于身份验证和用户数据持久性，Cookie 与请求一起发送到服务器，并在响应时发送给客户端，每次请求都会与服务器交换，服务器可以使用 cookie 向客户端发送个性化的内容，可以在一段时间后自动使数据过期的方式<br>每个 HTTP 请求和响应都会发送 Cookie 数据，存储过多的 Cookie 数据会使 HTTP 请求变得更加冗长</p><h2 id="Cookie-特点"><a href="#Cookie-特点" class="headerlink" title="Cookie 特点"></a>Cookie 特点</h2><ul><li>浏览器限制 cookie 的大小是 4kb，特定域允许的 cookie 的数量是 20 个，并且只能是字符串，操作同步，不能使用 web workers 来访问，通过全局的 window 对象访问</li><li>常用于会话管理、个性化、以及跨网站限制用户行为</li><li><strong>会话 Cookie：</strong> 没有指定 Expires 或 Max-Age 等属性，关闭浏览器会被删除</li><li><strong>持久 Cookie：</strong> 指定了 Expires 或 Max-Age 属性，在浏览器关闭的时候不会过期</li></ul><h2 id="Cookie-属性"><a href="#Cookie-属性" class="headerlink" title="Cookie 属性"></a>Cookie 属性</h2><h3 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h3><p>Domain 属性告诉浏览器允许那些主机访问 Cookie，如果未指定，则默认为设置 cookie 的同一主机，因此，当使用客户端的 js 去访问 cookie 的时，只能访问与 URL 域相同的 cookie，同样与 HTTP 请求的域共享相同域的 cookie 可以与请求头一起发送到服务器，可以设计顶域，方便获取 cookie</p><h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p>属性指定访问 cookie 必须存在的请求 URL 中的路径。除了将 cookie 限制到域之外，还可以通过路径来限制它。 路径属性为 Path&#x3D;&#x2F;store 的 cookie 只能在路径 &#x2F;store 及其子路径 &#x2F;store&#x2F;cart、&#x2F;store&#x2F;gadgets 等上访问</p><h3 id="Expires-Max-size"><a href="#Expires-Max-size" class="headerlink" title="Expires&#x2F;Max-size"></a>Expires&#x2F;Max-size</h3><p>属性用来设置 cookie 的过期时间。若设置其值为一个时间，那么当到达此时间后，cookie 就会失效。不设置的话默认值是 Session，意思是 cookie 会和 session 一起失效。当浏览器关闭(不是浏览器标签页) 后，cookie 就会失效。</p><h3 id="Secure"><a href="#Secure" class="headerlink" title="Secure"></a>Secure</h3><p>具有 Secure 属性的 cookie 仅可以通过安全的 HTTPS 协议发送到服务器，而不会通过 HTTP 协议。这有助于通过使 cookie 无法通过不安全的连接访问来防止中间人攻击。</p><h3 id="HTTPOnly"><a href="#HTTPOnly" class="headerlink" title="HTTPOnly"></a>HTTPOnly</h3><p>属性使 cookie 只能通过服务端访问。 因此，只有服务断可以通过响应头设置它们，然后浏览器会将它们与每个后续请求的头一起发送到服务器，并且它们将无法通过客户端 JavaScript 访问。</p><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>indexedDB 提供了一个类似 NoSQL 的 key&#x2F;value 数据库，可以存储大量结构化数据，甚至是文件和 blob，每个域至少有 1GB 的可用空间<br>key&#x2F;value 数据库意味着存储的所有数据都必须分配给一个 key。它将 key 与 value 相关联，key 用作该值的唯一标识符，这意味着可以使用该 key 跟踪该值。如果应用需要不断获取数据，key&#x2F;value 数据库使用非常高效且紧凑的索引结构来快速可靠地通过 key 定位值。使用该 key，不仅可以检索存储的值，还可以删除、更新和替换该值</p><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><ul><li>数据库：一个域可以创建任意数量的 indexedDB 数据库，只有同一域内的页面才能访问数据库</li><li>object store：相关数据项的 key&#x2F;value 存储，类似于数据库中的表</li><li>key：用于引用 object store 中每条记录（值）的唯一名称。它可以使用自动增量数字生成，也可以设置为记录中的任何唯一值</li><li>index：在 object store 中组织数据的另一种方式。搜索查询只能检查 key 或 index。</li><li>schema：object store、key 和 index 的定义。</li><li>version：分配给 schema 的版本号（整数）。 IndexedDB 提供自动版本控制，因此可以将数据库更新到最新 schema</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>特点如下：</strong></p><ul><li>可以将任何 JavaScript 类型的数据存储为键值对，例如对象（blob、文件）或数组等。</li><li>IndexedDB API 是异步的，不会在数据加载时停止页面的渲染。</li><li>可以存储结构化数据，例如 Date、视频、图像对象等。</li><li>支持数据库事务和版本控制。</li><li>可以存储大量数据。</li><li>可以在大量数据中快速定位&#x2F;搜索数据。</li><li>数据库是域专用的，因此任何其他站点都无法访问其他网站的 IndexedDB 存储，这也称为同源策略。</li></ul><p><strong>使用场景:</strong></p><ul><li>存储用户生成的内容：例如表单，在填写表单的过程中，用户可以离开并稍后再回来完成表单，存储之后就不会丢失初始输入的数据。</li><li>存储应用状态：当用户首次加载网站或应用时，可以使用 IndexedDB 存储这些初始状态。可以是登录身份验证、API 请求或呈现 UI 之前所需的任何其他状态。因此，当用户下次访问该站点时，加载速度会增加，因为应用已经存储了状态，这意味着它可以更快地呈现 UI。</li><li>对于离线工作的应用：用户可以在应用离线时编辑和添加数据。当应用程序来连接时，IndexedDB 将处理并清空同步队列中的这些操作。</li></ul><h1 id="浏览器中的网络传输"><a href="#浏览器中的网络传输" class="headerlink" title="浏览器中的网络传输"></a>浏览器中的网络传输</h1><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><blockquote><p>TCP&#x2F;IP 网络模型 一种通用的网络协议</p></blockquote><p>应用层 –&gt; 传输层 –&gt; 网络层 –&gt; 网络应用层 –&gt; 物理链路层</p><h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><ul><li><code>1xx</code>：属于提示信息，是协议处理中的中间状态(用到的少)</li><li><code>2xx</code>：表示服务器成功的处理了客户端的请求(预期情况)<ul><li><code>200ok</code>：最常见的成功状态码，表示一切正常，如果是非<code>HEAD</code>请求，服务器返回的响应头都会有<code>body</code>数据</li><li><code>204 No Content</code>：表示成功状态码，与 200 相同但是没有 body 数据</li><li><code>206 Partial Content</code>：应用于 HTTP 分块下载或者是断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分</li></ul></li><li><code>3xx</code>：表示客户端的请求资源发生了变动，需要客户端用新的 url 去重新发生请求获取资源，即是<strong>重定向</strong><ul><li><code>301 Moved Permanently</code>：永久重定向，说明请求的资源已经不存在了，需要用新的 url 去再次访问</li><li><code>302 Found</code>：表示临时重定向，说明请求的资源还在，但暂时需要改用新的 url 去访问</li><li><code>304 Not Modified</code>：不具有跳转的含义，表示资源未修改，去重定向已经缓存的文件，也称<strong>缓存重定向</strong>，用于缓存控制</li></ul></li><li><code>4xx</code>：表示客户端发送的报文有误，服务器无法处理<ul><li><code>400 Bad Request</code>：表示客户端的请求报文有错误，是一个笼统的错误处理</li><li><code>403 Forbidden</code>：表示服务器禁止访问资源 ，而不是客户端错误</li><li><code>404 Not Found</code>：表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端</li></ul></li><li><code>5xx</code>：表示客户端请求报文正确，但是服务器处理的时候内部发生了错误，属于服务端的错误码<ul><li><code>500 Inter Server Error</code>：与 400 一样是一个笼统的错误码，表示服务器发生了错误</li><li><code>501 Not Implemented</code>：表示客户端的请求还不支付，类似于即将开业的情况</li><li><code>502 Bad Gateway</code>：通常是服务器作为网关或者代理时返回的错误码</li><li><code>503 Service Unavalible</code>：服务器很忙暂时无法响应</li></ul></li></ul><h3 id="HTTP-中常见字段"><a href="#HTTP-中常见字段" class="headerlink" title="HTTP 中常见字段"></a>HTTP 中常见字段</h3><p><strong>Host 字段</strong>：客户端请求用来指定服务器的域名(Domain + Port)</p><p><strong>Content-length 字段：</strong>表面本次回应的数据长度</p><blockquote><p>Content-length 可以解决 TCP 中的粘包问题<br>TCP 中的粘包问题产生：我们不能认为一个用户消息对应一个 TCP 报文，因为 tcp 在发送报文的过程的时候会经过自己内部的发送窗口，拥塞控制和缓冲区大小等等共同解决的，所以 TCP 是面向字节流的协议</p><p>解决粘包问题在 HTTP 中是有特殊字符作为边界(空格、换行、回车) 和 content-length 作为数据长度 换行符做 HTTP Header 的边界 &amp;&amp; Content-Length 作为 HTTP Body 的边界 从而去解决这个问题</p></blockquote><p><strong>Connection 字段：</strong>常用于客户端要求服务器使用 HTTP 长连接机制，以便其他请求去复用 TCP 通道</p><blockquote><p>HTTP 长连接的特点是：只要任意一端没有明确的提出断开连接，特 TCP 会一直保持连接状态</p><p>HTTP 中的 Keep-Alive 和 TCP 中的 keepalive</p><p>HTTP 中的：HTTP(用户态)中的长链接，避免建立连接和释放的开销，也为 HTTP 流水线技术提供了可实现的基础(客户端可以先一次性发送多个请求，而在发送的过程中不需等待服务器的回应，可以减少整体的响应时间)，但是此时服务器的响应还是要按照顺序，这样就可能前一个请求太慢形成了阻塞也就是常说的队头阻塞问题，为了资源浪费也会设置一个 Keep-Alive-time 的字段去定时断开连接</p><p>TCP 中的：TCP 的保活机制，如果两端 TCP 一直没有数据交互，则达到触发 TCP 保活机制的条件，在内核中的 TCP 协议栈会发送探测报文去判断报告情况</p></blockquote><p><strong>Content-Type 字段(request &amp;&amp; response)：</strong>用于服务器返回的时候告诉客户端本次的数据格式，客户端请求的时候可以加上<strong>Accept</strong>表示自己应该接受什么类型</p><blockquote><p>(响应体中可以规定浏览器的默认行为 指向这次的媒体类型(MIME) text&#x2F;plain &amp;&amp; text&#x2F;html &amp;&amp; text&#x2F;javascript &amp;&amp; …</p></blockquote><p><strong>Content-Ending 字段：</strong>字段说明数据压缩的方式和请求中的可以接受<strong>Accept-Ending</strong>对应</p><h3 id="GET-和-POST"><a href="#GET-和-POST" class="headerlink" title="GET 和 POST"></a>GET 和 POST</h3><p>根据 RFC 规范来说：GET 是指从服务器获取指定资源，GET 的请求参数是写在 url 上的，必须是 ASCII，浏览器会对 URL 的长度有限制。POST 是指根据请求的负荷(body)对指定的资源做出处理，body 可以是任意格式的</p><blockquote><p>幂等：意思是执行多次，结果是一样的</p><p>安全：请求方法不会破坏服务器上面的资源</p></blockquote><p>根据 RFC 规范来看：GET 方法就是安全且幂等的，POST 是不安全且不幂等的</p><p>但是实际开发的过程中 GET 和可以实现增删改服务器上面的资源，POST 也可以用来查询数据，甚至 GET 可以带上 body，POST 也可以加上 URL 参数</p><h3 id="HTTP-缓存技术"><a href="#HTTP-缓存技术" class="headerlink" title="HTTP 缓存技术"></a>HTTP 缓存技术</h3><p>对于一些重复性的 HTTP 请求，比如每次请求到的数据是一样的，可以把这样的请求-响应的数据缓存在本地，避免 HTTP 请求的方法就是使用缓存，HTTP 中的缓存分成<strong>强制缓存</strong>和<strong>协商缓存</strong></p><h4 id="强制缓存-权重高"><a href="#强制缓存-权重高" class="headerlink" title="强制缓存(权重高)"></a>强制缓存(权重高)</h4><p>只要浏览器的缓存没过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器</p><p>强制缓存是利用到下面两个 HTTP 响应头部的字段信息去完成的，都用来表示资源在客户端的缓存有效期</p><ul><li><code>Cache-Control：</code>相对时间 &amp;&amp; 也可以设置别的参数 如<code>ctx.set(&#39;Cache-Control&#39;, &#39;max-age=3600, public&#39;)</code> (权重高)</li><li><code>Expries:</code> 是一个相对时间</li></ul><p>流程：浏览器第一次访问服务器资源的时候，服务器会返回某个资源并且在 response 上面设置对应的响应字段，浏览器保存后，在次请求的时候<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，服务器在次收到请求后会重新更新头部的<strong>Cache-Control</strong></p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p><strong>请求响应码是 304</strong>，服务端告知客户端是否可以使用缓存的方式叫<strong>协商缓存</strong>，即通过<strong>协商缓存结果来判断是否可以使用本地缓存</strong></p><p>也可以基于两种形式去完成协商缓存的过程</p><ul><li><code>RES: If-Modified-Since &amp;&amp; REQ: Last-Modified</code>：资源过期后，发现 reponse 中含有 Last-Modified 字段，则在次发起请求的时候带上 Last-Modified 发送给服务器，服务器去根据这项时间去跟对比返回</li><li><code>RES: If-None-Match &amp;&amp; REQ: Etag</code>: 资源过期后，同比较<code>Etag</code> 是否 相同, 一般是使用 hash 去给内容做一个唯一的 token 值去比较，权重高，如果不存在则比较时间</li></ul><p>使用 Etag 的好处：监控的粒度更加深，可以精确到毫秒内，不会存在手动改写时间的情况</p><p><strong>协商缓存字段只有在设置了 Cache-Control 强制缓存字段后，未命中强制缓存的时候，才能发起带有协商缓存的字段请求</strong></p><h3 id="HTTP-特性"><a href="#HTTP-特性" class="headerlink" title="HTTP 特性"></a>HTTP 特性</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><ul><li>简单：基本报文格式就是 header + body，头部信息也是：key-value 简单文本形式，易于理解</li><li>灵活，易于扩展：HTTP 中的各种请求方法，URL，状态码，头字段等都没有被规定死，允许开发人员自定义</li><li>应用广泛和跨平台</li><li>无状态：服务器不会去记忆 HTTP 状态，不需要额外的资源去使用，减轻服务器的负担，但是没有记忆性，做到一些关联性操作会非常麻烦于是就引出了关于<code>Cookie</code>等技术</li><li>明文传输，不安全，通信使用明文，不验证通信的双方，不能验证报文的完整性</li></ul><h4 id="HTTP-1-1-性能"><a href="#HTTP-1-1-性能" class="headerlink" title="HTTP&#x2F;1.1 性能"></a>HTTP&#x2F;1.1 性能</h4><p>基于 TCP&#x2F;IP 协议，请求-应答的模式，即性能判断就在这两点上面</p><ul><li>长连接：早期的 HTTP1.0 是每发起一个请求都会建立 TCP 连接&#x2F;断开 TCP 连接，消费资源比较大 1.1 提出长连接，没有一方 close 会一直保持</li><li>管道网络传输：在同一个 TCP 连接中，客户端可以发起多个请求，可以减少整体的响应时间，但是服务器的响应必须按照请求的顺序，这样就造成了队头阻塞的问题</li><li>队头阻塞</li></ul><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>HTTP 是明文传输存在，窃听，篡改，冒充等风险</p><p>HTTPS 在 HTTP 和 TCP 之间增加了<code>SSL/TLS</code>协议，可以很好的解决上面 HTTP 的缺点</p><ul><li>信息加密：混合加密的方式来实现信息的机密性，比如 RSA 算法</li><li>校验机制：摘要算法+数字签名 来实现完整性，为数据生成独一无二的指纹</li><li>身份证书：将服务器公钥放入数字证书中，解决冒充的风险</li></ul><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h4><p>HTTP2 协议是基于 HTTPS 的</p><p>相比较 HTTP&#x2F;1 有如下的更新</p><ul><li>头部压缩：HTTP 中会<strong>压缩头(Header)</strong>,如果同时发送的请求头是一样的，协议栈会消除重复的部分，<code>HPACK</code>算法去打表</li><li>二进制格式：采用二进制格式去实现，头信息和数据体都是二进制，统称为帧(frame)，头信息帧和数据帧</li><li>并发传输：引入 Stream 概念，多个 Stream 复用一条 TCP 的连接，针对不同的 HTTP 请求使用独一无二的 Stream 来区分，可以交错的发送和请求报文</li><li>服务器主动推送资源：服务端和客户端双方都可以建立 Stream，使用数字的奇偶来区分</li></ul><p>缺点：HTTP2 是基于 TCP 协议来传输的数据，TCP 是基于字节流，必须保证接受到的字节流是完整且连续的，这样才会从内核缓冲区中取数据去发送给 HTTP 应用，当前一个字节没有发送的时候，后面的数据只能放在缓冲区中，等待第一个字节数据到达才会发送给 HTTP 应用</p><h4 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h4><p>HTTP&#x2F;1.1 中的管道虽然可以解决请求的问题，但是没有解决响应的队头阻塞问题。HTTP&#x2F;2 虽然通过 Stream 多路复用解决了 HTTP 队头阻塞的问题，但是一旦发现丢包则会阻塞所有的 HTTP 请求，属于 TCP 层的队头阻塞</p><p>HTTP2 中的问题是 TCP 导致的队头阻塞，但是 TCP 的特点就是基于字节流，所以 HTTP3 就是将传输换成了 UDP，实现了基于 UDP 的格式方法机制</p><p>UDP 的 QUIC 协议：在 UDP 上面实现的伪 TCP + TLS + HTTP&#x2F;2 的多路复用协议</p><ul><li>无队头阻塞：QUIC 协议也有类似的 Stream 的机制，保证传输的可靠性，但是多个 Stream 是没有依赖的相互独立，当某个流丢包的时候，只会阻塞这个流，并不会影响到其他的流</li><li>更快的建立连接：因为 QUIC 内部包含 TLS 1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与 TLS 密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</li><li>连接迁移无感</li></ul><h3 id="HTTP-优化"><a href="#HTTP-优化" class="headerlink" title="HTTP 优化"></a>HTTP 优化</h3><ul><li><p>尽量避免发送 HTTP 请求：通过缓存技术(HTTP Cache)去完成缓存功能，包括强制缓存和协商缓存等</p></li><li><p>在需要发送 HTTP 请求的时候考虑如何减少次数</p><ul><li>减少重定向请求次数：通过中间层服务器去完成这个定向请求的功能而不是去跟客户端交互</li><li>合并请求：比如通用的配置生成一个 configs 的大请求，小的资源图去形成大的精灵图，减少 HTTP 次数的请求</li><li>延迟发送请求：懒加载，按需请求等</li></ul></li><li><p>减少服务器的 HTTP 响应的数据大小：无损压缩和有损压缩</p></li></ul><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>本质上就是一种基于传输层的一种通信方式，Remote Procedure Call 远程过程调用，调用方式，有很多封装好的 RPC 协议比如 GRPC 等的是在应用层的一种协议，一般是用来在集群内部的通信，调用远端的方法可以屏蔽一些网络的细节</p><p>与 HTTP 的区别：</p><ul><li>服务发现：HTTP 中通过 DNS 服务去解析背后的 IP 和端口，RPC 一般会有中间服务去保存服务器名和 IP 信息，Etcd、redis 等</li><li>底层连接形式：RPC 会在底层建立一个连接池，在请求量大的时候，建立多条连接放在池内</li><li>传输内容：定制程度高，不用考虑浏览的行为，效率性能高</li></ul><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>TCP 连接的两端是在<strong>同一时间</strong>，双方都可以主动的想对方发送数据，即是所谓的<strong>全双工</strong>，然而 HTTP&#x2F;1.1 是基于 TCP 的，同一段时间段内客户端和服务器只能有一方主动的发送消息即是<strong>半双工</strong></p><p>因为最开始的网页设计就是看文本等场景，只需要请求-应答的模式即可以，但是现在场景越多，需求越多，这样基于 TCP 的新应用层协议 Websocket 即出来了</p><p>在早期做到服务器推送消息的时候：</p><p><strong>HTTP 不断轮询：</strong> 在前端代码中不断地定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应信息，伪服务器的推送手段，只是用户无感而已<br>这种缺点也是非常的明显，消耗带宽，满屏的 http 请求，边缘 case 等</p><p><strong>HTTP 长轮询：</strong>将 HTTP 请求的超时时间设置的很大，在这段时间内服务器只要收到了请求的信息，就立马返回给客户端，如果超时则立马发起下一个请求</p><h4 id="浏览器中怎么建立的-x-连接"><a href="#浏览器中怎么建立的-x-连接" class="headerlink" title="浏览器中怎么建立的 x 连接"></a>浏览器中怎么建立的 x 连接</h4><p>为了在浏览器中兼容 HTTP 协议，浏览器在进行 TCP 三次握手后，都统一使用 HTTP 协议先进行一次通信</p><ul><li><p>如果是普通的 HTTP 请求，则继续使用 HTTP 协议进行交互</p></li><li><p>如果是想建立 WebSocket 过程，则会在 HTTP 中携带一些特殊的 header 头信息，如下所示</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>Websocket</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>Explosionaabbccdd32423=123\r\n</span><br></pre></td></tr></table></figure><p>header 头的意思是：浏览器想升级协议，并且想升级成 WebSocket，同时随机携带一个随机生成的 base64 码作为 key 发给服务器</p><p>如果服务器支持 WebSocket 连接协议就会去走 WebSocket 的握手流程，同时根据客户端生成的 base64 码，根据公开的算法去生成对应的字符串返回同时变成 101 状态码</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols\r\n</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>acnasunafsvnpsirghpw\r\n</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>WebSocket\r\n</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade\r\n</span><br></pre></td></tr></table></figure></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/network/websocket_connect.png"></p><h4 id="WebSocket-使用场景"><a href="#WebSocket-使用场景" class="headerlink" title="WebSocket 使用场景"></a>WebSocket 使用场景</h4><p>完成的实现了 TCP 的全双工的能力，并且也解决了粘包问题，适用于服务端和客户端需要大量交互的场景</p><details class="folding-tag" cyan><summary>查看默认打开的折叠框</summary><div class="content"><ul><li>TCP 协议本身是全双工的，但是 HTTP 协议设计的是半双工，对大部分服务器要推送的场景使用 WebSocket 更合适</li><li>基于简单的场景的比如登录等场景，可以使用长轮询或者定时轮询去实习服务器推送功能</li><li>正因为各个浏览器都支持 HTTP 协 议，所以 WebSocket 会先利用 HTTP 协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了</li></ul></div></details><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="TCP-的基本格式"><a href="#TCP-的基本格式" class="headerlink" title="TCP 的基本格式"></a>TCP 的基本格式</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/network/tcp_transport.png"></p><p>序列号：在建立连接计算机随机生成的随机数去做为初始值，通过 SYN 包发送给接收端的主机，每次增加数据字节数去累加判断，<strong>用来解决网络包乱序的问题</strong></p><p>确认应答号：指下一次期望接受收到的数据序列号，<strong>用来解决丢包的问题</strong></p><blockquote><p>TCP 是一个工作在传输层的可靠数据传输的服务，能确保接受端接受到的网络包是无损坏、无间隔、非冗余、按序的</p></blockquote><h4 id="TCP-特点"><a href="#TCP-特点" class="headerlink" title="TCP 特点"></a>TCP 特点</h4><p>TCP 是 <strong>面向连接</strong>、<strong>可靠的</strong>、<strong>基于字节流的</strong>传输层通信协议</p><ul><li><strong>面向连接</strong>：一对一才能连接</li><li><strong>可靠的</strong>：无论网络链路出现了什么样的变化，TCP 都可以保证一个报文一定能到达接收端</li><li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统分组成多个 TCP 报文，通过消息边界来确定，没接受到的等待，重复的丢弃</li></ul><h4 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h4><p>用于保证可靠状态和流量传输控制维护的某些状态信息这些信息包括：Sokcet(IP + port)、序列号(解决乱序问题)、窗口大小(流量控制)</p><h4 id="TCP-建立连接过程"><a href="#TCP-建立连接过程" class="headerlink" title="TCP 建立连接过程"></a>TCP 建立连接过程</h4><p>TCP 是面相连接的协议，所以必须先建立连接，连接是通过三次握手来进行的，过程如下</p><ul><li>刚开始：client 和 server 端都处理 CLOSE 状态，server 主动监听端口，变成 LISTEN 状态</li><li>客户端会初始化序列号(client_isn)，将此序列号置于 TCP 首部的序列号字段中，同时把 SYN 的字段设置成 1，表示 SYN 报文，之后把这个 SYN 报文发送给服务端，表示发起连接请求，该报文并不包含应用层数据，发送后的客户端处于 SYN-SEND 状态</li><li>服务端收到客户端的 SYN 后，首先也直接初始化一个随机数字作为 server_isn，放入序列号字段中，同时将确认答应号填成 client_isn + 1 把 SYN 和 ACK 的值都变成 1，发送回去，同时也不包含任何的应用层数据</li><li>客户端接受到了服务端数据后，还要向服务端去发送一个确认消息，确认应答号是 srever_isn + 1，将 ACK 变成 1，之后服务器处于 ESTABLISHED 状态，这个时候可以携带应用层数据</li><li>客户端处于 ESTABLISHED 状态</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/network/tcp_thrid_get.png"></p><h4 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h4><ul><li>阻止重复历史连接的初始化：在网络拥堵的情况下，客户端可以确认自己希望收到的应答号去进行对比确认</li><li>同步双方的初始序列号：去除从重复数据，根据数据包的序列号按需接受，可以识别发送的数据包是否被接受</li><li>避免浪费资源</li></ul><h4 id="TCP-断开连接的过程"><a href="#TCP-断开连接的过程" class="headerlink" title="TCP 断开连接的过程"></a>TCP 断开连接的过程</h4><p>TCP 的连接是通过四次挥手来完成</p><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置位 1 的报文，即是 FIN 报文，之后客户端进入 FIN_WAIT_1 的状态</li><li>服务端接受到报文信息后就向客户端发送 ACK 应答报文，同时自己的状态进入 CLOSE_WAIT</li><li>客户端接受到 ACK 报文后，进入 FIN_WAIT_2 的状态</li><li>等地服务器处理完数据后，向客户端发送一个 FIN 报文，之后进入 LAST_ACK 状态</li><li>客户端接受到 FIN 报文，回答一个 ACK 报文，同时自己的状态进入 TIME_WAIT</li><li>服务器收到 ACK 报文后，进入 CLOSE 状态</li><li>客户端经过 2MSL 后一段时间后，自动进入 CLOSE 状态(丢包重传的情况)</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/network/tcp_duankai_four.png"></p><h4 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h4><ul><li>关闭连接时，客户端向服务端发送 FIN，只是代表了客户端不发送数据了，但是还是可以去接受数据</li><li>服务端收到客户端的 FIN 时，回首先回复一个 ACK 的报文，而服务端可能还有数据需要处理和转发，等服务器不在发送数据后才会回复一个 FIN 报文向客户端表示同意关闭连接了</li></ul><p>故服务端通常是要等待数据发送和处理完，所以服务端的 ACK 和 FIN 会分开发送即是四次挥手</p><p><strong>服务器出现大量的 TIME_WAIT 状态有那些原因？</strong></p><ul><li>HTTP 没有使用长连接</li><li>HTTP 长连接超时</li><li>HTTP 长连接请求达到数量</li></ul><h4 id="TCP-功能"><a href="#TCP-功能" class="headerlink" title="TCP 功能"></a>TCP 功能</h4><ul><li>重传机制</li><li>滑动窗口</li><li>流量控制</li><li>拥塞控制</li></ul><h3 id="IP-层"><a href="#IP-层" class="headerlink" title="IP 层"></a>IP 层</h3><p>IP 层是在网络层，主要作用是：实现主机与主机之间的通信，即是<strong>点对点(end to end)通信</strong></p><blockquote><p>网络层和数据链路层的区别和关系</p><p>MAC 的作用是实现直连的两个设备之间的通信，而 IP 层则负责在没有直连的两个网络之间进行通信传输</p></blockquote><p>计算机中是依靠数据链路层和网络层去实现目标 IP 的最终通信，在网络传输的过程中，源 IP 和目标 IP 地址是不会变化的(除了 NAT 技术)，只有源 MAC 和目标的 MAC 在不断地发生变化，不停的在网络中去寻找下一跳要发送的地方</p><p>在 TCP&#x2F;IP 网络通信中，为了保证能正常的通信，每个设备都要配置正确的 IP 地址，以便寻址</p><h4 id="IP-地址分类"><a href="#IP-地址分类" class="headerlink" title="IP 地址分类"></a>IP 地址分类</h4><p>IP 地址最初被划分成 ABCDE 五种类型，通过前几位来判断是处于的地方</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/network/IPhuafen.png"></p><p>在主机号中有两个 IP 是特殊的</p><ul><li>主机号全为 1：指定某个网络下的所有主机，用于广播，分本地广播和直接广播</li><li>主机号为 0：指定某个网络</li></ul><h4 id="无分类地址-CIDR"><a href="#无分类地址-CIDR" class="headerlink" title="无分类地址 CIDR"></a>无分类地址 CIDR</h4><p>由于 IP 分类存在一些缺点，比如同一个网络下没有地址层次，缺少地址的灵活性，大类中的数量不能很好的与现实网络匹配等</p><p>提出了无分类地址<code>CIDR</code>的概念 32 位的地址划分成了前面网络号，后面是主机号</p><blockquote><p>怎么划分网络号和主机号呢？</p><p>变现形式有：a.b.c.d&#x2F;x x 表示网络号 &amp;&amp; 给 IP 地址和子网掩码去进行与运算得到网络号</p></blockquote><p>为什么存在网络号？</p><p>方便路由寻址工作，在路由寻址的时候，先进行广播找到网络地址是否相同，如果相同则在同一个网段内，直接发送数据包到目的主机即可，用于路由控制</p><p>子网掩码的另一个作用：可以划分子网，将主机地址划分成：子网网络地址 &amp; 子网主机地址</p><h4 id="IP-地址和路由控制"><a href="#IP-地址和路由控制" class="headerlink" title="IP 地址和路由控制"></a>IP 地址和路由控制</h4><p><strong>IP 地址中的网络地址这一部分是用于进行路由控制</strong></p><p>路由控制表中记录着网络地址和下一步应该发送至路由器的地址，在主机和路由器上都会有各自的路由器控制表</p><p>在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最长匹配。</p><p>IP 协议相关技术</p><ul><li><strong>DNS：</strong> DNS 域名解析，递归或者循环去取数据，去完成查询到最终域名的 IP 地址，(从本地域名开始访问，根域不同的向下查询)</li><li><strong>ARP：</strong> 通过 ARP 协议，可以根据 IP 地址去查询到对应的 MAC 地址，ARP 是借助 ARP 请求和 ARP 响应来完成功能的，通过广播发送 ARP 请求，设备去查看，在形成 ARP 响应，返回得到信息，操作系统中存在 arp 的 cache，反之有<strong>RARP 协议</strong></li><li><strong>DHCP：</strong> DHCP 去获取动态的 IP，全程通信使用 UDP</li><li><strong>NAT：</strong> 生成私有 IP，用于学校，家庭等设备很多的地方，可以架设一个 NAT 池</li><li><strong>ICMP：</strong> 互联网控制报文协议，确认 IP 包是否成功的送达目标地址，报告发送过程中 IP 包被废弃的原因和改善网络设施等</li></ul><h2 id="同源策略和跨域"><a href="#同源策略和跨域" class="headerlink" title="同源策略和跨域"></a>同源策略和跨域</h2><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>跨域问题其实就是浏览器的同源策略造成的</p><blockquote><p>同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互，这是浏览器的一个用于隔离潜在恶意文件的重要安全机制</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/network6.png" alt="image-20230112102913056"></p><p><strong>同源策略：</strong> protocol(协议)、domain(域名)、port(端口) 三者必须一致</p><p>同源策略主要限制了下面方面</p><ul><li>当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage、indexDB</li><li>当前域下的 js 脚本不能操作其他域下的 DOM</li><li>当前域下 ajax 无法发送跨域请求</li></ul><p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者 script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p><h3 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h3><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><blockquote><p>CORS：跨域资源共享，使用额外的 HTTP 头来告诉浏览器，让运行在一个 origin(domain)上的 Web 应用被准许访问来自不同源服务器上的指定的资源，当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求</p></blockquote><p>CORS 需要浏览器和服务器同时支持，整个 CORS 过程都是浏览器完成的，无需用户参与。因此实现 CORS 的关键就是服务器，只要服务器实现了 CORS 请求，就可以跨源通信了</p><p>浏览器将 CORS 分成<strong>简单请求</strong>和<strong>复杂请求</strong>：<br>简单请求不会触发 CORS 预检请求，若该请求满足一下两个条件</p><ul><li>请求方法是 <strong>HEAD、GET、POST</strong> 中的一种</li><li>自定义的 HTTP 的头部信息不超过：Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type: 只限于 application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain</li></ul><p><strong>简单请求过程：</strong><br>对于简单请求，浏览器会直接发出 CORS 请求，会在请求的头信息中增加一个 Origin 字段，字段用来说明是在哪个源，服务器会根据这个值来决定是否同意请求<br><strong>在简单请求中，在服务器内，至少需要设置字段：<code>Access-Control-Allow-Origin</code></strong></p><p><strong>复杂请求</strong><br>复杂请求是对服务器有特殊要求，比如请求方法为 DELETE 或 PUT 等，复杂请求会在正式通信之前进行一次 HTTP 查询请求，称为<strong>预检请求</strong><br>浏览器会询问服务器，当前所在的网页是否在服务器允许访问的范围内，以及可以使用哪些 HTTP 请求方式和头信息字段，只有得到肯定的回复，才会进行正式的 HTTP 请求，否则就会报错。<br>预检请求使用的请求方法是 OPTIONS，表示这个请求是来询问的。他的头信息中的关键字段是 origin，表示请求来自哪个源。除此之外，头信息中还包括两个字段：</p><ul><li>Access-Control-Request-Method：该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法。</li><li>Access-Control-Request-Headers： 该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段。<br>服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，如果返回的头信息在中有 Access-Control-Allow-Origin 这个字段就是允许跨域请求，如果没有，就是不同意这个预检请求，就会报错。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">https</span>:<span class="comment">//blog.yueyun.com  // 允许跨域的源地址</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Methods</span>: <span class="variable constant_">GET</span>, <span class="variable constant_">POST</span>, <span class="variable constant_">PUT</span> <span class="comment">// 服务器支持的所有跨域请求的方法</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Headers</span>: X-<span class="title class_">Custom</span>-<span class="title class_">Header</span>  <span class="comment">// 服务器支持的所有头信息字段</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credentials</span>: <span class="literal">true</span>   <span class="comment">// 表示是否允许发送Cookie</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Max</span>-<span class="title class_">Age</span>: <span class="number">1728000</span>  <span class="comment">// 用来指定本次预检请求的有效期，单位为秒</span></span><br></pre></td></tr></table></figure><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>jsonp 的原理就是利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签 src 属性，发送带有 callback 参数的 GET 请求，服务端将接口返回数据拼凑到 callback 函数中，返回给浏览器，浏览器解析执行，从而前端拿到 callback 函数返回的数据。<br>原生 JS 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    script.<span class="property">type</span> = <span class="string">&#x27;text/javascript&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span></span></span><br><span class="line"><span class="language-javascript">    script.<span class="property">src</span> = <span class="string">&#x27;http://blog.yueyun.com:8080/login?user=admin&amp;callback=handleCallback&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 回调执行函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">handleCallback</span>(<span class="params">res</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(res));</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后端 nodejs 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queryString = <span class="built_in">require</span>(<span class="string">&#x27;queryString&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> params = queryString.<span class="title function_">parse</span>(req.<span class="property">url</span>.<span class="title function_">split</span>(<span class="string">&#x27;?&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">const</span> fn = params.<span class="property">callback</span></span><br><span class="line">  <span class="comment">// jsonp返回设置</span></span><br><span class="line">  res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/javascript&#x27;</span> &#125;)</span><br><span class="line">  res.<span class="title function_">write</span>(fn + <span class="string">&#x27;(&#x27;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(params) + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">  res.<span class="title function_">end</span>()</span><br><span class="line">&#125;)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="string">&#x27;8080&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>)</span><br></pre></td></tr></table></figure><p>JSONP 的缺点：</p><ul><li>具有局限性， 仅支持 get 方法</li><li>不安全，可能会遭受 XSS 攻击</li></ul><h3 id="nginx-代理跨域"><a href="#nginx-代理跨域" class="headerlink" title="nginx 代理跨域"></a>nginx 代理跨域</h3><ol><li>代理静态资源</li><li>服务端反向代理</li></ol><h3 id="nodejs-中间件代理跨域"><a href="#nodejs-中间件代理跨域" class="headerlink" title="nodejs 中间件代理跨域"></a>nodejs 中间件代理跨域</h3></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/yueyun.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/yueyun.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">月晕</div><div class="post-copyright__author_desc">生命是有光的</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.yueyun.site/posts/e28d3347.html">原创</a><a class="post-copyright-title"><span onclick='rm.copyPageUrl("https://blog.yueyun.site/posts/e28d3347.html")'>浏览器原理</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.yueyun.site/posts/e28d3347.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><script>function copyCurrentPageUrl(){var e=window.location.href,t=document.createElement("input");t.setAttribute("value",e),document.body.appendChild(t),t.select(),t.setSelectionRange(0,99999),document.execCommand("copy"),document.body.removeChild(t)}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.yueyun.site" target="_blank">月晕</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"><span class="categoryes-punctuation"><i class="anzhiyufont anzhiyu-icon-inbox"></i></span>浏览器<span class="categoryesPageCount">1</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tags-punctuation"><i class="anzhiyufont anzhiyu-icon-tag"></i></span>前端<span class="tagsPageCount">14</span></a><a class="post-meta__box__tags" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>浏览器原理<span class="tagsPageCount">1</span></a></div></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/79666db.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1700892602354.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构</div></div></a></div><div class="next-post pull-right"><a href="/posts/7251401c.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/qiuqiunile.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">NestJS学习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size:1.5rem;margin-right:4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/938f2f9c.html" title="React Native开坑"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1702557508740.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-15</div><div class="title">React Native开坑</div></div></a></div><div><a href="/posts/9ac48510.html" title="React学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1701613946910.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-12</div><div class="title">React学习</div></div></a></div><div><a href="/posts/49ae955a.html" title="React 源码分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/wallpaper/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-15</div><div class="title">React 源码分析</div></div></a></div><div><a href="/posts/317b894e.html" title="Vue学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1702396713207.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-12</div><div class="title">Vue学习</div></div></a></div><div><a href="/posts/262c4a52.html" title="前端工程化配置，工程能力学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1722687861605.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-08-09</div><div class="title">前端工程化配置，工程能力学习</div></div></a></div><div><a href="/posts/616f4683.html" title="前端性能优化"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1700908475489.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-08-27</div><div class="title">前端性能优化</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)" style="display:none">匿名评论</a><a href="/privacy" style="margin-left:4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/yueyun.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"><div class="author-info__decoration"><img class="avatar-decoration-1" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/avatar_desc/avatar_d1.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="decoration"><img class="avatar-decoration-2" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/avatar_desc/avatar_d2.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="decoration"><img class="avatar-decoration-3" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/avatar_desc/avatar_d3.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="decoration"><img class="avatar-decoration-4" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/avatar_desc/avatar_d4.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="decoration"></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><h1 class="author-info__name">月晕</h1><div class="author-info__desc">生命是有光的</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=3514392356&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="anzhiyufont anzhiyu-icon-qq"></i></a><a class="social-icon faa-parent animated-hover" href="https://github.com/apprehen" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/554370301" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.</span> <span class="toc-text">浏览器事件循环</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">浏览器的进程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">何为进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">何为线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">浏览器有哪些进程和线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">1.2.</span> <span class="toc-text">渲染主线程是如何工作的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E8%A7%A3%E9%87%8A"><span class="toc-number">1.3.</span> <span class="toc-text">一些解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-number">1.3.1.</span> <span class="toc-text">异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E4%B8%BA%E4%BD%95%E4%BC%9A%E9%98%BB%E7%A2%8D%E6%B8%B2%E6%9F%93"><span class="toc-number">1.3.2.</span> <span class="toc-text">JS为何会阻碍渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.3.3.</span> <span class="toc-text">任务优先级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">浏览器渲染原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%A7%A3%E6%9E%90-HTML-Parse-HTML"><span class="toc-number">2.1.</span> <span class="toc-text">1. 解析 HTML - Parse HTML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%A1%E7%AE%97"><span class="toc-number">2.2.</span> <span class="toc-text">2. 计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B8%83%E5%B1%80"><span class="toc-number">2.3.</span> <span class="toc-text">3. 布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%88%86%E5%B1%82"><span class="toc-number">2.4.</span> <span class="toc-text">4.分层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BB%98%E5%88%B6"><span class="toc-number">2.5.</span> <span class="toc-text">5.绘制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%88%86%E5%9D%97"><span class="toc-number">2.6.</span> <span class="toc-text">6.分块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%85%89%E6%A0%85%E5%8C%96"><span class="toc-number">2.7.</span> <span class="toc-text">7.光栅化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%94%BB"><span class="toc-number">2.8.</span> <span class="toc-text">8.画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-reflow"><span class="toc-number">2.9.</span> <span class="toc-text">什么是 reflow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-repaint"><span class="toc-number">2.10.</span> <span class="toc-text">什么是 repaint</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8"><span class="toc-number">3.</span> <span class="toc-text">浏览器存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-Storage"><span class="toc-number">3.2.</span> <span class="toc-text">Web Storage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie"><span class="toc-number">3.3.</span> <span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie-%E7%89%B9%E7%82%B9"><span class="toc-number">3.4.</span> <span class="toc-text">Cookie 特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie-%E5%B1%9E%E6%80%A7"><span class="toc-number">3.5.</span> <span class="toc-text">Cookie 属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Domain"><span class="toc-number">3.5.1.</span> <span class="toc-text">Domain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Path"><span class="toc-number">3.5.2.</span> <span class="toc-text">Path</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Expires-Max-size"><span class="toc-number">3.5.3.</span> <span class="toc-text">Expires&#x2F;Max-size</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Secure"><span class="toc-number">3.5.4.</span> <span class="toc-text">Secure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPOnly"><span class="toc-number">3.5.5.</span> <span class="toc-text">HTTPOnly</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IndexedDB"><span class="toc-number">3.6.</span> <span class="toc-text">IndexedDB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="toc-number">3.6.1.</span> <span class="toc-text">相关术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">3.6.2.</span> <span class="toc-text">特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93"><span class="toc-number">4.</span> <span class="toc-text">浏览器中的网络传输</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">4.1.</span> <span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">4.1.1.</span> <span class="toc-text">常见状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E4%B8%AD%E5%B8%B8%E8%A7%81%E5%AD%97%E6%AE%B5"><span class="toc-number">4.1.2.</span> <span class="toc-text">HTTP 中常见字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-%E5%92%8C-POST"><span class="toc-number">4.1.3.</span> <span class="toc-text">GET 和 POST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="toc-number">4.1.4.</span> <span class="toc-text">HTTP 缓存技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98-%E6%9D%83%E9%87%8D%E9%AB%98"><span class="toc-number">4.1.4.1.</span> <span class="toc-text">强制缓存(权重高)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">4.1.4.2.</span> <span class="toc-text">协商缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E7%89%B9%E6%80%A7"><span class="toc-number">4.1.5.</span> <span class="toc-text">HTTP 特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP"><span class="toc-number">4.1.5.1.</span> <span class="toc-text">HTTP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-1-1-%E6%80%A7%E8%83%BD"><span class="toc-number">4.1.5.2.</span> <span class="toc-text">HTTP&#x2F;1.1 性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS"><span class="toc-number">4.1.5.3.</span> <span class="toc-text">HTTPS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-2"><span class="toc-number">4.1.5.4.</span> <span class="toc-text">HTTP&#x2F;2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-3"><span class="toc-number">4.1.5.5.</span> <span class="toc-text">HTTP&#x2F;3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E4%BC%98%E5%8C%96"><span class="toc-number">4.1.6.</span> <span class="toc-text">HTTP 优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC"><span class="toc-number">4.1.7.</span> <span class="toc-text">RPC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket"><span class="toc-number">4.1.8.</span> <span class="toc-text">WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%80%8E%E4%B9%88%E5%BB%BA%E7%AB%8B%E7%9A%84-x-%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.1.8.1.</span> <span class="toc-text">浏览器中怎么建立的 x 连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebSocket-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.1.8.2.</span> <span class="toc-text">WebSocket 使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP"><span class="toc-number">4.1.9.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.1.9.1.</span> <span class="toc-text">TCP 的基本格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.9.2.</span> <span class="toc-text">TCP 特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.1.9.3.</span> <span class="toc-text">TCP 连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">4.1.9.4.</span> <span class="toc-text">TCP 建立连接过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">4.1.9.5.</span> <span class="toc-text">为什么需要三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.1.9.6.</span> <span class="toc-text">TCP 断开连接的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">4.1.9.7.</span> <span class="toc-text">为什么需要四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E5%8A%9F%E8%83%BD"><span class="toc-number">4.1.9.8.</span> <span class="toc-text">TCP 功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-%E5%B1%82"><span class="toc-number">4.1.10.</span> <span class="toc-text">IP 层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IP-%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB"><span class="toc-number">4.1.10.1.</span> <span class="toc-text">IP 地址分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%88%86%E7%B1%BB%E5%9C%B0%E5%9D%80-CIDR"><span class="toc-number">4.1.10.2.</span> <span class="toc-text">无分类地址 CIDR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IP-%E5%9C%B0%E5%9D%80%E5%92%8C%E8%B7%AF%E7%94%B1%E6%8E%A7%E5%88%B6"><span class="toc-number">4.1.10.3.</span> <span class="toc-text">IP 地址和路由控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F"><span class="toc-number">4.2.</span> <span class="toc-text">同源策略和跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-number">4.2.1.</span> <span class="toc-text">同源策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.2.</span> <span class="toc-text">如何解决跨域问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CORS"><span class="toc-number">4.2.3.</span> <span class="toc-text">CORS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSONP"><span class="toc-number">4.2.4.</span> <span class="toc-text">JSONP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nginx-%E4%BB%A3%E7%90%86%E8%B7%A8%E5%9F%9F"><span class="toc-number">4.2.5.</span> <span class="toc-text">nginx 代理跨域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nodejs-%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BB%A3%E7%90%86%E8%B7%A8%E5%9F%9F"><span class="toc-number">4.2.6.</span> <span class="toc-text">nodejs 中间件代理跨域</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/616f4683.html" title="前端性能优化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1700908475489.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="前端性能优化"></a><div class="content"><a class="title" href="/posts/616f4683.html" title="前端性能优化">前端性能优化</a><time datetime="2024-08-27T23:20:29.000Z" title="发表于 2024-08-27 23:20:29">2024-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/262c4a52.html" title="前端工程化配置，工程能力学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1722687861605.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="前端工程化配置，工程能力学习"></a><div class="content"><a class="title" href="/posts/262c4a52.html" title="前端工程化配置，工程能力学习">前端工程化配置，工程能力学习</a><time datetime="2024-08-09T01:07:53.000Z" title="发表于 2024-08-09 01:07:53">2024-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f576a3fe.html" title="记录第一次字节实习offer"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/8c52b9660688cedcc40580545cef9ba4.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="记录第一次字节实习offer"></a><div class="content"><a class="title" href="/posts/f576a3fe.html" title="记录第一次字节实习offer">记录第一次字节实习offer</a><time datetime="2024-07-26T22:56:41.000Z" title="发表于 2024-07-26 22:56:41">2024-07-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8f49bd54.html" title="前端技术探索"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1719120534005.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="前端技术探索"></a><div class="content"><a class="title" href="/posts/8f49bd54.html" title="前端技术探索">前端技术探索</a><time datetime="2024-06-23T13:26:24.000Z" title="发表于 2024-06-23 13:26:24">2024-06-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ac8590ca.html" title="go 语言速成"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/5370198c46b7e6193aad423d755464fd5aa83820_raw.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="go 语言速成"></a><div class="content"><a class="title" href="/posts/ac8590ca.html" title="go 语言速成">go 语言速成</a><time datetime="2024-01-16T13:38:42.000Z" title="发表于 2024-01-16 13:38:42">2024-01-16</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/apprehen" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/apprehen" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/apprehen" title="facebook"><i class="anzhiyufont anzhiyu-icon-facebook1"></i></a><a class="deal_link" href="/atom.xml" title="RSS"><i class="anzhiyufont anzhiyu-icon-rss"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0,500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/yueyun.jpg" size="50px"><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/apprehen" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/apprehen" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/apprehen" title="抖音"><i class="anzhiyufont anzhiyu-icon-tiktok"></i></a><a class="deal_link" href="/copyright" title="CC"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i></a></div><div class="copyright">&copy;2023 - 2024 By 月晕</div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">14</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>留言</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size:.9em"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size:.9em"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size:.9em"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/resume/"><i class="anzhiyufont anzhiyu-icon-book faa-tada" style="font-size:.9em"></i><span> 简历</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size:.9em"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Clash/" style="font-size:.88rem">Clash<sup>1</sup></a><a href="/tags/Git/" style="font-size:.88rem">Git<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size:.88rem">JavaScript<sup>10</sup></a><a href="/tags/Linux/" style="font-size:.88rem">Linux<sup>2</sup></a><a href="/tags/NestJS/" style="font-size:.88rem">NestJS<sup>1</sup></a><a href="/tags/Nginx/" style="font-size:.88rem">Nginx<sup>1</sup></a><a href="/tags/PM2/" style="font-size:.88rem">PM2<sup>1</sup></a><a href="/tags/Python/" style="font-size:.88rem">Python<sup>1</sup></a><a href="/tags/React/" style="font-size:.88rem">React<sup>4</sup></a><a href="/tags/React-Native/" style="font-size:.88rem">React Native<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size:.88rem">TypeScript<sup>2</sup></a><a href="/tags/Vite/" style="font-size:.88rem">Vite<sup>1</sup></a><a href="/tags/Vue/" style="font-size:.88rem">Vue<sup>2</sup></a><a href="/tags/go/" style="font-size:.88rem">go<sup>1</sup></a><a href="/tags/leetcode/" style="font-size:.88rem">leetcode<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size:.88rem">代理<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size:.88rem;font-weight:500;color:var(--anzhiyu-lighttext)">前端<sup>14</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" style="font-size:.88rem">前端框架<sup>2</sup></a><a href="/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/" style="font-size:.88rem">反向代理<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size:.88rem">后端<sup>2</sup></a><a href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size:.88rem">工程化<sup>1</sup></a><a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size:.88rem">性能优化<sup>1</sup></a><a href="/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/" style="font-size:.88rem">打包工具<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size:.88rem">数据结构<sup>2</sup></a><a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/" style="font-size:.88rem">浏览器原理<sup>1</sup></a><a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size:.88rem">源码分析<sup>2</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size:.88rem">爬虫<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size:.88rem">算法<sup>2</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" style="font-size:.88rem">计算机<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size:.88rem;font-weight:500;color:var(--anzhiyu-lighttext)">计算机基础<sup>3</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size:.88rem">计算机操作系统<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size:.88rem">计算机网络<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size:.88rem">面试<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size:.88rem">面试题<sup>1</sup></a></div></div><hr></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size:1rem"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display:none"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://chat.yueyun.site',
      region: 'ap-hangzhou',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.21/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://chat.yueyun.site',
      region: 'ap-hangzhou',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: true,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', 'G-W3DLGJMJDY', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginModelPath:"assets/",model:{jsonPath:"/live2dw/assets/unitychan.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html>