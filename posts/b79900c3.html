<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>JavaScript语言学习 | 月晕</title><meta name="keywords" content="Javascript,编程语言,学习记录"><meta name="author" content="月晕"><meta name="copyright" content="月晕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="JavaScript语言学习"><meta name="application-name" content="JavaScript语言学习"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="JavaScript语言学习"><meta property="og:url" content="https://blog.yueyun.site/posts/b79900c3.html"><meta property="og:site_name" content="月晕"><meta property="og:description" content="JavaScript语言学习、使用过程的学习记录"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/vscodebg.jpg"><meta property="article:author" content="月晕"><meta property="article:tag" content="JS,前端,前端开发,TS,TypeScript,Node,Node.js,Nodejs,Node,后端"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/vscodebg.jpg"><meta name="description" content="JavaScript语言学习、使用过程的学习记录"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.yueyun.site/posts/b79900c3"><link rel="preconnect" href="//cdn.cbd.int"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><meta name="google-site-verification" content="QmqYgcPLCjEZmEbdJVKduTaxnvd3OFJRyp3BLB2f0VQ"><meta name="baidu-site-verification" content="codeva-XPqAkKFOID"><meta name="msvalidate.01" content="xxx"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload='this.media="all"'><script async src="https://www.googletagmanager.com/gtag/js?id=G-W3DLGJMJDY"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-W3DLGJMJDY")</script><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"T^T","backTitle":"Ciallo~"},
  LA51: {"enable":true,"ck":"3GbfdCFGvNdWoQg1","LingQueMonitorID":"3GbfdCFGvNdWoQg1"},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://chat.yueyun.site',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🖥️ JavaScript爱好者","🔍 前沿技术追随者","🩵 吃饭睡觉看动漫","🔨 前端后端一把梭","🤓 玉玉郁郁第一名","🧟 间歇性发奋图强","😵 持续性混吃等死","🥰 欢迎找我来聊天"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 月晕","link":"链接: ","source":"来源: 月晕","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={configTitle:"月晕",title:"JavaScript语言学习",postAI:"",pageFillDescription:"JAVASCRIPT 简介, 浏览器中的 JavaScript 能做什么？, JavaScript 的上层语言, 基础知识, JavaScript 中的数据类型, Number, String, 字符串中的方法, 常用, 不常用, Boolean(逻辑类型), 布尔转换时, 逻辑运算, 或运算(||), 与运算(ampamp), 非运算(!), 值比较, 严格相等, null和undefined进行比较, ?和??运算符, Null, Undefined, Symbol, 隐藏属性, 对象字面量中的 symbol, Symbol 会在 for in 中跳过, 全局 Symbol, Symbol.keyFor, BigInt, Object, Object 表示, Object 的引用和复制, Object 中的 this, 方法中的this, 箭头函数没有自己的this, 可选链？, Javascript 中的方法, 原始类型的方法, 数组中的方法, Iterable object(可迭代对象), Symbol.iterator, 字符串迭代, 显示调用迭代器, Array.from, Map 和 Set(映射和集合), Map, Map 迭代, Map 和对象的转换, Set, Set 迭代(iteration), WeakMap 和 WeakSet, WeakMap, WeakSet, 解构赋值, 数组解构, 对象解构, 嵌套解构, 智能函数参数, JSON 方法 toJSON, JSON.stringify, JSON.parse, 规范和调试, 高级内容, 函数, 递归, 执行上下文和堆栈, Rest 参数和 Spread 语法, 变量作用域和闭包, 代码块, 嵌套函数, 词法环境, 垃圾回收, 全局对象和函数对象, 全局对象, 函数对象, 命名函数的表达式, 调度：setTimeout 和 setInterval, 装饰器模式和转发：Callx2Fapply, 透明缓存, function.call 设定上下文, 传递多个参数, function.apply, 装饰器和属性函数, 函数绑定, 箭头函数, 对象, 属性标志和属性描述符, 属性标志, 设定一个全局的密封对象, 对象属性配置, getter 和 setter, 访问器描述符, 原型, Prototype, F.prototype, 默认的 F.prototype 构造器属性, 原生的原型, Object.prototype, 其他内建原型, 基本数据类型, 更改原生原型, 类, class 语法, 错误处理, try catch, Error对象, 抛出自定义的Error, 再次抛出(Rethrowing), try…catch…finally, 自定义Error扩展Error, 扩展Error, 深入继承, 迭代器, generator, generator函数, 模块导入导出, 异步, 浏览器中的 JS, NodeJS简介最初被创建的原因是作在浏览器环境中使得浏览器的交互效果更加生动这种编程语言写出来的程序称之为脚本即是可以被直接写在网页的中在页面加载的时候自动执行脚本被以纯文本的形式提供和执行它们不需要特殊的准备或编译即可运行发展到如今不仅能在浏览器中执行也可以在服务端执行甚至可以在任意存在引擎的设置中执行浏览器中嵌入了引擎有时也称作虚拟机比如等引擎是如何工作的引擎很复杂但是基本原理很简单引擎如果是浏览器则引擎被嵌入在其中读取解析脚本然后引擎将脚本转化编译为机器语言然后机器代码快速地执行引擎会对流程中的每个阶段都进行优化它甚至可以在编译的脚本运行时监视它分析流经该脚本的数据并根据获得的信息进一步优化机器代码浏览器中的能做什么现代的是一种安全的编程语言它不提供对内存或的底层访问因为它最初是为浏览器创建的不需要这些功能的能力很大程度上取决于它运行的环境例如支持允许读取写入任意文件执行网络请求等的函数的上层语言不同的人想要不同的功能的语法也不能满足所有人的需求这是正常的因为每个人的项目和需求都不一样因此最近出现了许多新语言这些语言在浏览器中执行之前都会被编译转化成现代化的工具使得编译速度非常快且透明实际上允许开发者使用另一种语言编写代码并会将其自动转换为此类语言的示例有是的一种语法糖它引入了更加简短的语法使我们可以编写更清晰简洁的代码专注于添加严格的数据类型以简化开发以更好地支持复杂系统的开发由微软开发也添加了数据类型但是以一种不同的方式由开发是一门独立的语言它拥有自己的引擎该引擎可以在非浏览器环境中运行例如手机应用它也可以被编译成由开发是一个到的转译器让我们可以在不使用的情况下以纯编写应用程序是一个现代简洁且安全的编程语言编写出的应用程序可以在浏览器和环境中运行这样的语言还有很多当然即使我们在使用此类编译语言我们也需要了解因为了解才能让我们真正明白我们在做什么基础知识中的数据类型原始数据类型类型代表整数和浮点数除了常规的数字还包括所谓的特殊数值也属于这种类型和表示数学概念上的无穷大代表一个计算错误它是一个不正确的或者一个未定义的数学操作所得到的结果是粘性的任何对的进一步数学运算都会返回数学运算是安全的脚本永远不会因为一个致命的错误死亡而停止最坏的情况下我们会得到的结果编写数字的更多方法可以使用这种语法糖使用来缩短十进制二进制八进制十六进制数字在中被广泛用于表示颜色编码字符以及其他许多东西所以自然地有一种较短的写方法然后是数字一样大小写没影响二进制形式的八进制形式的方法返回在给定进制数字系统中的字符串表示形式的范围可以从到默认情况下是舍入向下舍入向上舍入最近舍入移除小数点后的所有内容将数字舍入到小数点后位并以字符串形式返回结果在结尾添加了以达到小数点后五位我们可以使用一元加号或调用将其转换为数字例如不精确的计算在内部数字是以位格式如果一个如果一个数字真的很大则可能会溢出位存储变成一个特殊的数值一个数字以其二进制的形式存储在内存中一个和的序列但是在十进制数字系统中看起来很简单的这样的小数实际上在二进制形式中是无限循环小数使用二进制数字系统无法精确存储或就像没有办法将三分之一存储为十进制小数一样数字格式通过将数字舍入到最接近的可能数字来解决此问题这些舍入规则通常不允许我们看到极小的精度损失但是它确实存在最可靠的方法是借助方法对结果进行舍入和将其参数转换为数字然后测试它是否为将其参数转换为数字如果是常规数字而不是则返回因为是一个特殊的值因为是一个特殊的值和使用加号或的数字转换是严格的如果一个值不完全是一个数字就会失败但在现实生活中我们经常会有带有单位的值例如中的或它们可以从字符串中读取数字直到无法读取为止如果发生则返回收集到的数字函数返回一个整数而返回一个浮点数只有整数部分被返回了在第二个点出停止了读取某些情况下会返回当没有数字可读时会发生这种情况第一个符号停止了读取的第二个参数函数具有可选的第二个参数它指定了数字系统的基数因此还可以解析十六进制数字二进制数字等的字符串没有仍然有效其他数学函数返回一个从到的随机数不包括和从任意数量的参数中返回最大值和最小值返回的给定次幂取根号单引号双引号反引号字符串中的方法常用改变大小写获得子串已经不推荐使用方法了属于遗留特性建议使用参数可以为负数不破坏原来的串返回新的串替换是如果是则只会替换第一项分割字符形成数组如果为则会形成查找是否包含查找的字符串的第一次出现的索引如果没有找到则返回不常用逻辑类型布尔转换时空值即转换为其余为注意是噢逻辑运算或运算传统的比如中使用就不提了处理每一个操作数时都将其转化为布尔值如果结果是就停止计算返回这个操作数的初始值调用处理逻辑与运算在处理每一个操作数时都将其转化为布尔值如果结果是就停止计算并返回这个操作数的初始值非运算两个非运算有时候用来将某个值转化为布尔类型值比较严格相等普通的相等性检查存在一个问题会先转换类型才会进行比较严格相等运算符在进行比较时不会做任何的类型转换因为被比较值的数据类型不同和进行比较和运算符运算符计算条件结果如果结果为真则返回否则返回上面写法有点多余因为如果写成本来就会返回一个使用一系列问号运算符可以返回一个取决于多个条件的值有时候能代替但是可读性并不强赋值的时可以考虑使用做逻辑判断的时候更佳空值合并运算符对待和的方式类似所以当一个值既不是也不是时我们将其称为已定义的否则为未定义的结果是如果是已定义的则结果为如果不是已定义的则结果为匿名匿名未定义匿名已定义显示第一个已定义的值匿名与比较它们之间重要的区别是返回第一个真值返回第一个已定义的值换句话说无法区分空字符串和它们都一样假值如果其中任何一个是的第一个参数那么我们将得到第二个参数作为结果不过在实际中我们可能只想在变量的值为时使用默认值也就是说当该值确实未知或未被设置时特殊的值不属于任何一种类型构成了独立类型仅代表无空值未知等状态表示是未知的特殊值和一样自成类型如果一个变量已被声明但未被赋值那么它的值就是弹出通常使用将一个空或者未知的值写入变量中而则保留作为未进行初始化的事物的默认初始值值表示唯一的标识符可以使用来创建这种类型的值隐藏属性允许我们创建对象的隐藏属性代码的任何其他部分都不能意外访问或重写这些属性例如如果我们使用的是属于第三方代码的对象我们想要给它们添加一些标识符我们可以给它们使用键属于另一个代码我们可以使用作为键来访问数据我们的标识符和它们的标识符之间不会有冲突因为总是不同的即使它们有相同的名字对象字面量中的如果我们要在对象字面量中使用则需要使用方括号把它括起来而不是会在中跳过属性不参与循环没有使用任务直接访问也会忽略它们这是一般隐藏符号属性原则的一部分如果另一个脚本或库遍历我们的对象它不会意外地访问到符号属性相反会同时复制字符串和属性全局要从注册表中读取不存在则创建请使用该调用会检查全局注册表如果有一个描述为的则返回该否则将创建一个新并通过给定的将其存储在注册表中从全局注册表中读取如果该不存在则创建它再次读取可能是在代码中的另一个位置相同的通过获取通过获取是一种特殊的数字类型它提供了对任意长度整数的支持创建的方式有两种在一个整数字面量后面加或者调用函数该函数从字符串数字等中生成与相同基本类型和引用类型中栈和堆栈自动分配固定大小的内存空间并由系统自动释放栈数据结构遵从先进后出的原则堆堆内存动态分配内存内存大小不固定也不会自动释放堆数据结构是一种无序的树状结构满足键值对我们只用知道名就能通过查找到对应的比较经典的就是书架存书的例子我们知道书名就可以找到对应的书籍引用类型的引用和复制当一个对象变量被复制引用被复制而该对象自身并没有被复制月晕这里在堆内存中并没有新一份月晕而只是把的内容地址指向的地址指向堆内存中的同一份非原始数据类型表示构造函数的语法字面量的语法这将提示有语法错误下面这样不会报错设置读取删除中的计算属性属性名是从变量中得到的如果的引用和复制对象与原始类型的根本区别之一是对象是通过引用存储和复制的而原始类型字符串数字布尔值等总是作为一个整体复制当一个对象变量被复制引用被复制而该对象自身并没有被复制复制引用克隆和合并拷贝一个对象变量会又创建一个对相同对象的引用复制一个对象那该怎么做呢最先想到的就是遍历一份月晕使用对象展开符来实现将和中的所有属性都拷贝到中现在如果被拷贝的属性的属性名已经存在那么它会被覆盖深层克隆到现在为止我们都假设的所有属性均为原始类型但属性可以是对其他对象的引用当数组中存在对象抑或是对象中存在对象就要使用深拷贝深拷贝可以使用序列化有优缺点来做或者是自己手写一个深拷贝函数库中的使用去拷贝中的即是函数的上下文出现的值取决于它出现的上下文函数类或全局函数写在对象中称之为对象的方法方法中的通常对象方法需要访问对象中存储的信息才能完成其工作会指向一个对象以函数形式调用时指向的是浏览器环境环境以方法的形式调用指向的是调用方法的对象指的是当前对象的值是在代码运行时计算出来的它取决于代码上下文在两个对象中使用相同的函数这两个调用有不同的值函数内部的是点符号前面的那个对象使用点符号或方括号语法来访问这个方法都没有关系箭头函数没有自己的箭头函数有些特别它们没有自己的如果我们在这样的函数中引用值取决于外部正常的函数可选链可选链是一种访问嵌套对象属性的安全的方式即使中间属性不存在也不会出现错误不存在属性问题如果我们有很多个对象其中存储了我们的用户数据我们大多数用户的地址都存储在中街道地址存储在中但有些用户没有提供这些信息在这种情况下当我们尝试获取而该用户恰好没提供地址信息我们则会收到一个错误一个没有属性的对象会把识别为尝试读取即是自然是会失败并返回一个错误在开发中我们可以使用特殊的方法调用例如以对象的形式获取一个网页元素如果没有这种对象则返回如果的结果为则会出现错误同样如果该元素不存在则访问的属性时会报错在某些情况下当元素的缺失是没问题的时候我们希望避免出现这种错误而是接受作为结果首先我们想到的肯定是可以用条件语句判断或者运算符来解决当层级多了之后显示会很臃肿而且不优雅即引入了可选链没有属性不报错如果没有符合的元素则为如果未声明变量那么会触发一个错误前的变量必须已声明例如或作为一个函数参数可选链仅适用于已声明的变量当然也存在和中的方法原始类型的方法比如下面的这样中实际发生的情况字符串是一个原始值因此在访问其属性时会创建一个包含字符串字面值的特殊对象并且具有可用的方法例如该方法运行并返回一个新的字符串由显示特殊对象被销毁只留下原始值所以原始类型可以提供方法但它们依然是轻量级的引擎高度优化了这个过程它甚至可能跳过创建额外的对象但是它仍然必须遵守规范并且表现得好像它创建了一样数字有其自己的方法例如将数字舍入到给定的精度数组中的方法但很多时候我们发现还需要有序集合里面的元素都是按顺序排列的例如我们可能需要存储一些列表比如用户商品以及元素等这时一个特殊的数据结构数组就派上用场了它能存储有序的集合从的数据类型本质上面来说数组属于是一种特殊的对象添加删除元素向尾端添加元素从尾端提取一个元素从首端提取一个元素向首端添加元素从开始删除个元素并插入创建一个新数组将从索引到索引但不包括的元素复制进去返回一个新数组复制当前数组的所有元素并向其中添加如果中的任意一项是一个数组那么就取其元素搜索元素从索引开始搜索搜索到则返回该项的索引否则返回如果数组有则返回否则返回通过过滤元素返回使返回的第一个值所有值和类似但返回索引而不是值遍历元素对每个元素都调用不返回任何内容转换数组根据对每个元素调用的结果创建一个新数组对数组进行原位排序然后返回它原位反转数组然后返回它将字符串转换为数组并返回通过对每个元素调用计算数组上的单个值并在调用之间传递中间结果其他方法检查是否是一个数组如果是则返回否则返回请注意和方法修改的是数组本身杂检查数组从索引到用重复的填充数组将从位置到的所有元素复制到自身的位置覆盖现有元素从多维数组创建一个新的扁平数组可迭代对象可迭代对像是数组的泛化即是对象可以在循环中使用数组是可迭代的但不仅仅是数组很多其他内建对象也都是可迭代的例如字符串也是可迭代的如果从技术上讲对象不是数组而是表示某物的集合列表集合是一个能够遍历它的很好的语法因此让我们来看看如何使其发挥作用比如现在有一个对象代表了一个数字区间我们希望为了让对象可以迭代我们需要手动为其添加一个方法当循环启动时它会调用这个方法如果没找到就会报错这个方法必须返回一个迭代器一个有方法的对象从此开始仅适用于这个被返回的对象当循环希望取得下一个数值它就调用这个对象的方法方法返回的结果的格式必须是当时表示循环结束否则是下一个值月晕月晕无穷迭代器无穷迭代器也是可能的例如将设置为这时则成为了无穷迭代器或者我们可以创建一个可迭代对象它生成一个无穷伪随机数序列也是可能的没有什么限制它可以返回越来越多的值这是正常的当然迭代这种对象的循环将不会停止但是我们可以通过使用来停止它字符串迭代显示调用迭代器为了更深层地了解底层知识让我们来看看如何显式地使用迭代器我们将会采用与完全相同的方式遍历字符串但使用的是直接调用这段代码创建了一个字符串迭代器并手动从中获取值和做相同的事一个接一个地输出字符很少需要我们这样做但是比给了我们更多的控制权例如我们可以拆分迭代过程迭代一部分然后停止做一些其他处理然后再恢复迭代可迭代和类数组如上所述是实现了方法的对象是有索引和属性的对象所以它们看起来很像数组有一个全局方法可以接受一个可迭代或类数组的值并从中获取一个真正的数组然后我们就可以对其调用数组方法了接受上面的生成数组可选的第二个参数可以是一个函数该函数会在对象中的元素被添加到数组前被应用于每个元素此外允许我们为该函数设置求每个数的平方和映射和集合是一个带键的数据项集合就跟一样区别就是的允许是任意类型的方法和属性如下创建根据键存储值根据键来返回值如果中不存在对应的则返回如果存在则返回否则返回删除指定键的值清空返回当前元素个数可以使用对象来做键存储每个用户的来访次数是中的键使用对象作为键是最值得注意和重要的功能之一在中我们则无法使用对象作为键在中使用字符串作为键是可以的但我们无法使用另一个作为中的键调用都会返回本身即我们可以进行链式调用迭代如果要在里使用循环可以使用下面的方法遍历并返回一个包含所有键的可迭代对象遍历并返回一个包含所有值的可迭代对象遍历并返回一个包含所有实体的可迭代对象在默认情况下使用的就是这个遍历所有的键遍历所有的值遍历所有的实体与相同迭代的顺序与插入值的顺序相同与普通的不同保留了此顺序中有内建的对每个键值对运行函数和对象的转换从对象创建从创建对象现在当中含有对象作为时专成对象时的会变成是一个特殊的类型集合值的集合没有键它的每一个值只能出现一次它的主要方法如下创建一个如果提供了一个对象通常是数组将会从数组里面复制值到中添加一个值返回本身删除值如果在这个方法调用的时候存在则返回否则返回如果在中返回否则返回清空返回元素个数它的主要特点是重复使用同一个值调用并不会发生什么改变这就是里面的每一个值只出现一次的原因一些访客来访好几次只保留不重复的值然后和迭代我们可以使用或来遍历与相同和在垃圾回收中引擎在值可达和可使用时会将其保存在内存中该对象能访问是它的引用覆盖该对象将会被从内存中清除通常当对象数组之类的数据结构在内存中时它们的子元素如对象的属性数组的元素都是认为可达的例如如果把一个对象放入到数组中那么只要这个数组存在那么这个对象也就存在即使没有其他对该对象的引用覆盖前面由所引用的那个对象被存储在了中所以它不会被垃圾回收机制回收我们可以通过获取到它所以当我们使用对象作为的键的时如果存在那么对象就会一直存在占用内存不会被垃圾回收在这方面有着根本上的不同它不会阻止垃圾回收机制对作为键的对象的回收和的第一个不同点就是的键必须是对象不能是原始值正常工作以对象作为键不能使用字符串作为键因为不是一个对象现在如果我们在中使用一个对象作为键并且没有其他对这个对象的引用该对象将会被从内存和中自动清除与常规的相比如果仅仅是作为的键而存在它将会被从和内存中自动删除不支持迭代以及和方法所以没有办法获取的所有键或值只有以下的方法的表现类似与类似但是我们只能向添加对象而不能是原始值对象只有在其它某个些地方能被访问的时候才能留在中跟一样支持和方法但不支持和并且不可迭代变弱的同时它也可以作为额外的存储空间但并非针对任意数据而是针对是否的事实的元素可能代表着有关该对象的某些信息例如我们可以将用户添加到中以追踪访问过我们网站的用户访问了我们然后是再次访问现在有两个用户了检查是否来访过检查是否来访过将被自动清理即自动清除其中已失效的值解构赋值中最常用的数据结构是和解构赋值是一种特殊的语法将数组或对象拆包到一系列的变量中数组解构解构并没有破坏只是方便简单的赋值有想忽略的元素等号的右侧可以是任何可迭代的对象交换变量值的技巧让我们来交换变量的值使得成功交换其余的通常如果数组比左边的列表长那么其余的数组项会被省略如果我们还想收集其余的数组项我们可以使用三个点来再加一个参数以获取其余数组项就是剩下元素的数组集合我们也能使用去快速浅拷贝或者赋值默认值而不是对象解构解构赋值同样适用于对象基本情况是属性和值被赋给了对应的变量变量的顺序并不重要可以取别名映射也可以默认赋值也可以使用去解构注意使用声明代码块嵌套解构建议不要使用捏会让简单的变得很烦智能函数参数有这样的场景一个函数需要接受很多参数而且大部分参数都是可选的下面是很糟糕的写法在实际开发中记忆如此多的参数的位置是一个很大的负担通常集成开发环境会尽力帮助我们特别是当代码有良好的文档注释的时候但是另一个问题就是在大部分的参数只需采用默认值的情况下调用这个函数时会需要写大量的在采用默认值就可以的位置设置这太难看了而且当我们处理更多参数的时候可读性会变得很差解构赋值可以解决这些问题我们可以用一个对象来传递所有参数而函数负责把这个对象解构成各个参数我们传递一个对象给函数然后函数马上把对象解构成变量提取于使用默认值我们也可以使用带有嵌套对象和冒号映射的更加复杂的解构完整语法和解构赋值是一样的我们可以通过指定空对象为整个参数对象的默认值来解决这个问题方法的一些数据结构是属于独有的当传输网络数据或者在日志输出的时候需要传输数据是表示值和对象的通用格式在标准中有对其的描述最初它是为而创建的但许多其他编程语言也有用于处理它的库因此当客户端使用而服务器端是使用等语言编写的时使用可以很容易地进行数据交换提供了如下方法将对象转换成将转换成对象编码的对象方法接受对象并将其转换成字符串得到的字符串是一个被称之为编码或序列化或字符串化或编组化的对象也可以应用于原始数据类型支持的数据类型是语言无关的纯数据规范因此一些特定于的对象属性会被跳过即函数属性方法类型的键和值存储的属性支持嵌套对象转换但是不能循环引用的完整语法是要编码的值要编码属性数组活映射函数用于美化输出的空格数引用了引用了要解码字符串需要使用方法要解析的字符串可选的函数将为每个键值对调用此函数字符串化数组反序列化的时候如果遇到特殊对象会调用函数现在正常运行了总结是一种数据格式具有自己的独立标准和大多数编程语言的库支持和提供序列化成的方法和解析的方法这两种方法都支持用于智能读写的转换函数如果一个对象具有那么它会被调用规范和调试高级内容函数递归在函数解决任务时调用了自身就是所谓的递归比如想在要完成一个函数可以计算的次方有两种解法迭代思路使用循环递归思路简化任务调用自身当被调用时执行分为下面两个分支当时叫做基础递归因为会产生明显的结果可以使用表示这就递归步骤将人物转化为更简单的行为和更简单的同类任务调用带有更小的的运算接下来的步骤将其进一步简化直到达到递归将函数调用简化成为一个更简单的函数调用然后在将其简化为一个更加简单的函数以此类推直到结果变得显而易见最大的嵌套调用次数包括首次被称为递归深度在上面这个例子正好为执行上下文和堆栈递归调用的工作函数底层的工作原理有关正在运行的函数的执行过程的相关信息被存储在其执行上下文中执行上下文是一个内部据结构他包含有关函数执行时的详细细节当前控制流所在的位置作用域链每个执行上下文都有一个与之相关联的作用域链作用域链是一个对象列表它定义了变量和函数的查找规则决定了代码在哪些区域是有效的当代码在一个执行上下文中查找变量时如果在当前上下文的变量对象中找不到它会沿着作用域链向上查找当前的变量包含函数的参数局部变量函数声明变量声明在函数执行的初始阶段函数所有的参数值函数内部的函数声明以及变量声明都会被添加到变量对象中的值表示调用上下文依赖于函数的调用方式全局执行上下文函数执行上下文如何被调用及内部的一些细节一个函数调用仅具有一个与其关联的执行上下文当一个函数进行嵌套调用的时候将发生当前函数被暂停与它关联的执行上下文被一个叫做执行上下文堆栈而特殊数据结构保存执行嵌套调用嵌套调用结束后从堆栈中恢复之前的执行上下文并从停止的位置恢复外部函数比如现在来分析上面这个例子使用抽象的来表示一下执行流程在调用而开始执行上下文会储存变量执行流程在函数而第一行我们将其定义为当函数开始执行的时进入第二条分支变量相同但是位置改变了执行到计算需要带入新的参数新的子调用为了执行嵌套调用会在执行上下文堆栈中记住当前的执行上下文这里我们调用相同的函数但这绝对没问题所有函数的处理都是一样的当前上下文被记录在堆栈的顶部为子调用创建新的上下文当子调用结束后前一个上下文被从堆栈中弹出并继续执行下面是进入子调用时的上下文堆栈当我们完成了子调用后很容易恢复一个上下文因为它既保留了变量也保留了当时代码的确切位置执行重复过程现在的调用堆栈出口即使调用堆栈出栈口递归可以更加简单明了优雅的描述出一段代码的逻辑虽然性能上可能不如循环但是在一些复杂的数据结构下面使用递归往往更好比如树链表等参数和语法简单来说就是变量作用域和闭包是非常面向对象和函数的语言会有很大的自由度和写法我们可以随时创建函数可以将函数作为参数传递在任意不同的代码位置调用可以访问外部的环境代码块如果在内声明变量那么这个变量并不会向外传递只能在内部访问该代码块内可见在中中声明的变量也仅在内部可见嵌套函数如果一个函数在另外一个函数中创建的被称为高级函数或者嵌套函数辅助嵌套函数使用如下词法环境变量在中每个运行的函数代码块以及整个脚本都有一个被称为词法环境的内部的关联对象该词法环境对象由两部分组成环境记录一个存储所有局部变量作为其属性包括一些其他的信息例如的值的对象对外部词法环境的引用与外部代码相关联一个变量只是环境记录这个特殊的内部对象的一个属性获取或修改变量一味着获取或修改词法环境的一个属性获取或修改变量意味着获取或修改词法环境的一个属性比如下面的一个最简单的例子这个就是所谓的与整个脚本相关联的全局词法环境在上面的过程中矩形区域表示环境记录变量存储箭头表示外部引用全局词法环境没有外部引用所以箭头指向了随着代码的开始继续的执行词法环境发生了变化上面的图片中右侧演示了执行过程中词法环境的变化当脚本开始运行词法环境先填充了所有声明的变量在最初它们处于未初始化的状态这是一种特殊的内部状态这意味着引擎知道这个变量存在但是在声明之前不能引用它几乎就跟不存在一样定义出现尚未被赋值因此值是被赋予了一个值被修改实际上执行的过程是变量是特殊内部对象的属性与当前正在执行的代码块函数脚本有关操作变量实际上是操作该对象的属性词法环境是一个规范的对象是存在于语言规范的理论层面用于描述是如何工作的我们无法在代码块中获取该对象并直接进行操作函数声明一个函数其实就是一个值就像变量一样不同就在于如果是函数声明的初始化会被立刻完成当创建了一个词法环境时函数会立即变成即用型函数并不像那样到声明处才可以去使用例如下面是添加一个函数时全局词法环境的初始状态这种行为仅适用于函数声明而不适用于匿名函数的声明比如或者内部和外部的词法环境当一个函数运行时在调用刚开始会自动创建一个新的词法环境以存储这个调用的局部变量和参数例如对于的执行流程如下在函数调用期间我们拥有两个词法环境内部一个用于函数调用和外部一个全局内部词法环境与的当前执行相对应它具有单独的属性函数的参数调用的是所以的值为外部词法环境是全局词法环境它具有变量和函数本身内部词法环境引用了当代码要访问一个变量时首先会搜索内部词法环境然后搜索外部环境然后搜索更外部的环境以此类推直到全局词法环境返回函数比如下面的例子在每次调用的开始都会创建一个新的词法环境对象以存储该运行时的变量因此我们有两层嵌套的词法环境不一样的是在执行的过程中创建了一个仅占一行的嵌套函数我们并没有运行它只是创建了这么一个函数所有的函数在创建时都会记住它的词法环境从技术上来说所有的函数都有名为的隐藏属性该属性保存了对创建对象该函数的词法环境的应引用因此有对词法环境的引用这就是函数记住它创建于何处的方式与调用无关引用在函数创建时被设置并永久保存稍后调用时会自动创建一个新的词法环境并且其外部词法环境引用获取于现在当中的代码查找变量时它首先搜索自己的词法环境为空因为那里没有局部变量然后是外部的词法环境并且在哪里找到就在哪里修改在变量所在的词法环境中更新变量如果我们调用多次变量将在同一位置增加到等闭包是一个编程术语是指一个函数可以记住其他外部变量并可以访问这些变量在某些编程语言中会有不同的差异但在中所有的函数天生都是闭包的即中的函数会自动通过隐藏属性记住创建它们的位置所以它们都可以访问外部变量垃圾回收通常函数调用完成后会将词法环境和其中的所有变量从内存中删除因为现在没有任何对它们的引用了与中的任何其他对象一样词法环境仅在可达时才会被保留在内存中但是如果有一个嵌套函数在函数结束后的语句任然可达则它将具有引用词法环境的属性存储了对相应调用的词法环境的引用如果多次调用并且返回的函数被保存那么所有相应的词法环境对象也会保留在内存中下面代码中有三个这样的函数数组中的个函数每个都与来自对应的的词法环境相关联当词法环境对象变得不可达时它就会死去就像其他任何对象一样换句话说它仅在至少有一个嵌套函数引用它时才存在在下面的代码中嵌套函数被删除后其封闭的词法环境以及其中的也会被从内存中删除当函数存在时该值会被保留在内存中现在内存被清理了全局对象和函数对象全局对象全局对象提供可以在任何地方都使用的变量和函数默认的情况下这些全局变量内建于语言或环境中在浏览器环境中全局对象是对于运行时环境全局对象是在最新的规定中被作为全局对象的标准名称加入到了中所有环境都应该支持该名称所有主流浏览器都支持它全局对象的所有属性都可以直接被访问等同于在浏览器中使用声明的全局函数和变量都会成为全局属性请不要这样去使用这种行为是出于兼容性而存在的现代脚本使用所以不会发生这种事情如果我们使用就不会发生这种情况如果一个值非常重要你想让它在全局的范围中将当前用户信息全局化以允许所有脚本访问它代码中的另一个位置或者如果我们有一个名为的局部变量从显式地获取它这是安全的函数对象在中函数也是一个值函数值的类型是可以把函数理解成为一个可调用的行为对象同样可以传递属性和引用传递比如属性有名字生效了规范中把这种特性叫做上下文命名如果函数自己没有提供那么在赋值中会根据上下文来推测一个函数是在数组中创建的空字符串引擎无法设置正确的名字所以没有值属性属性有时在操作其它函数的函数中用于做内省运行时检查对于肯定的回答两个都会被调用对于否定的回答只有第二个被调用自定义属性我们可以在函数中添加属性记录被调用了多少次初始值属性并不是变量被赋值给函数的属性比如不会在函数内定义一个局部变量换句话说属性和变量是毫不相关的两个东西函数属性有时会用来替代闭包如下面修改之前写过的闭包即被直接存储在函数里而不是它外部的词法环境这种写法一般不太常见因为可以在外部去修改它的属性从而导致代码很混乱可以任意的修改命名函数的表达式命名函数表达式指带有名字的函数表达式术语它仍然是一个函数表达式在后面加一个名字没有使它成为一个函数声明因为它仍然是作为赋值表达式中的一部分被创建的添加这个名字当然也没有打破任何东西函数依然可以通过来调用关于添加的两个特殊的地方允许函数在内部引用自己它在函数外是引用不到的使用再次调用函数自身但这不工作在函数外不可见同样不适用去写递归因为很容易就被外部污染嵌套调用不再有效当我们需要一个可靠的内部名时这就成为了你把函数声明重写成函数表达式的理由了调度和当我们并不想立刻执行一个函数而是等待特定一段时间之后再执行这就是所谓的计划调用目前的实现方式有下面两种方式实现允许我们将函数推迟到一段时间间隔之后再执行允许我们重复运行一个函数从一段时间间隔之后开始运行之后以该时间间隔连续重复运行该函数期望得到一个对函数的引用来取消调度在调用时会返回一个定时器标识符在我们的例子中是我们可以使用它来取消执行方法和的语法相同不过与只执行一次不同是每间隔给定的时间周期性执行装饰器模式和转发在处理函数时提供了很高的灵活性它们可以被传递用作对象下面将介绍它们之间的转发和装饰透明缓存假设现在我们有一个重负载的函数但是他纯函数给定相同的参数总是会返回相同的结果如果这个函数使用频繁我们希望能记住这个缓存能记住因此避免花费额外的时间如下从缓存中读取结果将结果记录下来被缓存下并返回结果返回缓存记录的结果在上面的例子中是一个装饰器这样我们可以为任何函数调用它将返回缓存包装器这样别的函数需要这种特性就可以直接复用还可以将缓存与主代码分开变得更加简单的结果是一个包装器将的调用包装到缓存逻辑中从外部代码来看包装的函数执行的仍然是与之前相同的操作它只是在其行为上添加了缓存功能使用分离的而不是改变本身的代码有几个好处是可重用的我们可以将它应用于另一个函数缓存逻辑是独立的它没有增加本身的复杂性如果有的话如果需要我们可以组合多个装饰器其他装饰器将遵循同样的逻辑设定上下文但是如果我们在对象中这样使用的话呢如下原始方法有效现在对其进行缓存报错错误在于试图访问失败了原因是包装器将原始函数调用为行中的但是这样调用得到的这是因为包装器将调用传递给原始方法但是并没有上下文的使用内建的函数方法允许调用一个显示设置的函数例如在下面的代码中我们在不同对象的上下文中调用运行并提供了然后下一行设置使用将不同的对象传递为在我们的例子中我们可以在包装器中使用将上下文传递给原始函数现在一切工作正常的传递过程在经过装饰之后现在是包装器因此当执行时包装器将作为参数并且它是点符号之前的对象在包装器内部假设结果尚未缓存将当前的和当前的参数传递给原始方法传递多个参数记住参数组合的结果实现一个新的类似于的更通用的并且允许多个键的数据结构使用嵌套的去实现比如来获取将两个值合并成一个多为装饰器添加一个函数现在以第三种方法写出带多个参数现在这个包装器可以处理任意数量的参数了在行中它调用来从创建一个单独的键这里我们使用一个简单的连接函数将参数转换为键更复杂的情况可能需要其他哈希函数然后行使用将包装器获得的上下文和所有参数不仅仅是第一个参数传递给原始函数和的用法类似区别就是希望接受的是一个参数列表而不是多个参数装饰器和属性函数通常用装饰的函数替换一个函数或一个方法是安全的除了一件小东西如果原始函数有属性例如或其他则装饰后的函数将不再提供这些属性因为这是装饰器因此如果有人使用它们那么就需要小心例如在上面的示例中如果函数具有任何属性而则是一个没有这些属性的包装器一些包装器可能会提供自己的属性例如装饰器会计算一个函数被调用了多少次以及花费了多少时间并通过包装器属性公开这些信息存在一种创建装饰器的方法该装饰器可保留对函数属性的访问权限但这需要使用特殊的对象来包装函数函数绑定在将对象的方法作为回调进行传递例如传递给的时候会存在一个常见的问题即是丢失比如下面的情况输出这是因为获取到了函数但是他和对象分开了丢失了解决办法用函数包括执行这样即可以成功但是这样又会存在可能在定时器还在计时的过程中如果函数发生变化那么又会调用到错误的对象解决办法的结果是一个特殊的类似于函数的外来对象它可以像函数一样被调用并且透明地将调用传递给并设定如下上面例子的解法箭头函数箭头函数不仅仅是编写简介代码的捷径还具有非常特殊有用的特性充满了我们需要编写在其他地方执行的小函数的情况例如每个元素都执行由内建调度器执行的精髓在于创建一个函数并将其传递到某个地方在这样的函数中我们通常不想离开当前上下文这就是箭头函数的应用场景箭头函数没有这里中使用了箭头函数其中的其实和外部方法完全一样如果我们使用正常的函数则会出现错误报错是因为运行它里面的这个函数但是这个函数的为默认值因此就出现了尝试访问的情况但箭头函数就没事因为它们没有不能对箭头函数进行操作不具有自然就意味着箭头函数不能作为构造器箭头函数没有箭头函数也没有变量对象属性标志和属性描述符我们知道对象可以存储属性到目前为止属性对我们来说只是一个简单的键值对但对象属性实际上是更灵活且更强大的东西属性标志对象属性是除了还有三个特殊的特性即标志如果是则值可以被修改否则它是只可读的如果是则值可以被枚举否则不会被列出如果为则此属性可以被删除这些特性也可以被修改否则不可以方法允许查询有关属性的完整信息属性描述符为了修改标志我们可以使用使用的语法是要应用描述符的对象及其属性要应用的属性描述符对象如果该属性存在会更新其标志否则它会使用给定的值和标志创建属性在这种情况下如果没有提供标志则会假定它是将它与上面的以常用方式创建的进行比较现在所有标志都为如果这不是我们想要的那么我们最好在中将它们设置为可以设置属性为只读不可枚举不可配置设定一个全局的密封对象禁止向对象添加新属性禁止添加删除属性为所有现有的属性设置禁止添加删除更改属性为所有现有的属性设置还有针对它们的测试如果添加属性被禁止则返回否则返回如果添加删除属性被禁止并且所有现有的属性都具有则返回如果添加删除更改属性被禁止并且所有当前属性都是则返回对象属性配置和有两种类型的对象属性第一种是数据属性我们已经知道如何使用它们了到目前为止我们使用过的所有属性都是数据属性第二种类型的属性是新东西它是访问器属性它们本质上是用于获取和设置值的函数但从外部代码来看就像常规属性访问器属性由和方法表示在对象字面量中它们用和表示当读取时起作用当执行操作时起作用当读取时起作用当被赋值时起作用例如我们有一个具有和属性的对象从外表看访问器属性看起来就像一个普通属性这就是访问器属性的设计思想我们不以函数的方式调用我们正常读取它在幕后运行让我们通过为添加一个来修改它将以给定值执行访问器描述符访问器属性的描述符与数据属性的不同对于访问器属性没有和但是有和函数所以访问器描述符可能有一个没有参数的函数在读取属性时工作带有一个参数的函数当属性被设置时调用与数据属性的相同与数据属性的相同例如上面的例子使用创建一个访问器请注意一个属性要么是访问器具有方法要么是数据属性具有但不能两者都是如果我们试图在同一个描述符中同时提供和则会出现错误原型在编程中我们经常会想获取并扩展一些东西比如我们有一个对象及其属性和方法并希望将和作为基于稍加修改的变体我们想重用中的内容而不是复制重新实现它的方法而只是在其之上构建一个新的对象原型继承这个语言特性能够帮助我们实现这一需求在中对象有特殊的隐藏属性他们要么是要么就是在另一个对象中的引用该对象称之为原型我们会从逐步的向上寻找即原型继承属性是内部的而且是隐藏的但是这儿有很多设置它的方式其中之一就是使用特殊的名字就像这样现在这两个属性我们都能在中找到原型链可能会很长是通过原型链获得的从现在如果我们从中读取一些它不存在的内容会先在中查找然后在中查找这里只有两个限制引用不能形成闭环如果我们试图给赋值但会导致引用形成闭环时会抛出错误的值可以是对象也可以是而其他的类型都会被忽略当然这可能很显而易见但是仍然要强调只能有一个一个对象不能从其他两个对象获得继承注意是的因历史原因而留下来的与内部的不一样是的属性有点过时了它的存在是出于历史的原因现代编程语言建议我们应该使用函数来取代去原型原型仅用于读取属性上赋值操作是由函数去处理而因此写入类属性实际上就是与调用函数相同的内容被修改了的内容被保护了只会遍历当前的属性的值会遍历当前的和继承的值如果要判断是否是自己的可以使用总结在中所有的对象都有一个隐藏的属性它要么是另一个对象要么就是我们可以使用访问它历史遗留下来的这儿还有其他方法很快我们就会讲到通过引用的对象被称为原型如果我们想要读取的一个属性或者调用一个方法并且它不存在那么就会尝试在原型中查找它写删除操作直接在对象上进行它们不使用原型假设它是数据属性不是如果我们调用而且是从原型中获取的仍然会引用因此方法始终与当前对象一起使用即使方法是继承的循环在其自身和继承的属性上进行迭代所有其他的键值获取方法仅对对象本身起作用我们可以通过这样的构造函数来创建一个新对象如果是一个对象操作符会使用它作为新对象设置这里的指的是的一个的普通常规属性如下设置的字面意思是当创建了一个时把它的赋值为在上图中是一个水平箭头表示一个常规属性是垂直的表示继承自仅用在被调用时使用它为新对象的赋值默认的构造器属性每个函数都有属性即使我们没有提供它默认的是一个只有属性的对象属性指向函数自身默认的默认默认继承自属性不要把它与弄混了在被调用时为新对象的赋值的值要么是一个对象要么就是其他值都不起作用属性仅当设置在一个构造函数上并通过调用时才具有这种特殊的影响原生的原型属性在中广泛的使用所有而内建构造函数都使用到了它内建的生成了字符串和是一个意思其中就是一个内建的对象构造函数其自身的指向一个带有和其他方法的一个巨大的对象其他内建原型例如及其他都在上挂载了方法当我们创建一个数组在内部会默认使用构造器因此变成了这个数组的并为这个数组提供数组的操作方法这样内存的存储效率是很高的所有的内建原型顶端都是这就是为什么有人说一切都从对象继承而来经过下面验证它继承自接下来继承自原型链的顶端为一些方法在原型上可能会发生重叠例如有自己的方法来列举出来数组的所有元素并用逗号分隔每一个元素基本数据类型最复杂的事情发生在字符串数字和布尔值上正如我们记忆中的那样它们并不是对象但是如果我们试图访问它们的属性那么临时包装器对象将会通过内建的构造器和被创建它们提供给我们操作字符串数字和布尔值的方法然后消失这些对象对我们来说是无形地创建出来的大多数引擎都会对其进行优化但是规范中描述的就是通过这种方式这些对象的方法也驻留在它们的中可以通过和进行获取值和没有对象包装器并且它们也没有相应的原型更改原生原型在开发的过程中我们可能会想要一些新的内建方法并且想把它们添加到原生原型中但这通常是一个很不好的想法原型是全局的所以很容易造成冲突如果有两个库都添加了方法那么其中的一个方法将被另一个覆盖所以通常来说修改原生原型被认为是一个很不好的想法类语法通过来创建具有上述方法的新对象会自动调用方法因此我们可以在中初始化对象在中类其实是一种函数在中增加了类而关键字是一种新的语法糖放其更加方便直观的创建想要的类构造实际是完成了下面的事创建一个名为的函数该函数为类声明的结果该函数的代码来自于方法存储类中的方法例如中的如下面的代码解释是一个函数或者更确切地说是方法方法在中例如方法的代码在原型中实际上有两个方法错误处理通常我们在编写脚本的时候总是会遇到很多非预期的错误导致脚本停止执行有一种语法结构它使我们可以捕获错误因此脚本可以执行更合理的操作而不是死掉首先执行中的代码如果没有错误那么就跳过中的代码继续执行中的代码执行完毕如果出现错误那么中剩下的代码停止执行控制台执行中的代码中的代码将包含一个的对象执行完毕对象发生错误时会生成一个包含有关此详细信息的对象然后将该对象作为参数传递给对象也可以用其他参数名代替的名称例如一个未定义的变量则报错是关于的详细文字描述当前的单调栈用于调试抛出自定义的操作符操作符会生成一个对象技术上讲我们可以将任何东西用作对象甚至可以是一个原始类型数据例如数字或字符串但最好使用对象最好使用具有和属性的对象某种程度上保持与内建的兼容性中有很多内建的标准的构造器等我们也可以使用它们来创建对象或再次抛出不完整的数据数据不全没有预料之外的再次抛出结构可能还有一个代码子句尝试执行的代码处理总是会执行的代码自定义扩展当我们开发项目时经常需要我们自己定义类来反映任务中可能出错的特定任务对于网络操作中的我们需要对于数据库操作中的我们需要对于搜索操作的我们需要我们自定义的应该支持基本的的属性例如并且最好还有但是它们也可能会有其他属于它们自己的属性例如对象可能会有一个属性属性值可能为或等扩展如果我们需要使用去检查是否存在某个数据我们现在规定成类是内建的结构类似如下自身定义的内建的类的伪代码不同的内建类拥有不同的名字现在让我们从其中继承并尝试进行运行一个嵌套调用的列表每个调用都有对应的行号深入继承类是非常通用的很多东西都可能出错对象的属性可能缺失或者属性可能有格式错误让我们针对缺少属性的错误来制作一个更具体的类它将携带有关缺少的属性的相关信息这个新的类使用起来很简单我们只需要传递属性名人类可读的是由生成的是对的迭代器常规函数只会返回一个单一值或者不返回任何值而可以按需一个接一个地返回多个值它们可与完美配合使用从而可以轻松地创建数据流函数要创建一个我们需要一个特殊语法结构即所谓的函数与常规函数的行为不同在此类函数被调用时他不会运行其代码而是返回一个被称为的特殊对象来管理执行流程创建了一个到现在为止上段代码中的函数体代码并没有开始执行一个的主要方法就是当被调用时它会恢复运行执行直到最近的语句可以被省略默认为然后函数执行暂停并将产出的值返回到外部代码的结果始终是一个具有两个属性的对象产出的的值如果函数已执行完成则为否则为创建了一个创建了一个模块导入导出异步浏览器中的",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-01-17 11:24:35",postMainColor:""}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W3DLGJMJDY"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-W3DLGJMJDY")</script><meta name="generator" content="Hexo 7.0.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/yueyun.jpg"><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"><script async src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">月晕</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>留言</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size:.9em"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size:.9em"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size:.9em"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size:.9em"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><div class="nav-change" id="nav-darkmode"><a class="darkmode_switchbutton" title="显示模式切换" onclick="darkmo" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><input id="center-console" type="checkbox"><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url">编程语言</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/JavaScript/" tabindex="-1" itemprop="url"> <span><i class="anzhiyufont anzhiyu-icon-hashtag"></i>JavaScript</span></a></span></div></div><h1 class="post-title" itemprop="name headline">JavaScript语言学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="post-meta-icon anzhiyufont anzhiyu-icon-calendar-days"></i><span class="post-meta-label">发表于</span><time itemprop="dateCreated datePublished" datetime="2023-11-21T23:18:24.000Z" title="发表于 2023-11-21 23:18:24">2023-11-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">23.6k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>89分钟</span></span><span class="post-meta-separator"> </span><span class="post-meta-position" title="作者IP属地为杭州"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>杭州</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/b79900c3.html#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/vscodebg.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blog.yueyun.site/posts/b79900c3.html"><header><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url">编程语言</a><a href="/tags/JavaScript/" tabindex="-1" itemprop="url">JavaScript</a><h1 id="CrawlerTitle" itemprop="name headline">JavaScript语言学习</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">月晕</span><time itemprop="dateCreated datePublished" datetime="2023-11-21T23:18:24.000Z" title="undefined 2023-11-21 23:18:24">2023-11-21</time></header><h1 id="JAVASCRIPT-简介"><a href="#JAVASCRIPT-简介" class="headerlink" title="JAVASCRIPT 简介"></a>JAVASCRIPT 简介</h1><p>javascript 最初被创建的原因是作在浏览器环境中使得浏览器的交互效果更加生动</p><p>javascript 这种编程语言写出来的程序称之为<mark class="hl-label blue">脚本</mark> ，即是可以被直接写在网页的 HTML 中，在页面加载的时候自动执行。脚本被以纯文本的形式提供和执行。它们不需要特殊的准备或编译即可运行</p><p>发展到如今 JavaScript 不仅能在浏览器中执行，也可以在服务端执行，甚至可以在任意存在 Javascript 引擎的设置中执行</p><p>浏览器中嵌入了 JavaScript 引擎，有时也称作“JavaScript 虚拟机”。</p><p>比如：<strong>V8</strong>(<code>javascript engine</code>)、<strong>SpiderMonkey</strong> 等</p><div class="note orange anzhiyufont anzhiyu-icon-dengpao simple"><p><strong>引擎是如何工作的？</strong></p></div><blockquote><p>引擎很复杂，但是基本原理很简单。</p><ul><li>引擎（如果是浏览器，则引擎被嵌入在其中）读取（“解析”）脚本。</li><li>然后，引擎将脚本转化（“编译”）为机器语言。</li><li>然后，机器代码快速地执行。</li></ul><p>引擎会对流程中的每个阶段都进行优化。它甚至可以在编译的脚本运行时监视它，分析流经该脚本的数据，并根据获得的信息进一步优化机器代码。</p></blockquote><h2 id="浏览器中的-JavaScript-能做什么？"><a href="#浏览器中的-JavaScript-能做什么？" class="headerlink" title="浏览器中的 JavaScript 能做什么？"></a>浏览器中的 JavaScript 能做什么？</h2><p>现代的 JavaScript 是一种“安全的”编程语言。它不提供对内存或 CPU 的底层访问，因为它最初是为浏览器创建的，不需要这些功能。</p><p>JavaScript 的能力很大程度上取决于它运行的环境。例如，<a target="_blank" rel="noopener" href="https://wikipedia.org/wiki/Node.js">Node.js</a> 支持允许 JavaScript 读取&#x2F;写入任意文件，执行网络请求等的函数。</p><h2 id="JavaScript-的上层语言"><a href="#JavaScript-的上层语言" class="headerlink" title="JavaScript 的上层语言"></a>JavaScript 的上层语言</h2><p>不同的人想要不同的功能。JavaScript 的语法也不能满足所有人的需求。</p><p>这是正常的，因为每个人的项目和需求都不一样。</p><p>因此，最近出现了许多新语言，这些语言在浏览器中执行之前，都会被 <strong>编译</strong>（转化）成 JavaScript。</p><p>现代化的工具使得编译速度非常快且透明，实际上允许开发者使用另一种语言编写代码并会将其“自动转换”为 JavaScript。</p><p>此类语言的示例有：</p><ul><li><a target="_blank" rel="noopener" href="https://coffeescript.org/">CoffeeScript</a> 是 JavaScript 的一种语法糖。它引入了更加简短的语法，使我们可以编写更清晰简洁的代码。</li><li><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/">TypeScript</a> 专注于添加“严格的数据类型”以简化开发，以更好地支持复杂系统的开发。由微软开发。</li><li><a target="_blank" rel="noopener" href="https://flow.org/">Flow</a> 也添加了数据类型，但是以一种不同的方式。由 Facebook 开发。</li><li><a target="_blank" rel="noopener" href="https://www.dartlang.org/">Dart</a> 是一门独立的语言。它拥有自己的引擎，该引擎可以在非浏览器环境中运行（例如手机应用），它也可以被编译成 JavaScript。由 Google 开发。</li><li><a target="_blank" rel="noopener" href="https://brython.info/">Brython</a> 是一个 Python 到 JavaScript 的转译器，让我们可以在不使用 JavaScript 的情况下，以纯 Python 编写应用程序。</li><li><a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/js-overview.html">Kotlin</a> 是一个现代、简洁且安全的编程语言，编写出的应用程序可以在浏览器和 Node 环境中运行。</li></ul><p>这样的语言还有很多。当然，即使我们在使用此类编译语言，我们也需要了解 JavaScript。因为了解 JavaScript 才能让我们真正明白我们在做什么。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="JavaScript-中的数据类型"><a href="#JavaScript-中的数据类型" class="headerlink" title="JavaScript 中的数据类型"></a>JavaScript 中的数据类型</h2><p><strong>原始数据类型：</strong></p><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a><strong>Number</strong></h3><p>number 类型代表整数和浮点数<br>除了常规的数字，还包括所谓的“特殊数值（“special numeric values”）”也属于这种类型：<code>Infinity</code>、<code>-Infinity</code> 和 <code>NaN</code></p><ul><li><p><code>Infinity</code>表示数学概念上的无穷大 ∞ <code>console.log(1/0) || console.log(Infinity)</code></p></li><li><p><code>NaN</code>代表一个计算错误它是一个不正确的或者一个未定义的数学操作所得到的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;not a number&#x27;</span> / <span class="number">2</span>) <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure><p><code>NaN</code> 是粘性的。任何对 <code>NaN</code> 的进一步数学运算都会返回 <code>NaN</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="title class_">NaN</span> + <span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="number">3</span> * <span class="title class_">NaN</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;not a number&#x27;</span> / <span class="number">2</span> - <span class="number">1</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><div class="note orange anzhiyufont anzhiyu-icon-dengpao simple"><p><strong>数学运算是安全的</strong>,脚本永远不会因为一个致命的错误（“死亡”）而停止。最坏的情况下，我们会得到 <code>NaN</code> 的结果。</p></div></li></ul><p><strong>编写数字的更多方法</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> billion = <span class="number">1000000000</span></span><br><span class="line"><span class="comment">// 可以使用 _ 这种语法糖</span></span><br><span class="line">billio = <span class="number">1_000_000_000</span></span><br><span class="line"><span class="comment">// 使用 e 来缩短</span></span><br><span class="line">billio = <span class="number">1e9</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7.3e9</span>)</span><br><span class="line"><span class="keyword">let</span> msc = <span class="number">0.000001</span></span><br><span class="line">msc = <span class="number">1e-6</span></span><br></pre></td></tr></table></figure><p><strong>十进制、二进制、八进制</strong></p><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hexadecimal">十六进制</a> 数字在 JavaScript 中被广泛用于表示颜色，编码字符以及其他许多东西。所以自然地，有一种较短的写方法：<code>0x</code>，然后是数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0xff</span>) <span class="comment">// 255</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0xff</span>) <span class="comment">// 255（一样，大小写没影响）</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0b11111111</span> <span class="comment">// 二进制形式的 255</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0o377</span> <span class="comment">// 八进制形式的 255</span></span><br></pre></td></tr></table></figure><p><strong>toString(base)</strong></p><p>方法 <code>num.toString(base)</code> 返回在给定 <code>base</code> 进制数字系统中 <code>num</code> 的字符串表示形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">255</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(num.<span class="title function_">toString</span>(<span class="number">16</span>)) <span class="comment">// ff</span></span><br><span class="line"><span class="title function_">alert</span>(num.<span class="title function_">toString</span>(<span class="number">2</span>)) <span class="comment">// 11111111</span></span><br></pre></td></tr></table></figure><p><code>base</code> 的范围可以从 <code>2</code> 到 <code>36</code>。默认情况下是 <code>10</code>。</p><p><strong>舍入</strong></p><ul><li><p><strong><code>Math.floor</code></strong>: 向下舍入</p></li><li><p><strong><code>Math.ceil</code></strong>: 向上舍入</p></li><li><p><strong><code>Math.round</code></strong>: 最近舍入</p></li><li><p><strong><code>Math.trunc</code></strong>: 移除小数点后的所有内容</p></li><li><p><strong><code>toFixed(n)</code></strong>: 将数字舍入到小数点后 <code>n</code> 位，并以字符串形式返回结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">12.34</span></span><br><span class="line"><span class="title function_">alert</span>(num.<span class="title function_">toFixed</span>(<span class="number">1</span>)) <span class="comment">// &quot;12.3&quot;</span></span><br><span class="line">num = <span class="number">12.36</span></span><br><span class="line"><span class="title function_">alert</span>(num.<span class="title function_">toFixed</span>(<span class="number">1</span>)) <span class="comment">// &quot;12.4&quot;</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">12.34</span></span><br><span class="line"><span class="title function_">alert</span>(num.<span class="title function_">toFixed</span>(<span class="number">5</span>)) <span class="comment">// &quot;12.34000&quot;，在结尾添加了 0，以达到小数点后五位</span></span><br></pre></td></tr></table></figure><p>我们可以使用一元加号或 <code>Number()</code> 调用，将其转换为数字，例如 <code>+ num.toFixed(5)</code></p></li></ul><p><strong>不精确的计算：</strong><br>在内部，数字是以 64 位格式<code>IEEE-754</code>，如果一个如果一个数字真的很大，则可能会溢出 64 位存储，变成一个特殊的数值 <code>Infinity</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.1</span> + <span class="number">0.2</span>) <span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure><p>一个数字以其二进制的形式存储在内存中，一个 1 和 0 的序列。但是在十进制数字系统中看起来很简单的 <code>0.1</code>，<code>0.2</code> 这样的小数，实际上在二进制形式中是无限循环小数。</p><p>使用二进制数字系统无法 <strong>精确</strong> 存储 <em>0.1</em> 或 _0.2_，就像没有办法将三分之一存储为十进制小数一样。<br>IEEE-754 数字格式通过将数字舍入到最接近的可能数字来解决此问题。这些舍入规则通常不允许我们看到“极小的精度损失”，但是它确实存在。</p><p>最可靠的方法是借助方法 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed">toFixed(n)</a> 对结果进行舍入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line"><span class="title function_">alert</span>(sum.<span class="title function_">toFixed</span>(<span class="number">2</span>)) <span class="comment">// &quot;0.30&quot;</span></span><br></pre></td></tr></table></figure><p><strong>isNaN 和 isFinite</strong></p><ul><li><p><code>isNaN(value)</code> 将其参数转换为数字，然后测试它是否为 <code>NaN</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">isNaN</span>(<span class="string">&#x27;str&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">&#x27;123&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">NaN</span> === <span class="title class_">NaN</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><code>isFinite(value)</code> 将其参数转换为数字，如果是常规数字而不是 <code>NaN/Infinity/-Infinity</code>，则返回 <code>true</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="built_in">isFinite</span>(<span class="string">&#x27;15&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">isFinite</span>(<span class="string">&#x27;str&#x27;</span>)) <span class="comment">// false，因为是一个特殊的值：NaN</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">isFinite</span>(<span class="title class_">Infinity</span>)) <span class="comment">// false，因为是一个特殊的值：Infinity</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>parseInt 和 pareseFloat：</strong></p><p>使用加号 <code>+</code> 或 <code>Number()</code> 的数字转换是严格的。如果一个值不完全是一个数字，就会失败：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(+<span class="string">&#x27;100px&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>但在现实生活中，我们经常会有带有单位的值，例如 CSS 中的 <code>&quot;100px&quot;</code> 或 <code>&quot;12pt&quot;</code>。</p><p>它们可以从字符串中“读取”数字，直到无法读取为止。如果发生 error，则返回收集到的数字。函数 <code>parseInt</code> 返回一个整数，而 <code>parseFloat</code> 返回一个浮点数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;100px&#x27;</span>)) <span class="comment">// 100</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;12.5em&#x27;</span>)) <span class="comment">// 12.5</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;12.3&#x27;</span>)) <span class="comment">// 12，只有整数部分被返回了</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;12.3.4&#x27;</span>)) <span class="comment">// 12.3，在第二个点出停止了读取</span></span><br></pre></td></tr></table></figure><p>某些情况下，<code>parseInt/parseFloat</code> 会返回 <code>NaN</code>。当没有数字可读时会发生这种情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;a123&#x27;</span>)) <span class="comment">// NaN，第一个符号停止了读取</span></span><br></pre></td></tr></table></figure><div class="note orange anzhiyufont anzhiyu-icon-dengpao simple"><p><strong>parseInt(str, radix) 的第二个参数</strong></p></div><p><code>parseInt()</code> 函数具有可选的第二个参数。它指定了数字系统的基数，因此 <code>parseInt</code> 还可以解析十六进制数字、二进制数字等的字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;0xff&#x27;</span>, <span class="number">16</span>)) <span class="comment">// 255</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;ff&#x27;</span>, <span class="number">16</span>)) <span class="comment">// 255，没有 0x 仍然有效</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;2n9c&#x27;</span>, <span class="number">36</span>)) <span class="comment">// 123456</span></span><br></pre></td></tr></table></figure><p><strong>其他数学函数：</strong></p><p><strong><code>Math.random()</code>：</strong>返回一个从 0 到 1 的随机数（不包括 1</p><p><strong><code>Math.max(a, b, c...)和Math.min(a, b, c...)</code>：</strong> 从任意数量的参数中返回最大值和最小值。</p><p><strong><code>Math.pow(n, power)</code>：</strong>返回 <code>n</code> 的给定（power）次幂。</p><p><strong><code>Math.sqrt(100)</code>：</strong> 取根号</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li><strong>单引号：</strong> <code>let str = &#39;hello&#39;</code></li><li><strong>双引号：</strong><code>let str = &quot;hello&quot;</code></li><li><strong>反引号：</strong> let str &#x3D; `hello`</li></ul><h4 id="字符串中的方法"><a href="#字符串中的方法" class="headerlink" title="字符串中的方法"></a>字符串中的方法</h4><h5 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h5><ul><li><p><code>toUpperCase() || toLowerCase()：</code>改变大小写</p></li><li><p><code>substring(start||0,end?length)：</code>获得子串</p><div class="note orange anzhiyufont anzhiyu-icon-dengpao simple"><p>MDN 已经不推荐使用 <code>substr</code> 方法了 属于遗留特性 建议使用<code>slice</code></p></div></li><li><p><code>slice(start,end):</code>参数可以为负数，不破坏原来的串返回新的串</p></li><li><p><code>replace(pattern:(string|regex,replacement:(string|function)))：</code>替换(pattern 是如果是 string,则只会替换第一项) –&gt; <code>replaceAll</code></p></li><li><p><code>split(separator:(undefined||string||regex),limit?)：</code>分割字符形成数组，如果<code>separator</code>为<code>undefined</code>则会形成<code>[&#39;str&#39;]</code></p></li><li><p><code>includes(searchString,position?):boolean：</code> 查找是否包含</p></li><li><p><code>indexof(serchValue,position?):index||-1：</code>查找的字符串 <code>searchValue</code> 的第一次出现的索引，如果没有找到，则返回 <code>-1</code>。</p></li><li><p><code>lastIndexOf(serchValue,position?)</code></p></li></ul><h5 id="不常用"><a href="#不常用" class="headerlink" title="不常用"></a>不常用</h5><ul><li><code>at()</code></li><li><code>charAt</code></li><li><code>charCodeAt()</code></li><li><code>match(regexp)</code></li><li><code>startsWith(searchString,position?)</code></li><li><code>endsWith(...)</code></li><li><code>trim()</code></li></ul><h3 id="Boolean-逻辑类型"><a href="#Boolean-逻辑类型" class="headerlink" title="Boolean(逻辑类型)"></a>Boolean(逻辑类型)</h3><h4 id="布尔转换时"><a href="#布尔转换时" class="headerlink" title="布尔转换时"></a>布尔转换时</h4><ul><li><strong>空</strong>值：即 0、” “、undefined、NaN、null 转换为<code>false</code></li><li>其余为 <code>true</code></li></ul><blockquote><p>注意 “0” 是 true 噢</p></blockquote><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><h5 id="或运算"><a href="#或运算" class="headerlink" title="或运算(||)"></a>或运算(||)</h5><p>传统的比如 <code>if</code>中使用 就不提了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = value1 || value2 || value3</span><br><span class="line"><span class="comment">// 处理每一个操作数时，都将其转化为布尔值。如果结果是 true，就停止计算，返回这个操作数的初始值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用处理逻辑</span></span><br><span class="line">flag || <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line"><span class="literal">false</span> || <span class="title function_">alert</span>(<span class="string">&quot;printed&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="与运算"><a href="#与运算" class="headerlink" title="与运算(&amp;&amp;)"></a><strong>与运算(&amp;&amp;)</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> &amp;&amp; <span class="number">0</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> &amp;&amp; <span class="number">5</span>) <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 在处理每一个操作数时，都将其转化为布尔值。如果结果是 false，就停止计算，并返回这个操作数的初始值。</span></span><br></pre></td></tr></table></figure><h5 id="非运算"><a href="#非运算" class="headerlink" title="非运算(!)"></a><strong>非运算(!)</strong></h5><p>两个非运算 <code>!!</code> 有时候用来将某个值转化为布尔类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(!!<span class="string">&#x27;non-empty string&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>(!!<span class="literal">null</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="值比较"><a href="#值比较" class="headerlink" title="值比较"></a>值比较</h4><h5 id="严格相等"><a href="#严格相等" class="headerlink" title="严格相等"></a>严格相等</h5><p>普通的相等性检查 <code>==</code> 存在一个问题，会先转换类型才会进行比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> == <span class="literal">false</span>) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&#x27;</span> == <span class="literal">false</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>严格相等运算符 <code>===</code> 在进行比较时不会做任何的类型转换。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="number">0</span> === <span class="literal">false</span>) <span class="comment">// false，因为被比较值的数据类型不同</span></span><br></pre></td></tr></table></figure><h5 id="null和undefined进行比较"><a href="#null和undefined进行比较" class="headerlink" title="null和undefined进行比较"></a><code>null</code>和<code>undefined</code>进行比较</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="literal">null</span> === <span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="literal">null</span> == <span class="literal">undefined</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="literal">null</span> &gt; <span class="number">0</span>) <span class="comment">// (1) false</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="literal">null</span> == <span class="number">0</span>) <span class="comment">// (2) false</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="literal">null</span> &gt;= <span class="number">0</span>) <span class="comment">// (3) true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="literal">undefined</span> &gt; <span class="number">0</span>) <span class="comment">// false (1)</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="literal">undefined</span> &lt; <span class="number">0</span>) <span class="comment">// false (2)</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="literal">undefined</span> == <span class="number">0</span>) <span class="comment">// false (3)</span></span><br></pre></td></tr></table></figure><h5 id="和-运算符"><a href="#和-运算符" class="headerlink" title="?和??运算符"></a><code>?</code>和<code>??</code>运算符</h5><p>?运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = condition ? value1 : value2</span><br><span class="line"><span class="comment">// 计算条件结果，如果结果为真，则返回 value1，否则返回 value2。</span></span><br><span class="line"><span class="keyword">let</span> accessAllowed = age &gt; <span class="number">18</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// 上面写法有点多余 因为 accessAllowed 如果写成 age &gt; 18 本来就会返回一个boolean</span></span><br></pre></td></tr></table></figure><p>使用一系列问号 <code>?</code> 运算符可以返回一个取决于多个条件的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="title function_">prompt</span>(<span class="string">&#x27;age?&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> message =</span><br><span class="line">  age &lt; <span class="number">3</span></span><br><span class="line">    ? <span class="string">&#x27;Hi, baby!&#x27;</span></span><br><span class="line">    : age &lt; <span class="number">18</span></span><br><span class="line">    ? <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">    : age &lt; <span class="number">100</span></span><br><span class="line">    ? <span class="string">&#x27;Greetings!&#x27;</span></span><br><span class="line">    : <span class="string">&#x27;What an unusual age!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(message)</span><br></pre></td></tr></table></figure><p><strong>?</strong> 有时候能代替<strong>if</strong>但是可读性并不强 赋值的时可以考虑使用 <strong>?</strong> 做逻辑判断的时候 <strong>if</strong> 更佳</p><p><strong>空值合并运算符<code>??</code></strong></p><p>对待 <code>null</code> 和 <code>undefined</code> 的方式类似,所以当一个值既不是 <code>null</code> 也不是 <code>undefined</code> 时，我们将其称为“已定义的（defined）否则为未定义</p><p><code>a ?? b</code> 的结果是：</p><ul><li>如果 <code>a</code> 是已定义的，则结果为 <code>a</code>，</li><li>如果 <code>a</code> 不是已定义的，则结果为 <code>b</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = a !== <span class="literal">null</span> &amp;&amp; a !== <span class="literal">undefined</span> ? a : b</span><br><span class="line"><span class="keyword">let</span> user</span><br><span class="line"><span class="title function_">alert</span>(user ?? <span class="string">&#x27;匿名&#x27;</span>) <span class="comment">// 匿名（user 未定义）</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="string">&#x27;John&#x27;</span></span><br><span class="line"><span class="title function_">alert</span>(user ?? <span class="string">&#x27;匿名&#x27;</span>) <span class="comment">// John（user 已定义）</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> lastName = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> nickName = <span class="string">&#x27;Supercoder&#x27;</span></span><br><span class="line"><span class="comment">// 显示第一个已定义的值：</span></span><br><span class="line"><span class="title function_">alert</span>(firstName ?? lastName ?? nickName ?? <span class="string">&#x27;匿名&#x27;</span>) <span class="comment">// Supercoder</span></span><br></pre></td></tr></table></figure><p><strong>与||比较</strong></p><p>它们之间重要的区别是：</p><ul><li><code>||</code> 返回第一个 <strong>真</strong> 值。</li><li><code>??</code> 返回第一个 <strong>已定义的</strong> 值。</li></ul><p>换句话说，<code>||</code> 无法区分 <code>false</code>、<code>0</code>、空字符串 <code>&quot;&quot;</code> 和 <code>null/undefined</code>。它们都一样 —— 假值（falsy values）。如果其中任何一个是 <code>||</code> 的第一个参数，那么我们将得到第二个参数作为结果。</p><p>不过在实际中，我们可能只想在变量的值为 <code>null/undefined</code> 时使用默认值。也就是说，当该值确实未知或未被设置时。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> height = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(height || <span class="number">100</span>) <span class="comment">// 100</span></span><br><span class="line"><span class="title function_">alert</span>(height ?? <span class="number">100</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h3><p>特殊的<code>null</code>值不属于任何一种类型构成了独立类型，仅代表无、空、值未知等状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 表示age是未知的</span></span><br></pre></td></tr></table></figure><h3 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h3><p>特殊值 <code>undefined</code> 和 <code>null</code> 一样自成类型。<br>如果一个变量已被声明，但未被赋值，那么它的值就是 <code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age</span><br><span class="line"><span class="title function_">alert</span>(age) <span class="comment">// 弹出 &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure><p>通常，使用 <code>null</code> 将一个“空”或者“未知”的值写入变量中，而 <code>undefined</code> 则保留作为未进行初始化的事物的默认初始值。</p><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>“symbol” 值表示唯一的标识符,可以使用 <code>Symbol()</code> 来创建这种类型的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&#x27;id&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h4><p>symbol 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性。</p><p>例如，如果我们使用的是属于第三方代码的 <code>user</code> 对象，我们想要给它们添加一些标识符。</p><p>我们可以给它们使用 symbol 键：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="comment">// 属于另一个代码</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">user[id] = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user[id]) <span class="comment">// 我们可以使用 symbol 作为键来访问数据</span></span><br></pre></td></tr></table></figure><p>我们的标识符和它们的标识符之间不会有冲突，因为 symbol 总是不同的，即使它们有相同的名字。</p><h4 id="对象字面量中的-symbol"><a href="#对象字面量中的-symbol" class="headerlink" title="对象字面量中的 symbol"></a>对象字面量中的 symbol</h4><p>如果我们要在对象字面量 <code>&#123;...&#125;</code> 中使用 symbol，则需要使用方括号把它括起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  [id]: <span class="number">123</span> <span class="comment">// 而不是 &quot;id&quot;：123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Symbol-会在-for-in-中跳过"><a href="#Symbol-会在-for-in-中跳过" class="headerlink" title="Symbol 会在 for in 中跳过"></a>Symbol 会在 for in 中跳过</h4><p>symbol 属性不参与 <code>for..in</code> 循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  [id]: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user) <span class="title function_">alert</span>(key) <span class="comment">// name, age（没有 symbol）</span></span><br><span class="line"><span class="comment">// 使用 symbol 任务直接访问</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;Direct: &#x27;</span> + user[id]) <span class="comment">// Direct: 123</span></span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys">Object.keys(user)</a> 也会忽略它们。这是一般“隐藏符号属性”原则的一部分。如果另一个脚本或库遍历我们的对象，它不会意外地访问到符号属性。</p><p>相反，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> 会同时复制字符串和 symbol 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  [id]: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, user)</span><br><span class="line"><span class="title function_">alert</span>(clone[id]) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><h4 id="全局-Symbol"><a href="#全局-Symbol" class="headerlink" title="全局 Symbol"></a>全局 Symbol</h4><p>要从注册表中读取（不存在则创建）symbol，请使用 <code>Symbol.for(key)</code>。<br>该调用会检查全局注册表，如果有一个描述为 <code>key</code> 的 symbol，则返回该 symbol，否则将创建一个新 symbol（<code>Symbol(key)</code>），并通过给定的 <code>key</code> 将其存储在注册表中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从全局注册表中读取</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;id&#x27;</span>) <span class="comment">// 如果该 symbol 不存在，则创建它</span></span><br><span class="line"><span class="comment">// 再次读取（可能是在代码中的另一个位置）</span></span><br><span class="line"><span class="keyword">let</span> idAgain = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line"><span class="comment">// 相同的 symbol</span></span><br><span class="line"><span class="title function_">alert</span>(id === idAgain) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor"></a>Symbol.keyFor</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 name 获取 symbol</span></span><br><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> sym2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line"><span class="comment">// 通过 symbol 获取 name</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(sym)) <span class="comment">// name</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(sym2)) <span class="comment">// id</span></span><br></pre></td></tr></table></figure><h3 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h3><p><code>BigInt</code> 是一种特殊的数字类型，它提供了对任意长度整数的支持。</p><p>创建 bigint 的方式有两种：在一个整数字面量后面加 <code>n</code> 或者调用 <code>BigInt</code> 函数，该函数从字符串、数字等中生成 bigint。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bigint = <span class="number">1234567890123456789012345678901234567890n</span></span><br><span class="line"><span class="keyword">const</span> sameBigint = <span class="title class_">BigInt</span>(<span class="string">&#x27;1234567890123456789012345678901234567890&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bigintFromNumber = <span class="title class_">BigInt</span>(<span class="number">10</span>) <span class="comment">// 与 10n 相同</span></span><br></pre></td></tr></table></figure><details class="folding-tag" cyan><summary>基本类型和引用类型</summary><div class="content"><ol><li><p><code>Javascript</code>中栈和堆</p><ul><li>栈(<strong>stack</strong>)：自动分配固定大小的内存空间，并由系统自动释放，栈数据结构遵从先进后出的原则</li><li>堆(<strong>heap</strong>)：堆内存，动态分配内存，内存大小不固定，也不会自动释放，堆数据结构是一种无序的树状结构，满足<code>key-value</code>键值对我们只用知道 key 名，就能通过 key 查找到对应的 value。比较经典的就是书架存书的例子，我们知道书名，就可以找到对应的书籍</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/javascript1.png"></p></li><li><p>引用类型的引用和复制</p><p><strong>当一个对象变量被复制 —— 引用被复制，而该对象自身并没有被复制。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">name</span>: <span class="string">&#x27;月晕&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line"><span class="comment">// 这里在堆内存中并没有新new 一份 &#123;name: &#x27;月晕&#x27;, age: 18&#125;,而只是把b的内容地址指向a的地址 指向堆内存中的同一份</span></span><br></pre></td></tr></table></figure></li></ol></div></details><p><strong>非原始数据类型:</strong></p><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="Object-表示"><a href="#Object-表示" class="headerlink" title="Object 表示"></a>Object 表示</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// “构造函数” 的语法</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;&#125;;  <span class="comment">// “字面量” 的语法</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这将提示有语法错误</span></span><br><span class="line">user.<span class="property">likes</span> birds = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 下面这样不会报错</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line">user[<span class="string">&quot;likes birds&quot;</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="title function_">alert</span>(user[<span class="string">&quot;likes birds&quot;</span>]); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">delete</span> user[<span class="string">&quot;likes birds&quot;</span>];</span><br></pre></td></tr></table></figure><p><strong>object 中 key 的计算属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruit = <span class="title function_">prompt</span>(<span class="string">&#x27;Which fruit to buy?&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> bag = &#123;</span><br><span class="line">  [fruit]: <span class="number">5</span>, <span class="comment">// 属性名是从 fruit 变量中得到的</span></span><br><span class="line">  [fruit + <span class="string">&#x27;Computers&#x27;</span>]: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(bag.<span class="property">apple</span>) <span class="comment">// 5 如果 fruit=&quot;apple&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Object-的引用和复制"><a href="#Object-的引用和复制" class="headerlink" title="Object 的引用和复制"></a>Object 的引用和复制</h4><p>对象与原始类型的根本区别之一是，对象是“通过引用”存储和复制的，而原始类型：字符串、数字、布尔值等 —— 总是“作为一个整体”复制。</p><p><strong>当一个对象变量被复制 —— 引用被复制，而该对象自身并没有被复制。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> admin = user <span class="comment">// 复制引用</span></span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zh.javascript.info/article/object-copy/variable-copy-reference.svg"></p><p><strong>克隆和合并,Object.assign</strong></p><p>拷贝一个对象变量会又创建一个对相同对象的引用,复制一个对象，那该怎么做呢？<br>最先想到的就是遍历一份</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;月晕&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> clone = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user) &#123;</span><br><span class="line">  clone[key] = user[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 es6 对象展开符</span></span><br><span class="line"><span class="keyword">let</span> clone1 = &#123; ...user &#125;</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a>来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.assign(dest, src1, src2, src3,...)</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;yueyun&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> permissions1 = &#123; <span class="attr">canView</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> permissions2 = &#123; <span class="attr">canEdit</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="comment">// 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(user, permissions1, permissions2);</span><br><span class="line"><span class="comment">// 现在 user = &#123; name: &quot;John&quot;, canView: true, canEdit: true &#125;</span></span><br><span class="line"><span class="comment">// 如果被拷贝的属性的属性名已经存在，那么它会被覆盖</span></span><br></pre></td></tr></table></figure><p><strong>深层克隆：</strong></p><p>到现在为止，我们都假设 <code>user</code> 的所有属性均为原始类型。但属性可以是对其他对象的引用。<br>当数组中存在对象抑或是对象中存在对象就要使用深拷贝</p><p>深拷贝可以使用 JSON 序列化(有优缺点)来做或者是自己手写一个深拷贝函数</p><p><strong>lodash</strong>库中的<code>.cloneDeep(obj)</code></p><p>使用 <code>structuredClone()</code> 去拷贝</p><h4 id="Object-中的-this"><a href="#Object-中的-this" class="headerlink" title="Object 中的 this"></a>Object 中的 this</h4><p>this 即是函数的上下文，this 出现的值取决于它出现的上下文：函数、类或全局</p><p>函数写在对象中称之为对象的方法</p><h5 id="方法中的this"><a href="#方法中的this" class="headerlink" title="方法中的this"></a>方法中的<code>this</code></h5><p>通常, 对象方法需要访问对象中存储的信息才能完成其工作。<br>this 会指向一个对象：</p><ul><li>以函数形式调用时、this 指向的是 widow(浏览器环境)&#x2F;<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/globalThis">globalThis</a>(nodejs 环境)</li><li>以方法的形式调用、this 指向的是调用方法的对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// this 指的是当前对象 John</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this</code> 的值是在代码运行时计算出来的，它取决于代码上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> admin = &#123; <span class="attr">name</span>: <span class="string">&#x27;Admin&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在两个对象中使用相同的函数</span></span><br><span class="line">user.<span class="property">f</span> = sayHi</span><br><span class="line">admin.<span class="property">f</span> = sayHi</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个调用有不同的 this 值</span></span><br><span class="line"><span class="comment">// 函数内部的 &quot;this&quot; 是“点符号前面”的那个对象</span></span><br><span class="line">user.<span class="title function_">f</span>() <span class="comment">// John（this == user）</span></span><br><span class="line">admin.<span class="title function_">f</span>() <span class="comment">// Admin（this == admin）</span></span><br><span class="line">admin[<span class="string">&#x27;f&#x27;</span>]() <span class="comment">// Admin（使用点符号或方括号语法来访问这个方法，都没有关系。）</span></span><br></pre></td></tr></table></figure><h5 id="箭头函数没有自己的this"><a href="#箭头函数没有自己的this" class="headerlink" title="箭头函数没有自己的this"></a><strong>箭头函数没有自己的<code>this</code></strong></h5><p>箭头函数有些特别：它们没有自己的 <code>this</code>。如果我们在这样的函数中引用 <code>this</code>，<code>this</code> 值取决于外部“正常的”函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;Ilya&#x27;</span>,</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">arrow</span> = (<span class="params"></span>) =&gt; <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">firstName</span>)</span><br><span class="line">    <span class="title function_">arrow</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">user.<span class="title function_">sayHi</span>() <span class="comment">// Ilya</span></span><br></pre></td></tr></table></figure><h4 id="可选链？"><a href="#可选链？" class="headerlink" title="可选链？"></a>可选链？</h4><p>可选链<code>?.</code> 是一种访问嵌套对象属性的安全的方式，即使中间属性不存在也不会出现错误</p><p><strong>不存在属性问题：</strong></p><p>如果我们有很多个 <code>user</code> 对象其中存储了我们的用户数据，我们大多数用户的地址都存储在 <code>user.address</code> 中，街道地址存储在 <code>user.address.street</code> 中，但有些用户没有提供这些信息。在这种情况下，当我们尝试获取 <code>user.address.street</code>，而该用户恰好没提供地址信息，我们则会收到一个错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125; <span class="comment">// 一个没有 &quot;address&quot; 属性的 user 对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">address</span>.<span class="property">street</span>) <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><p>javascritp 会把 <code>user.address</code> 识别为 <code>undefined</code> 尝试读取<code>user.address.street</code> 即是<code>undefined.street</code>自然是会失败并返回一个错误</p><p>在 Web 开发中，我们可以使用特殊的方法调用（例如 <code>document.querySelector(&#39;.elem&#39;)</code>）以对象的形式获取一个网页元素，如果没有这种对象，则返回 <code>null</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.elem&#x27;</span>).<span class="property">innerHTML</span></span><br><span class="line"><span class="comment">// 如果 document.querySelector(&#x27;.elem&#x27;) 的结果为 null，则会出现错误</span></span><br></pre></td></tr></table></figure><p>同样，如果该元素不存在，则访问 <code>null</code> 的 <code>.innerHTML</code> 属性时会报错。在某些情况下，当元素的缺失是没问题的时候，我们希望避免出现这种错误，而是接受 <code>html = null</code> 作为结果。</p><p>首先我们想到的肯定是可以用<code>if</code>条件语句判断或者<code>?</code>运算符来解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">address</span> ? user.<span class="property">address</span>.<span class="property">street</span> : <span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure><p>当层级多了之后显示会很臃肿而且不优雅 即引入了<strong>可选链?</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125; <span class="comment">// user 没有 address 属性</span></span><br><span class="line"><span class="title function_">alert</span>(user?.<span class="property">address</span>?.<span class="property">street</span>) <span class="comment">// undefined（不报错）</span></span><br><span class="line"><span class="keyword">let</span> html = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.elem&#x27;</span>)?.<span class="property">innerHTML</span></span><br><span class="line"><span class="comment">// 如果没有符合的元素，则为 undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>如果未声明变量 <code>user</code>，那么 <code>user?.anything</code> 会触发一个错误<br><code>?.</code> 前的变量必须已声明（例如 <code>let/const/var user</code> 或作为一个函数参数）。可选链仅适用于已声明的变量。</p></blockquote><p>当然也存在<strong>*<code>?.()</code></strong> 和 <strong><code>?.[]</code></strong></p><h2 id="Javascript-中的方法"><a href="#Javascript-中的方法" class="headerlink" title="Javascript 中的方法"></a>Javascript 中的方法</h2><h3 id="原始类型的方法"><a href="#原始类型的方法" class="headerlink" title="原始类型的方法"></a>原始类型的方法</h3><p><code>string</code> <code>number</code> <code>bigInt</code> <code>boolean</code> <code>symbol</code> <code>null</code> <code>undefined</code></p><p>比如下面的这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">toUpperCase</span>())</span><br></pre></td></tr></table></figure><p><code>str.toUpperCase()</code>中实际发生的情况</p><ul><li>字符串<code>str</code>是一个原始值。因此，在访问其属性时，会创建一个包含字符串字面值的特殊对象，并且具有可用的方法，例如 <code>toUpperCase()</code>。</li><li>该方法运行并返回一个新的字符串（由 <code>console.log</code> 显示）。</li><li>特殊对象被销毁，只留下原始值 <code>str</code>。</li></ul><p>所以原始类型可以提供方法，但它们依然是轻量级的。</p><p>JavaScript 引擎高度优化了这个过程。它甚至可能跳过创建额外的对象。但是它仍然必须遵守规范，并且表现得好像它创建了一样。</p><p>数字有其自己的方法，例如，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed">toFixed(n)</a> 将数字舍入到给定的精度</p><h3 id="数组中的方法"><a href="#数组中的方法" class="headerlink" title="数组中的方法"></a>数组中的方法</h3><p>但很多时候我们发现还需要 <strong>有序集合</strong>，里面的元素都是按顺序排列的。例如，我们可能需要存储一些列表，比如用户、商品以及 HTML 元素等，这时一个特殊的数据结构数组（<code>Array</code>）就派上用场了，它能存储有序的集合。</p><blockquote><p>从 JS 的数据类型本质上面来说 数组属于是一种特殊的对象</p></blockquote><ul><li>添加&#x2F;删除元素<ul><li><code>push(...items)</code> —— 向尾端添加元素，</li><li><code>pop()</code> —— 从尾端提取一个元素，</li><li><code>shift()</code> —— 从首端提取一个元素，</li><li><code>unshift(...items)</code> —— 向首端添加元素，</li><li><code>splice(pos, deleteCount, ...items)</code> —— 从 <code>pos</code> 开始删除 <code>deleteCount</code> 个元素，并插入 <code>items</code>。</li><li><code>slice(start, end)</code> —— 创建一个新数组，将从索引 <code>start</code> 到索引 <code>end</code>（但不包括 <code>end</code>）的元素复制进去。</li><li><code>concat(...items)</code> —— 返回一个新数组：复制当前数组的所有元素，并向其中添加 <code>items</code>。如果 <code>items</code> 中的任意一项是一个数组，那么就取其元素。</li></ul></li><li>搜索元素<ul><li><code>indexOf/lastIndexOf(item, pos)</code> —— 从索引 <code>pos</code> 开始搜索 <code>item</code>，搜索到则返回该项的索引，否则返回 <code>-1</code>。</li><li><code>includes(value)</code> —— 如果数组有 <code>value</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</li><li><code>find/filter(func)</code> —— 通过 <code>func</code> 过滤元素，返回使 <code>func</code> 返回 <code>true</code> 的第一个值&#x2F;所有值。</li><li><code>findIndex</code> 和 <code>find</code> 类似，但返回索引而不是值。</li></ul></li><li>遍历元素<ul><li><code>forEach(func)</code> —— 对每个元素都调用 <code>func</code>，不返回任何内容。</li></ul></li><li>转换数组<ul><li><code>map(func)</code> —— 根据对每个元素调用 <code>func</code> 的结果创建一个新数组。</li><li><code>sort(func)</code> —— 对数组进行原位（in-place）排序，然后返回它。</li><li><code>reverse()</code> —— 原位（in-place）反转数组，然后返回它。</li><li><code>split/join</code> —— 将字符串转换为数组并返回。</li><li><code>reduce/reduceRight(func, initial)</code> —— 通过对每个元素调用 <code>func</code> 计算数组上的单个值，并在调用之间传递中间结果。</li></ul></li><li>其他方法<ul><li><code>Array.isArray(value)</code> 检查 <code>value</code> 是否是一个数组，如果是则返回 <code>true</code>，否则返回 <code>false</code>。</li></ul></li></ul><p>请注意，<code>sort</code>，<code>reverse</code> 和 <code>splice</code> 方法修改的是数组本身。</p><ul><li>杂<ul><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/some">arr.some(fn)</a>&#x2F;<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/every">arr.every(fn)</a> 检查数组</li><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/fill">arr.fill(value, start, end)</a> —— 从索引 <code>start</code> 到 <code>end</code>，用重复的 <code>value</code> 填充数组。</li><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin">arr.copyWithin(target, start, end)</a> —— 将从位置 <code>start</code> 到 <code>end</code> 的所有元素复制到 <strong>自身</strong> 的 <code>target</code> 位置（覆盖现有元素）。</li><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/flat">arr.flat(depth)</a>&#x2F;<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap">arr.flatMap(fn)</a> 从多维数组创建一个新的扁平数组。</li></ul></li></ul><h3 id="Iterable-object-可迭代对象"><a href="#Iterable-object-可迭代对象" class="headerlink" title="Iterable object(可迭代对象)"></a>Iterable object(可迭代对象)</h3><p>可迭代(<strong>Iterable</strong>) 对像是数组的泛化，即是对象可以在<code>for of</code>循环中使用</p><p>数组是可迭代的。但不仅仅是数组。很多其他内建对象也都是可迭代的。例如字符串也是可迭代的。</p><p>如果从技术上讲，对象不是数组，而是表示某物的集合（列表，集合），<code>for..of</code> 是一个能够遍历它的很好的语法，因此，让我们来看看如何使其发挥作用。</p><h4 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h4><p>比如现在有一个<code>range</code>对象代表了一个数字区间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="attr">from</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">to</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们希望</span></span><br><span class="line"><span class="comment">// for(let num of range) &#123;console.log(num) ...1 2 3 4 5&#125;</span></span><br></pre></td></tr></table></figure><p>为了让<code>range</code>对象可以迭代我们需要手动为其添加一个<code>Symbol.iterator</code>方法</p><ol><li>当 <code>for..of</code> 循环启动时，它会调用这个方法（如果没找到，就会报错）。这个方法必须返回一个 <strong>迭代器（iterator）</strong> —— 一个有 <code>next</code> 方法的对象。</li><li>从此开始，<code>for..of</code> <strong>仅适用于这个被返回的对象</strong>。</li><li>当 <code>for..of</code> 循环希望取得下一个数值，它就调用这个对象的 <code>next()</code> 方法。</li><li><code>next()</code> 方法返回的结果的格式必须是 <code>&#123;done: Boolean, value: any&#125;</code>，当 <code>done=true</code> 时，表示循环结束，否则 <code>value</code> 是下一个值。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> range = &#123;</span><br><span class="line">  <span class="attr">from</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">to</span>: <span class="number">5</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">current</span>: <span class="variable language_">this</span>.<span class="property">from</span>,</span><br><span class="line">      <span class="attr">last</span>: <span class="variable language_">this</span>.<span class="property">to</span>,</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">current</span> &lt;= <span class="variable language_">this</span>.<span class="property">last</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;explosion&#x27;</span>)</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">current</span>++ &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> range) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personInfo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;月晕&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">hobby</span>: [<span class="string">&#x27;code&#x27;</span>, <span class="string">&#x27;play Game&#x27;</span>, <span class="string">&#x27;sleep&#x27;</span>],</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">keys</span>: <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>),</span><br><span class="line">      <span class="attr">index</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">index</span> &lt; <span class="variable language_">this</span>.<span class="property">keys</span>.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: that[<span class="variable language_">this</span>.<span class="property">keys</span>[<span class="variable language_">this</span>.<span class="property">index</span>++]] &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> personInfo) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personInfo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;月晕&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">hobby</span>: [<span class="string">&#x27;code&#x27;</span>, <span class="string">&#x27;play Game&#x27;</span>, <span class="string">&#x27;sleep&#x27;</span>],</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; keys.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="variable language_">this</span>[keys[index++]] &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> personInfo) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>无穷迭代器（iterator）</strong></p><p>无穷迭代器也是可能的。例如，将 <code>range</code> 设置为 <code>range.to = Infinity</code>，这时 <code>range</code> 则成为了无穷迭代器。或者我们可以创建一个可迭代对象，它生成一个无穷伪随机数序列。也是可能的。</p><p><code>next</code> 没有什么限制，它可以返回越来越多的值，这是正常的。</p><p>当然，迭代这种对象的 <code>for..of</code> 循环将不会停止。但是我们可以通过使用 <code>break</code> 来停止它。</p></blockquote><h4 id="字符串迭代"><a href="#字符串迭代" class="headerlink" title="字符串迭代"></a>字符串迭代</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chars = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> chars) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(char)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="显示调用迭代器"><a href="#显示调用迭代器" class="headerlink" title="显示调用迭代器"></a>显示调用迭代器</h4><p>为了更深层地了解底层知识，让我们来看看如何显式地使用迭代器。</p><p>我们将会采用与 <code>for..of</code> 完全相同的方式遍历字符串，但使用的是直接调用。这段代码创建了一个字符串迭代器，并“手动”从中获取值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;yueyun&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和 for..of 做相同的事</span></span><br><span class="line"><span class="comment">// for (let char of str) alert(char);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = iterator.<span class="title function_">next</span>()</span><br><span class="line">  <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">break</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">value</span>) <span class="comment">// 一个接一个地输出字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很少需要我们这样做，但是比 <code>for..of</code> 给了我们更多的控制权。例如，我们可以拆分迭代过程：迭代一部分，然后停止，做一些其他处理，然后再恢复迭代。</p><p>可迭代(<strong>iterable</strong>)和类数组(<strong>array-like</strong>)</p><ul><li><strong>Iterable</strong> 如上所述，是实现了 <code>Symbol.iterator</code> 方法的对象。</li><li><strong>Array-like</strong> 是有索引和 <code>length</code> 属性的对象，所以它们看起来很像数组。</li></ul><h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h4><p>有一个全局方法 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/from">Array.from</a> 可以接受一个可迭代或类数组的值，并从中获取一个“真正的”数组。然后我们就可以对其调用数组方法了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;yueyun&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;suki&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">pop</span>())</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受上面的range 生成数组</span></span><br><span class="line"><span class="keyword">const</span> range = &#123;</span><br><span class="line">  <span class="attr">from</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">to</span>: <span class="number">5</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">current</span>: <span class="variable language_">this</span>.<span class="property">from</span>,</span><br><span class="line">      <span class="attr">last</span>: <span class="variable language_">this</span>.<span class="property">to</span>,</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">current</span> &lt;= <span class="variable language_">this</span>.<span class="property">last</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">current</span>++ &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> rangeArr = <span class="title class_">Array</span>.<span class="title function_">from</span>(range)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rangeArr) <span class="comment">// [1 2 3 4 5]</span></span><br></pre></td></tr></table></figure><p>可选的第二个参数 <code>mapFn</code> 可以是一个函数，该函数会在对象中的元素被添加到数组前，被应用于每个元素，此外 <code>thisArg</code> 允许我们为该函数设置 <code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求每个数的平方</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(range, <span class="function">(<span class="params">num</span>) =&gt;</span> num * num)</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(arr) <span class="comment">// 1,4,9,16,25</span></span><br></pre></td></tr></table></figure><h2 id="Map-和-Set-映射和集合"><a href="#Map-和-Set-映射和集合" class="headerlink" title="Map 和 Set(映射和集合)"></a>Map 和 Set(映射和集合)</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a>是一个带键的数据项集合.就跟<code>Object</code>一样,区别就是<code>Map</code>的<code>key</code>允许是任意类型<br>Map 的方法和属性如下</p><ul><li><code>new Map()</code> —— 创建 map。</li><li><code>map.set(key, value)</code> —— 根据键存储值。</li><li><code>map.get(key)</code> —— 根据键来返回值，如果 <code>map</code> 中不存在对应的 <code>key</code>，则返回 <code>undefined</code>。</li><li><code>map.has(key)</code> —— 如果 <code>key</code> 存在则返回 <code>true</code>，否则返回 <code>false</code>。</li><li><code>map.delete(key)</code> —— 删除指定键的值。</li><li><code>map.clear()</code> —— 清空 map。</li><li><code>map.size</code> —— 返回当前元素个数。</li></ul><blockquote><p>Map 可以使用对象来做键</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;</span><br><span class="line"><span class="comment">// 存储每个用户的来访次数</span></span><br><span class="line"><span class="keyword">let</span> visitsCountMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"><span class="comment">// john 是 Map 中的键</span></span><br><span class="line">visitsCountMap.<span class="title function_">set</span>(john, <span class="number">123</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(visitsCountMap.<span class="title function_">get</span>(john)) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>使用对象作为键是 <code>Map</code> 最值得注意和重要的功能之一。在 <code>Object</code> 中，我们则无法使用对象作为键。在 <code>Object</code> 中使用字符串作为键是可以的，但我们无法使用另一个 <code>Object</code> 作为 <code>Object</code> 中的键</p></blockquote><div class="note info simple"><p><code>map.set</code>调用都会返回 map 本身 即我们可以进行链式调用</p></div><h3 id="Map-迭代"><a href="#Map-迭代" class="headerlink" title="Map 迭代"></a>Map 迭代</h3><p>如果要在<code>Map</code>里使用循环 可以使用下面的方法</p><ul><li><code>map.keys()</code> 遍历并返回一个包含所有键的可迭代对象</li><li><code>map.values()</code> —— 遍历并返回一个包含所有值的可迭代对象，</li><li><code>map.entries()</code> —— 遍历并返回一个包含所有实体 <code>[key, value]</code> 的可迭代对象，<code>for..of</code> 在默认情况下使用的就是这个。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> recipeMap = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;cucumber&#x27;</span>, <span class="number">500</span>],</span><br><span class="line">  [<span class="string">&#x27;tomatoes&#x27;</span>, <span class="number">300</span>],</span><br><span class="line">  [<span class="string">&#x27;onion&#x27;</span>, <span class="number">50</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 遍历所有的键（vegetables）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> vegetable <span class="keyword">of</span> recipeMap.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(vegetable) <span class="comment">// cucumber, tomatoes, onion</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的值（amounts）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> amount <span class="keyword">of</span> recipeMap.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(amount) <span class="comment">// 500, 350, 50</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的实体 [key, value]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> recipeMap) &#123;</span><br><span class="line">  <span class="comment">// 与 recipeMap.entries() 相同</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(entry) <span class="comment">// cucumber,500 (and so on)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>迭代的顺序与插入值的顺序相同。与普通的 <code>Object</code> 不同，<code>Map</code> 保留了此顺序。</p></blockquote><p><code>Map</code>中有内建的<code>forEach</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对每个键值对 (key, value) 运行 forEach 函数</span></span><br><span class="line">recipeMap.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key, map</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>) <span class="comment">// cucumber: 500 etc</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Map-和对象的转换"><a href="#Map-和对象的转换" class="headerlink" title="Map 和对象的转换"></a>Map 和对象的转换</h3><p><strong><code>Object.entries</code>：</strong>从对象创建 Map</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;yueyun&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// yueyun</span></span><br></pre></td></tr></table></figure><p><strong><code>Object.fromEntries</code>：</strong>从 Map 创建对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> prices = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>([</span><br><span class="line">  [<span class="string">&#x27;banana&#x27;</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">&#x27;orange&#x27;</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="string">&#x27;meat&#x27;</span>, <span class="number">4</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 prices = &#123; banana: 1, orange: 2, meat: 4 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(prices.<span class="property">orange</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;banana&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;orange&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;meat&#x27;</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(map.<span class="title function_">entries</span>())</span><br></pre></td></tr></table></figure><blockquote><p>当 Map 中含有对象作为 key 时 专成对象时的 key 会变成<code>&#39;[object object]&#39;</code></p></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><code>Set</code> 是一个特殊的类型集合 —— “值的集合”（没有键），它的每一个值只能出现一次。 它的主要方法如下：</p><ul><li><code>new Set(iterable)</code> —— 创建一个 <code>set</code>，如果提供了一个 <code>iterable</code> 对象（通常是数组），将会从数组里面复制值到 <code>set</code> 中。</li><li><code>set.add(value)</code> —— 添加一个值，返回 set 本身</li><li><code>set.delete(value)</code> —— 删除值，如果 <code>value</code> 在这个方法调用的时候存在则返回 <code>true</code> ，否则返回 <code>false</code>。</li><li><code>set.has(value)</code> —— 如果 <code>value</code> 在 set 中，返回 <code>true</code>，否则返回 <code>false</code>。</li><li><code>set.clear()</code> —— 清空 set。</li><li><code>set.size</code> —— 返回元素个数。</li></ul><p>它的主要特点是，重复使用同一个值调用 <code>set.add(value)</code> 并不会发生什么改变。这就是 <code>Set</code> 里面的每一个值只出现一次的原因。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> pete = &#123; <span class="attr">name</span>: <span class="string">&#x27;Pete&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> mary = &#123; <span class="attr">name</span>: <span class="string">&#x27;Mary&#x27;</span> &#125;</span><br><span class="line"><span class="comment">// visits，一些访客来访好几次</span></span><br><span class="line">set.<span class="title function_">add</span>(john)</span><br><span class="line">set.<span class="title function_">add</span>(pete)</span><br><span class="line">set.<span class="title function_">add</span>(mary)</span><br><span class="line">set.<span class="title function_">add</span>(john)</span><br><span class="line">set.<span class="title function_">add</span>(mary)</span><br><span class="line"><span class="comment">// set 只保留不重复的值</span></span><br><span class="line"><span class="title function_">alert</span>(set.<span class="property">size</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> user <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(user.<span class="property">name</span>) <span class="comment">// John（然后 Pete 和 Mary）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Set-迭代-iteration"><a href="#Set-迭代-iteration" class="headerlink" title="Set 迭代(iteration)"></a>Set 迭代(iteration)</h3><p>我们可以使用 <code>for..of</code> 或 <code>forEach</code> 来遍历 Set：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;oranges&#x27;</span>, <span class="string">&#x27;apples&#x27;</span>, <span class="string">&#x27;bananas&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> set) <span class="title function_">alert</span>(value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 forEach 相同：</span></span><br><span class="line">set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, valueAgain, set</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="WeakMap-和-WeakSet"><a href="#WeakMap-和-WeakSet" class="headerlink" title="WeakMap 和 WeakSet"></a>WeakMap 和 WeakSet</h3><p>在垃圾回收中 Javascript 引擎在值“可达”和“可使用”时会将其保存在内存中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> yueyun = &#123; <span class="attr">name</span>: <span class="string">&#x27;yueyun&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"><span class="comment">// 该对象能访问 yueyun是它的引用</span></span><br><span class="line"><span class="comment">// 覆盖</span></span><br><span class="line">yueyun = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 该对象将会被从内存中清除</span></span><br></pre></td></tr></table></figure><p>通常 当对象，数组之类的数据结构在内存中时，它们的子元素 如对象的属性，数组的元素都是认为可达的 例如，如果把一个对象放入到数组中，那么只要这个数组存在，那么这个对象也就存在，即使没有其他对该对象的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> yueyun = &#123; <span class="attr">name</span>: <span class="string">&#x27;yueyun&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"><span class="keyword">let</span> arr = [yueyun]</span><br><span class="line"><span class="comment">// 覆盖</span></span><br><span class="line">yueyun = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 前面由 yueyun 所引用的那个对象被存储在了 array 中</span></span><br><span class="line"><span class="comment">// 所以它不会被垃圾回收机制回收</span></span><br><span class="line"><span class="comment">// 我们可以通过 array[0] 获取到它</span></span><br></pre></td></tr></table></figure><p>所以当我们使用对象作为 Map 的键的时 如果 Map 存在 那么对象就会一直存在占用内存不会被垃圾回收</p><p><code>WeakMap</code> 在这方面有着根本上的不同。它不会阻止垃圾回收机制对作为键的对象（key object）的回收。</p><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p><code>WeakMap</code> 和 <code>Map</code> 的第一个不同点就是，<code>WeakMap</code> 的键必须是对象，不能是原始值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> weakMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">weakMap.<span class="title function_">set</span>(obj, <span class="string">&#x27;ok&#x27;</span>) <span class="comment">// 正常工作（以对象作为键）</span></span><br><span class="line"><span class="comment">// 不能使用字符串作为键</span></span><br><span class="line">weakMap.<span class="title function_">set</span>(<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;Whoops&#x27;</span>) <span class="comment">// Error，因为 &quot;test&quot; 不是一个对象</span></span><br></pre></td></tr></table></figure><p>现在，如果我们在 weakMap 中使用一个对象作为键，并且没有其他对这个对象的引用 —— 该对象将会被从内存（和 map）中自动清除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> yueyun = &#123; <span class="attr">name</span>: <span class="string">&#x27;yueyun&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> weakMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line">weakMap.<span class="title function_">set</span>(yueyun, <span class="string">&#x27;yueyun&#x27;</span>)</span><br><span class="line">yueyun = <span class="literal">null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;weakMap&#x27;</span>, weakMap.<span class="title function_">get</span>(yueyun)) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>与常规的<code>map</code>相比 如果<code>yueyun</code>仅仅是作为 <code>WeakMap</code> 的键而存在 —— 它将会被从 map（和内存）中自动删除。</p><p><code>WeakMap</code> 不支持迭代以及 <code>keys()</code>，<code>values()</code> 和 <code>entries()</code> 方法。所以没有办法获取 <code>WeakMap</code> 的所有键或值。<br><code>WeakMap</code> 只有以下的方法：</p><ul><li><code>weakMap.get(key)</code></li><li><code>weakMap.set(key, value)</code></li><li><code>weakMap.delete(key)</code></li><li><code>weakMap.has(key)</code></li></ul><h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><p><code>WeakSet</code> 的表现类似：</p><ul><li>与 <code>Set</code> 类似，但是我们只能向 <code>WeakSet</code> 添加对象（而不能是原始值）。</li><li>对象只有在其它某个（些）地方能被访问的时候，才能留在 <code>WeakSet</code> 中。</li><li>跟 <code>Set</code> 一样，<code>WeakSet</code> 支持 <code>add</code>，<code>has</code> 和 <code>delete</code> 方法，但不支持 <code>size</code> 和 <code>keys()</code>，并且不可迭代。</li></ul><p>变“弱（weak）”的同时，它也可以作为额外的存储空间。但并非针对任意数据，而是针对“是&#x2F;否”的事实。<code>WeakSet</code> 的元素可能代表着有关该对象的某些信息。</p><p>例如，我们可以将用户添加到 <code>WeakSet</code> 中，以追踪访问过我们网站的用户：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> visitedSet = <span class="keyword">new</span> <span class="title class_">WeakSet</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> pete = &#123; <span class="attr">name</span>: <span class="string">&#x27;Pete&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> mary = &#123; <span class="attr">name</span>: <span class="string">&#x27;Mary&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">visitedSet.<span class="title function_">add</span>(john) <span class="comment">// John 访问了我们</span></span><br><span class="line">visitedSet.<span class="title function_">add</span>(pete) <span class="comment">// 然后是 Pete</span></span><br><span class="line">visitedSet.<span class="title function_">add</span>(john) <span class="comment">// John 再次访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// visitedSet 现在有两个用户了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 John 是否来访过？</span></span><br><span class="line"><span class="title function_">alert</span>(visitedSet.<span class="title function_">has</span>(john)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 Mary 是否来访过？</span></span><br><span class="line"><span class="title function_">alert</span>(visitedSet.<span class="title function_">has</span>(mary)) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">john = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// visitedSet 将被自动清理(即自动清除其中已失效的值 john)</span></span><br></pre></td></tr></table></figure><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>JavaScript 中最常用的数据结构是<code>Object</code>和<code>Array</code> 解构赋值是一种特殊的语法 将数组或对象拆包到一系列的变量中</p><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [firstName, lastName] = <span class="string">&#x27;yue yun&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstName) <span class="comment">// yue</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lastName) <span class="comment">// yun</span></span><br></pre></td></tr></table></figure><div class="note info simple"><p>解构并没有破坏 只是方便简单的赋值</p></div><p>有想忽略的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [firstName, , title] = [<span class="string">&#x27;yueyun&#x27;</span>, <span class="string">&#x27;megumi&#x27;</span>, <span class="string">&#x27;korumi&#x27;</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(title) <span class="comment">// korumi</span></span><br></pre></td></tr></table></figure><div class="note info simple"><p>等号的右侧可以是任何可迭代的对象</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = <span class="string">&#x27;abc&#x27;</span> <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="keyword">let</span> [one, two, three] = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><div class="note info simple"><p>交换变量值的技巧</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> guest = <span class="string">&#x27;yue&#x27;</span></span><br><span class="line"><span class="keyword">let</span> admin = <span class="string">&#x27;yun&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让我们来交换变量的值：使得 guest = yue，admin = yun</span></span><br><span class="line">;[guest, admin] = [admin, guest]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;guest&#125;</span> <span class="subst">$&#123;admin&#125;</span>`</span>) <span class="comment">// yun yue（成功交换！）</span></span><br></pre></td></tr></table></figure><p>其余的 <code>...</code></p><p>通常，如果数组比左边的列表长，那么“其余”的数组项会被省略。如果我们还想收集其余的数组项 —— 我们可以使用三个点 <code>&quot;...&quot;</code> 来再加一个参数以获取其余数组项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [name1, name2, ...rest] = [</span><br><span class="line">  <span class="string">&#x27;Julius&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Caesar&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Consul&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;of the Roman Republic&#x27;</span></span><br><span class="line">]</span><br><span class="line"><span class="comment">//  rest 就是剩下元素的数组集合</span></span><br></pre></td></tr></table></figure><p>我们也能使用<code>...</code>去快速浅拷贝或者赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldArr = [<span class="string">&#x27;yueyun&#x27;</span>, <span class="string">&#x27;meigumi&#x27;</span>, <span class="string">&#x27;kurumi&#x27;</span>, <span class="string">&#x27;explosion&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> newArr = [...oldArr]</span><br></pre></td></tr></table></figure><p>默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [name = <span class="string">&#x27;yueyun&#x27;</span>, age = <span class="number">18</span>] = [<span class="string">&#x27;yueyun2&#x27;</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">// yueyun</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// 18 而不是undefined</span></span><br></pre></td></tr></table></figure><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>解构赋值同样适用于对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本情况是</span></span><br><span class="line"><span class="keyword">const</span> &#123; v1, v2 &#125; = &#123; <span class="attr">v1</span>: <span class="string">&#x27;...&#x27;</span>, <span class="attr">v2</span>: <span class="string">&#x27;...&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  <span class="title class_">Dom</span>: <span class="string">&#x27;Nav&#x27;</span>,</span><br><span class="line">  <span class="title class_">Height</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">width</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="title class_">Dom</span>, <span class="title class_">Height</span>, <span class="title class_">Width</span> &#125; = options</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Dom</span>, <span class="title class_">Height</span>, <span class="title class_">Width</span>)</span><br></pre></td></tr></table></figure><p>属性 <code>options.title</code>、<code>options.width</code> 和 <code>options.height</code> 值被赋给了对应的变量。<strong>变量的顺序并不重要</strong></p><p>可以取别名映射 也可以默认赋值 也可以使用 … 去解构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Menu&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">width</span>: w = <span class="number">100</span>, <span class="attr">height</span>: h = <span class="number">200</span>, title &#125; = options</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(title) <span class="comment">// Menu</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(w) <span class="comment">// 100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h) <span class="comment">// 200</span></span><br></pre></td></tr></table></figure><div class="note info simple"><p>注意使用声明 (javascript 代码块)</p></div><h3 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h3><p>建议不要使用捏 会让简单的变得很烦</p><h3 id="智能函数参数"><a href="#智能函数参数" class="headerlink" title="智能函数参数"></a>智能函数参数</h3><p>有这样的场景 一个函数需要接受很多参数 而且大部分参数都是可选的<br>下面是很糟糕的写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMenu</span>(<span class="params">title = <span class="string">&#x27;Untitled&#x27;</span>, width = <span class="number">200</span>, height = <span class="number">100</span>, items = []</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际开发中，记忆如此多的参数的位置是一个很大的负担。通常集成开发环境（IDE）会尽力帮助我们，特别是当代码有良好的文档注释的时候，但是…… 另一个问题就是，在大部分的参数只需采用默认值的情况下，调用这个函数时会需要写大量的 undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在采用默认值就可以的位置设置 undefined</span></span><br><span class="line"><span class="title function_">showMenu</span>(<span class="string">&#x27;My Menu&#x27;</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, [<span class="string">&#x27;Item1&#x27;</span>, <span class="string">&#x27;Item2&#x27;</span>])</span><br></pre></td></tr></table></figure><p>这太难看了。而且，当我们处理更多参数的时候可读性会变得很差。</p><p>解构赋值可以解决这些问题。我们可以用一个对象来传递所有参数，而函数负责把这个对象解构成各个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们传递一个对象给函数</span></span><br><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;My menu&#x27;</span>,</span><br><span class="line">  <span class="attr">items</span>: [<span class="string">&#x27;Item1&#x27;</span>, <span class="string">&#x27;Item2&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……然后函数马上把对象解构成变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showMenu</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  title = <span class="string">&#x27;Untitled&#x27;</span>,</span></span><br><span class="line"><span class="params">  width = <span class="number">200</span>,</span></span><br><span class="line"><span class="params">  height = <span class="number">100</span>,</span></span><br><span class="line"><span class="params">  items = []</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// title, items – 提取于 options，</span></span><br><span class="line">  <span class="comment">// width, height – 使用默认值</span></span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;title&#125;</span> <span class="subst">$&#123;width&#125;</span> <span class="subst">$&#123;height&#125;</span>`</span>) <span class="comment">// My Menu 200 100</span></span><br><span class="line">  <span class="title function_">alert</span>(items) <span class="comment">// Item1, Item2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showMenu</span>(options)</span><br></pre></td></tr></table></figure><p>我们也可以使用带有嵌套对象和冒号映射的更加复杂的解构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;My menu&#x27;</span>,</span><br><span class="line">  <span class="attr">items</span>: [<span class="string">&#x27;Item1&#x27;</span>, <span class="string">&#x27;Item2&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showMenu</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  title = <span class="string">&#x27;Untitled&#x27;</span>,</span></span><br><span class="line"><span class="params">  width: w = <span class="number">100</span>, // width goes to w</span></span><br><span class="line"><span class="params">  height: h = <span class="number">200</span>, // height goes to h</span></span><br><span class="line"><span class="params">  items: [item1, item2] // items first element goes to item1, second to item2</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;title&#125;</span> <span class="subst">$&#123;w&#125;</span> <span class="subst">$&#123;h&#125;</span>`</span>) <span class="comment">// My Menu 100 200</span></span><br><span class="line">  <span class="title function_">alert</span>(item1) <span class="comment">// Item1</span></span><br><span class="line">  <span class="title function_">alert</span>(item2) <span class="comment">// Item2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showMenu</span>(options)</span><br></pre></td></tr></table></figure><p>完整语法和解构赋值是一样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  incomingProperty: varName = defaultValue</span></span><br><span class="line"><span class="params">  ...</span></span><br><span class="line"><span class="params">&#125;</span>)</span><br></pre></td></tr></table></figure><p>我们可以通过指定空对象 <code>&#123;&#125;</code> 为整个参数对象的默认值来解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMenu</span>(<span class="params">&#123; title = <span class="string">&#x27;Menu&#x27;</span>, width = <span class="number">100</span>, height = <span class="number">200</span> &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;title&#125;</span> <span class="subst">$&#123;width&#125;</span> <span class="subst">$&#123;height&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showMenu</span>() <span class="comment">// Menu 100 200</span></span><br></pre></td></tr></table></figure><h2 id="JSON-方法-toJSON"><a href="#JSON-方法-toJSON" class="headerlink" title="JSON 方法 toJSON"></a>JSON 方法 toJSON</h2><p>javascript 的一些数据结构是属于独有的 当传输网络数据或者在日志输出的时候需要传输数据</p><h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/JSON">JSON</a>（JavaScript Object Notation）是表示值和对象的通用格式。在 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc4627">RFC 4627</a> 标准中有对其的描述。最初它是为 JavaScript 而创建的，但许多其他编程语言也有用于处理它的库。因此，当客户端使用 JavaScript 而服务器端是使用 Ruby&#x2F;PHP&#x2F;Java 等语言编写的时，使用 JSON 可以很容易地进行数据交换。</p><p>JavaScript 提供了如下方法：</p><ul><li><code>JSON.stringify</code> 将对象转换成<code>JSON</code></li><li><code>JSON.parse</code> 将 JSON 转换成对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> student = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">isAdmin</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">courses</span>: [<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;js&#x27;</span>],</span><br><span class="line">  <span class="attr">spouse</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> json = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(student)</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> json) <span class="comment">// we&#x27;ve got a string!</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(json)</span><br><span class="line"><span class="comment">/* JSON 编码的对象：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;name&quot;: &quot;John&quot;,</span></span><br><span class="line"><span class="comment">  &quot;age&quot;: 30,</span></span><br><span class="line"><span class="comment">  &quot;isAdmin&quot;: false,</span></span><br><span class="line"><span class="comment">  &quot;courses&quot;: [&quot;html&quot;, &quot;css&quot;, &quot;js&quot;],</span></span><br><span class="line"><span class="comment">  &quot;spouse&quot;: null</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>方法<code>JSON.stingify(stduent)</code>接受对象并将其转换成字符串</p><p>得到的<code>JSON</code>字符串是一个被称之为<strong>JSON 编码（JSON-encoded）或 序列化 或 字符串化 或 编组化的对象</strong><br><code>JSON.stringify</code> 也可以应用于原始（primitive）数据类型。</p><p>JSON 支持的数据类型：</p><ul><li>Objects <code>&#123; ... &#125;</code></li><li>Arrays <code>[ ... ]</code></li><li>Primitives：<ul><li>strings，</li><li>numbers，</li><li>boolean values <code>true/false</code>，</li><li><code>null</code></li></ul></li></ul><p>JSON 是语言无关的纯数据规范，因此一些特定于 JavaScript 的对象属性会被 <code>JSON.stringify</code> 跳过。即:</p><ul><li>函数属性（方法）。</li><li>Symbol 类型的键和值。</li><li>存储 <code>undefined</code> 的属性。</li></ul><p>支持嵌套对象转换 但是不能循环引用<br><code>JSON.stringify</code>的完整语法是<br><code>let json = JSON.stringify(value,replacer, space)</code><br>value:要编码的值、replacer:要编码属性数组活映射函数、space:用于美化输出的空格数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> room = &#123;</span><br><span class="line">  <span class="attr">number</span>: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Conference&#x27;</span>,</span><br><span class="line">  <span class="attr">participants</span>: [&#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;],</span><br><span class="line">  <span class="attr">place</span>: room <span class="comment">// meetup 引用了 room</span></span><br><span class="line">&#125;</span><br><span class="line">room.<span class="property">occupiedBy</span> = meetup <span class="comment">// room 引用了 meetup</span></span><br><span class="line"><span class="comment">// console.log(meetup)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(meetup, <span class="keyword">function</span> <span class="title function_">replacer</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>, type: <span class="subst">$&#123;<span class="keyword">typeof</span> value&#125;</span>`</span>)</span><br><span class="line">    <span class="comment">// return key != &#x27;&#x27; &amp;&amp; value == meetup ? undefined : value</span></span><br><span class="line">    <span class="keyword">return</span> key == <span class="string">&#x27;occupiedBy&#x27;</span> ? <span class="literal">undefined</span> : value</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  0: [object Object], type: object</span></span><br><span class="line"><span class="comment">  name: John, type: string</span></span><br><span class="line"><span class="comment">  1: [object Object], type: object</span></span><br><span class="line"><span class="comment">  name: Alice, type: string</span></span><br><span class="line"><span class="comment">  place: [object Object], type: object</span></span><br><span class="line"><span class="comment">  number: 23, type: number</span></span><br><span class="line"><span class="comment">  occupiedBy: [object Object], type: object</span></span><br><span class="line"><span class="comment">  &#123;&quot;title&quot;:&quot;Conference&quot;,&quot;participants&quot;:[&#123;&quot;name&quot;:&quot;John&quot;&#125;,&#123;&quot;name&quot;:&quot;Alice&quot;&#125;],&quot;place&quot;:&#123;&quot;number&quot;:23&#125;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h3><p>要解码 JSON 字符串 需要使用<code>JSON.parse</code>方法<br><code>let value = JSON.parse(str,reviver)</code><br>str:要解析的 JSON 字符串、reviver:可选的函数，将为每个（键，值）对调用此函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串化数组</span></span><br><span class="line"><span class="keyword">let</span> numbers = <span class="string">&#x27;[0, 1, 2, 3]&#x27;</span></span><br><span class="line">numbers = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(numbers)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers[<span class="number">1</span>]) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> userData =</span><br><span class="line">  <span class="string">&#x27;&#123; &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 35, &quot;isAdmin&quot;: false, &quot;friends&quot;: [0,1,2,3] &#125;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(userData)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">friends</span>[<span class="number">1</span>]) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 反序列化的时候如果遇到特殊对象会调用reviver函数</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&#123;&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2017-11-30T12:00:00.000Z&quot;&#125;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> meetup = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str, <span class="keyword">function</span> (<span class="params">key, value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key == <span class="string">&#x27;date&#x27;</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(value)</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(meetup.<span class="property">date</span>.<span class="title function_">getDate</span>()) <span class="comment">// 现在正常运行了！</span></span><br></pre></td></tr></table></figure><details class="folding-tag"><summary>总结</summary><div class="content"><ul><li>JSON 是一种数据格式，具有自己的独立标准和大多数编程语言的库。</li><li>JSON 支持 object，array，string，number，boolean 和 null。</li><li>JavaScript 提供序列化（serialize）成 JSON 的方法 JSON.stringify 和解析 JSON 的方法 JSON.parse。</li><li>这两种方法都支持用于智能读&#x2F;写的转换函数。</li><li>如果一个对象具有 toJSON，那么它会被 JSON.stringify 调用。</li></ul></div></details><h1 id="规范和调试"><a href="#规范和调试" class="headerlink" title="规范和调试"></a>规范和调试</h1><h1 id="高级内容"><a href="#高级内容" class="headerlink" title="高级内容"></a>高级内容</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>在函数解决任务时 调用了<strong>自身</strong>就是所谓的递归</p><p>比如想在要完成一个函数<code>pow(x, n)</code>可以计算<code>x</code>的<code>n</code>次方 有两种解法</p><ol><li><p>迭代思路 使用<code>for</code>循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pow</span>(<span class="params">x, n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    result *= x</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>递归思路：简化任务 调用自身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pow</span>(<span class="params">x, n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="title function_">pow</span>(x, n - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>当<code>pow(x, n)被调用时 执行分为下面两个分支：</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">              <span class="keyword">if</span> n==<span class="number">1</span>  = x</span><br><span class="line">             /</span><br><span class="line"><span class="title function_">pow</span>(x, n) =</span><br><span class="line">             \</span><br><span class="line">              <span class="keyword">else</span>     = x * <span class="title function_">pow</span>(x, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>当 <code>n===1</code>时 叫做<strong>基础</strong>递归 因为会产生明显的结果</li><li>可以使用 <code>x * pow(x, n - 1)</code>表示<code>pow(x, n)</code> 这就<strong>递归步骤</strong>将人物转化为更简单的行为和更简单的同类任务调用 （带有更小的 <code>n</code> 的 <code>pow</code> 运算）。接下来的步骤将其进一步简化，直到 <code>n</code> 达到 <code>1</code>。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/javascriptlearing/01.png"></p><p>递归将函数调用简化成为一个更简单的函数调用 然后在将其简化为一个更加简单的函数 以此类推 直到结果变得显而易见</p><p>最大的嵌套调用次数(包括首次)被称为<strong>递归深度</strong> 在上面这个例子正好为 n</p><h4 id="执行上下文和堆栈"><a href="#执行上下文和堆栈" class="headerlink" title="执行上下文和堆栈"></a><strong>执行上下文和堆栈</strong></h4><p>递归调用的工作 函数底层的工作原理</p><p>有关正在运行的函数的执行过程的相关信息被存储在其执行上下文中</p><p>执行上下文是一个内部据结构 他包含有关函数执行时的详细细节：</p><ul><li>当前控制流所在的位置 (作用域链)：每个执行上下文都有一个与之相关联的作用域链。作用域链是一个对象列表，它定义了变量和函数的查找规则，决定了代码在哪些区域是有效的。当代码在一个执行上下文中查找变量时，如果在当前上下文的变量对象中找不到，它会沿着作用域链向上查找。</li><li>当前的变量：包含函数的参数、局部变量、函数声明、变量声明 在函数执行的初始阶段 函数所有的参数值、函数内部的函数声明以及变量声明都会被添加到变量对象中。</li><li><code>this</code>的值：表示调用上下文，依赖于函数的调用方式 全局执行上下文 函数执行上下文(如何被调用)</li><li>及内部的一些细节</li></ul><p>一个函数调用仅具有一个与其关联的执行上下文</p><p>当一个函数进行嵌套调用的时候 将发生</p><ul><li>当前函数被暂停</li><li>与它关联的执行上下文被一个叫做<code>执行上下文堆栈</code>而特殊数据结构保存</li><li>执行嵌套调用</li><li>嵌套调用结束后 从堆栈中恢复之前的执行上下文 并从停止的位置恢复外部函数</li></ul><p>比如现在来分析上面 <code>pow(2,3)</code> 这个例子 使用抽象的来表示一下执行流程</p><ol><li><p>在调用<code>pow(2, 3)</code>而开始，执行上下文(context)会储存变量：<code>x = 2, n = 3</code> 执行流程在函数而第一行我们将其定义为<br><strong><code>Context： &#123; x:2, n:3, at line 1 &#125;</code> call pow(2, 3)</strong><br>当函数开始执行的时 进入第二条分支 变量相同但是位置改变了<br>**<code>Context： &#123; x:2, n:3, at line 5 &#125;</code> call pow(2, 3) **</p><p>执行到计算 <code>x * pow(x, n - 1)</code> 需要带入新的参数新的<code>pow</code>子调用<code>pow(2,2)</code></p></li><li><p>为了执行嵌套调用，JavaScript 会在 <strong>执行上下文堆栈</strong> 中记住当前的执行上下文。</p><p>这里我们调用相同的函数 <code>pow</code>，但这绝对没问题。所有函数的处理都是一样的：</p><ol><li>当前上下文被“记录”在堆栈的顶部。</li><li>为子调用创建新的上下文。</li><li>当子调用结束后 —— 前一个上下文被从堆栈中弹出，并继续执行。</li></ol><p>下面是进入子调用<code>pow(2, 2)</code>时的上下文堆栈：</p><p>**<code>Context： &#123; x:2, n:2, at line 5 &#125;</code> call pow(2, 2) **<br>**<code>Context： &#123; x:2, n:3, at line 5 &#125;</code> call pow(2, 3) **<br>当我们完成了子调用后 很容易恢复一个上下文 因为它既保留了变量 也保留了当时代码的确切位置</p></li><li><p>执行<code>pow(2, 1)</code> 重复过程 现在的调用堆栈<br><code>Context： &#123; x:2, n:1, at line 5 &#125;</code> call pow(2, 1)</p><p>**<code>Context： &#123; x:2, n:2, at line 5 &#125;</code> call pow(2, 2) **<br>**<code>Context： &#123; x:2, n:3, at line 5 &#125;</code> call pow(2, 3) **</p></li><li><p>出口 即使调用堆栈 出栈口</p></li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/javascriptlearing/02.png"></p><p>递归可以更加简单明了优雅的描述出一段代码的逻辑 虽然性能上可能不如循环但是在一些复杂的数据结构下面使用递归往往更好 (比如 树 链表等)</p><h3 id="Rest-参数和-Spread-语法"><a href="#Rest-参数和-Spread-语法" class="headerlink" title="Rest 参数和 Spread 语法"></a>Rest 参数和 Spread 语法</h3><p>简单来说就是</p><p><code>function sum (...args)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cosnt arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> arr1 = [...arr2,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure><h3 id="变量作用域和闭包"><a href="#变量作用域和闭包" class="headerlink" title="变量作用域和闭包"></a>变量作用域和闭包</h3><p><code>JavaScript</code>是非常面向对象和函数的语言 会有很大的自由度和写法 我们可以随时创建函数可以将函数作为参数传递 在任意不同的代码位置调用 可以访问外部的环境</p><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>如果在<code>&#123; ... &#125;</code>内声明变量 那么这个变量并不会向外传递 只能在内部访问该代码块内可见</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2a&#x27;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>, a)</span><br><span class="line"><span class="comment">// 2a 20</span></span><br><span class="line"><span class="comment">// a 10</span></span><br></pre></td></tr></table></figure><p>在<code>if</code>, <code>for</code>, <code>while</code> 中 <code>&#123;...&#125;</code>中声明的变量也仅在内部可见</p><h4 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h4><p>如果一个函数在另外一个函数中创建的 被称为高级函数或者嵌套函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHiBye</span>(<span class="params">firstName, lastName</span>) &#123;</span><br><span class="line">  <span class="comment">// 辅助嵌套函数使用如下</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getFullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + <span class="title function_">getFullName</span>())</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Bye, &#x27;</span> + <span class="title function_">getFullName</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h4><p><strong>变量:</strong><br>在 Javascript 中每个 运行的函数 代码块 <code>&#123; ... &#125;</code> 以及整个脚本都有一个被称为词法**环境(Lexical Enviroment)**的内部的关联对象</p><p>该词法环境对象由两部分组成:</p><ul><li>环境记录(Enviroment Record) 一个存储所有局部变量作为其属性 (包括一些其他的信息 例如<code>this</code>的值)的对象</li><li>对<strong>外部词法环境</strong>的引用 与外部代码相关联</li></ul><p>一个变量只是**”环境记录”**这个特殊的内部对象的一个属性 获取或修改变量一味着获取或修改词法环境的一个属性 “获取或修改变量” 意味着 获取或修改词法环境的一个属性</p><p>比如下面的一个最简单的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> phrase = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(phrase)</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/javascriptlearing/03.png"></p><p>这个就是所谓的与整个脚本相关联的<strong>全局词法环境</strong></p><p>在上面的过程中 矩形区域表示环境记录(变量存储) 箭头表示外部引用 全局词法环境没有外部引用 所以箭头指向了<code>null</code></p><p>随着代码的开始继续的执行 词法环境发生了变化<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/javascriptlearing/04.png"></p><p>上面的图片中右侧演示了执行过程中词法环境的变化:</p><ol><li>当脚本开始运行 词法环境先填充了所有声明的变量<br>在最初 它们处于<strong>未初始化的状态</strong>这是一种特殊的内部状态 这意味着引擎知道这个变量存在但是在 let 声明之前 不能引用它 几乎就跟不存在一样</li><li><code>let phrase</code> 定义出现 尚未被赋值 因此值是<strong>undefined</strong></li><li><code>phrase</code>被赋予了一个值</li><li><code>phrase</code>被修改</li></ol><p>实际上执行的过程是</p><ul><li>变量是特殊内部对象的属性 与当前正在执行的**(代码)块&#x2F;函数&#x2F;脚本** 有关</li><li>操作变量实际上是操作该对象的属性</li></ul><div class="note info simple"><p>词法环境是一个规范的对象 是存在于<code>语言规范</code>的理论层面 用于描述是如何工作的 我们无法在代码块中获取该对象并直接进行操作</p></div><p><strong>函数声明:</strong></p><p>一个函数其实就是一个值 就像变量一样</p><p><strong>不同就在于 如果是函数声明的初始化会被立刻完成</strong></p><p>当创建了一个词法环境时,函数会立即变成即用型函数( 并不像 let 那样到声明处才可以去使用)<br>例如 下面是添加一个函数时全局词法环境的初始状态</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/javascriptlearing/05.png"></p><div class="note info simple"><p>这种行为仅适用于函数声明 而不适用于匿名函数的声明 比如<code>let sayHello = function () {...}</code> 或者 <code>let sayhello = () =&gt; {...}</code></p></div><p><strong>内部和外部的词法环境</strong><br>当一个函数运行时 在调用刚开始 会自动创建一个新的词法环境以存储这个调用的局部变量和参数 例如对于<code>say(&quot;yueyun&quot;)</code> 的执行流程如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> phrase = <span class="string">&#x27; Hello &#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">say</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  cosole.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;phrase&#125;</span>, <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">say</span>(<span class="string">&#x27;yueyun&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/javascriptlearing/06.png"></p><p>在函数调用期间我们拥有两个词法环境 内部一个(用于函数调用) 和外部一个(全局)：</p><ul><li>内部词法环境与<code>say</code>的当前执行相对应 它具有单独的属性：<code>name</code> 函数的参数 调用的是<code>say(&quot;yueyun&quot;)</code>所以<code>name</code>的值为<code>yueyun</code></li><li>外部词法环境是全局词法环境 它具有<code>phrase</code>变量和函数本身</li></ul><p>内部词法环境引用了<code>outer</code></p><p><strong>当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。</strong></p><p><strong>返回函数：</strong></p><p>比如下面的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter = <span class="title function_">makeCounter</span>()</span><br></pre></td></tr></table></figure><p>在每次<code>makeCounter()</code>调用的开始，都会创建一个新的词法环境对象，以存储该<code>makeCounter</code>运行时的变量</p><p>因此，我们有两层嵌套的词法环境</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/javascriptlearing/07.png"></p><p>不一样的是 在执行 <code>makeCounter()</code>的过程中创建了一个仅占一行的嵌套函数 <code>return count++</code> 我们并没有运行它 只是创建了这么一个函数</p><p>所有的函数在创建时都会记住它的词法环境 从技术上来说 所有的函数都有名为<code>[[Environment]]</code>的隐藏属性 该属性保存了对创建对象该函数的词法环境的应引用<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/javascriptlearing/08.png"></p><p>因此 counter.[[Env]] 有对 {<code>count: 0</code>}词法环境的引用 这就是函数记住它创建于何处的方式与调用无关 <code>[[Environment]]</code> 引用在函数创建时被设置并永久保存。</p><p>稍后调用<code>counter()</code>时，会自动创建一个新的词法环境 并且其外部词法环境引用获取于<code>counter.[[Environment]]</code></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/javascriptlearing/09.png"></p><p>现在，当 <code>counter()</code> 中的代码查找 <code>count</code> 变量时，它首先搜索自己的词法环境（为空，因为那里没有局部变量），然后是外部 <code>makeCounter()</code> 的词法环境，并且在哪里找到就在哪里修改。</p><p><strong>在变量所在的词法环境中更新变量</strong></p><p>如果我们调用 <code>counter()</code> 多次，<code>count</code> 变量将在同一位置增加到 <code>2</code>，<code>3</code> 等。</p><div class="note info simple"><p>闭包是一个编程术语 是指一个函数可以记住其他外部变量并可以访问这些变量 在某些编程语言中 会有不同的差异 但在<strong>Javascript</strong>中 所有的函数天生都是闭包的 即<code>JavaScirpt</code>中的函数会自动通过隐藏<code>[[Environment]]</code>属性记住创建它们的位置 所以它们都可以访问外部变量</p></div><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>通常，函数调用完成后，会将词法环境和其中的所有变量从内存中删除。因为现在没有任何对它们的引用了。与 JavaScript 中的任何其他对象一样，词法环境仅在可达时才会被保留在内存中。</p><p>但是 如果有一个嵌套函数在函数结束后的语句任然可达 则它将具有引用词法环境的 <code>[[Environment]]</code> 属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">f</span>() <span class="comment">// g.[[Environment]] 存储了对相应 f() 调用的词法环境的引用</span></span><br></pre></td></tr></table></figure><p>如果多次调用 <code>f()</code>，并且返回的函数被保存，那么所有相应的词法环境对象也会保留在内存中。下面代码中有三个这样的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="title class_">Math</span>.<span class="title function_">random</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中的 3 个函数，每个都与来自对应的 f() 的词法环境相关联</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="title function_">f</span>(), <span class="title function_">f</span>(), <span class="title function_">f</span>()]</span><br></pre></td></tr></table></figure><p>当词法环境对象变得不可达时，它就会死去（就像其他任何对象一样）。换句话说，它仅在至少有一个嵌套函数引用它时才存在。</p><p>在下面的代码中，嵌套函数被删除后，其封闭的词法环境（以及其中的 <code>value</code>）也会被从内存中删除：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">f</span>() <span class="comment">// 当 g 函数存在时，该值会被保留在内存中</span></span><br><span class="line"></span><br><span class="line">g = <span class="literal">null</span> <span class="comment">// ……现在内存被清理了</span></span><br></pre></td></tr></table></figure><h3 id="全局对象和函数对象"><a href="#全局对象和函数对象" class="headerlink" title="全局对象和函数对象"></a>全局对象和函数对象</h3><h4 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h4><p>全局对象提供可以在任何地方都使用的变量和函数 默认的情况下这些全局变量内建于语言或环境中</p><p>在浏览器环境中 全局对象是<code>window</code> 对于<code>nodejs</code>运行时环境 全局对象是<code>global</code></p><p>在最新的规定中<code>globalThis</code> 被作为全局对象的标准名称加入到了 JavaScript 中，所有环境都应该支持该名称。所有主流浏览器都支持它。</p><p>全局对象的所有属性都可以直接被访问</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在浏览器中 使用<code>var</code>声明的全局函数和变量都会成为全局属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gVar = <span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">gVar</span>)</span><br></pre></td></tr></table></figure><p>请不要这样去使用！这种行为是出于兼容性而存在的。现代脚本使用 <a target="_blank" rel="noopener" href="https://zh.javascript.info/modules">JavaScript modules</a> 所以不会发生这种事情。</p><p>如果我们使用 <code>let</code>，就不会发生这种情况</p><p>如果一个值非常重要你想让它在全局的范围中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前用户信息全局化，以允许所有脚本访问它</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">currentUser</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;yueyun&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码中的另一个位置</span></span><br><span class="line"><span class="title function_">alert</span>(currentUser.<span class="property">name</span>) <span class="comment">// yueyun</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者，如果我们有一个名为 &quot;currentUser&quot; 的局部变量</span></span><br><span class="line"><span class="comment">// 从 window 显式地获取它（这是安全的！）</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">window</span>.<span class="property">currentUser</span>.<span class="property">name</span>) <span class="comment">// yueyun</span></span><br></pre></td></tr></table></figure><h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h4><p>在 JavaScript 中函数也是一个值，函数值的类型是 <code>object</code></p><p>可以把函数理解成为一个可调用的<strong>行为对象(action object)</strong> 同样可以传递属性和引用传递</p><p>比如属性 name</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayHi, sayHi.<span class="property">name</span>) <span class="comment">//[Function: sayHi] sayHi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//***********************************************************</span></span><br><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayHi.<span class="property">name</span>) <span class="comment">// sayHi（有名字！）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//***********************************************************</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">sayHi = <span class="keyword">function</span> () &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(sayHi.<span class="property">name</span>) <span class="comment">// sayHi（生效了！）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br></pre></td></tr></table></figure><p>规范中把这种特性叫做「上下文命名」。如果函数自己没有提供，那么在赋值中，会根据上下文来推测一个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">sayBye</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">sayHi</span>.<span class="property">name</span>) <span class="comment">// sayHi</span></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">sayBye</span>.<span class="property">name</span>) <span class="comment">// sayBye</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数是在数组中创建的</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;]</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(arr[<span class="number">0</span>].<span class="property">name</span>) <span class="comment">// &lt;空字符串&gt;</span></span><br><span class="line"><span class="comment">// 引擎无法设置正确的名字，所以没有值</span></span><br></pre></td></tr></table></figure><p>属性 length</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params">a</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params">a, b</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">many</span>(<span class="params">a, b, ...more</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(f1.<span class="property">length</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">alert</span>(f2.<span class="property">length</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">alert</span>(many.<span class="property">length</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>属性 <code>length</code> 有时在操作其它函数的函数中用于做 <strong>内省&#x2F;运行时检查（introspection）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ask</span>(<span class="params">question, ...handlers</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> isYes = <span class="title function_">confirm</span>(question)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> handler <span class="keyword">of</span> handlers) &#123;</span><br><span class="line">    <span class="keyword">if</span> (handler.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isYes) <span class="title function_">handler</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">handler</span>(isYes)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于肯定的回答，两个 handler 都会被调用</span></span><br><span class="line"><span class="comment">// 对于否定的回答，只有第二个 handler 被调用</span></span><br><span class="line"><span class="title function_">ask</span>(</span><br><span class="line">  <span class="string">&#x27;Question?&#x27;</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="title function_">alert</span>(<span class="string">&#x27;You said yes&#x27;</span>),</span><br><span class="line">  <span class="function">(<span class="params">result</span>) =&gt;</span> <span class="title function_">alert</span>(result)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>自定义属性</p><p>我们可以在函数中添加<code>counter</code>属性记录被调用了多少次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi&#x27;</span>)</span><br><span class="line">  sayHi.<span class="property">counter</span>++</span><br><span class="line">&#125;</span><br><span class="line">sayHi.<span class="property">counter</span> = <span class="number">0</span> <span class="comment">// 初始值</span></span><br><span class="line"><span class="title function_">sayHi</span>() <span class="comment">// Hi</span></span><br><span class="line"><span class="title function_">sayHi</span>() <span class="comment">// Hi</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">`Called <span class="subst">$&#123;sayHi.counter&#125;</span> times`</span>) <span class="comment">// Called 2 times</span></span><br></pre></td></tr></table></figure><div class="note warning simple"><p>属性并不是变量，被赋值给函数的属性，比如 <code>sayHi.counter = 0</code>，<strong>不会</strong> 在函数内定义一个局部变量 <code>counter</code>。换句话说，属性 <code>counter</code> 和变量 <code>let counter</code> 是毫不相关的两个东西。</p></div><p>函数属性有时会用来替代闭包 如下面修改之前写过的闭包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> counter.<span class="property">count</span>++</span><br><span class="line">  &#125;</span><br><span class="line">  counter.<span class="property">count</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> counter</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter = <span class="title function_">makeCounter</span>()</span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">counter</span>()) <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">counter</span>()) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>即<code>count</code>被直接存储在函数里，而不是它外部的词法环境</p><p>这种写法一般不太常见 因为可以在外部去修改它的属性 从而导致代码很混乱</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> counter.<span class="property">count</span>++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  counter.<span class="property">count</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="title function_">makeCounter</span>()</span><br><span class="line"><span class="comment">// 可以任意的修改</span></span><br><span class="line">counter.<span class="property">count</span> = <span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter</span>()) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h4 id="命名函数的表达式"><a href="#命名函数的表达式" class="headerlink" title="命名函数的表达式"></a>命名函数的表达式</h4><p>命名函数表达式(NFE, Named Function Expression) 指带有名字的函数表达式术语</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">who</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;who&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它仍然是一个函数表达式。在 <code>function</code> 后面加一个名字 <code>&quot;func&quot;</code> 没有使它成为一个函数声明，因为它仍然是作为赋值表达式中的一部分被创建的。</p><p>添加这个名字当然也没有打破任何东西。函数依然可以通过 <code>sayHi()</code> 来调用：</p><p>关于添加<code>func</code>的两个特殊的地方</p><ul><li>允许函数在内部引用自己</li><li>它在函数外是引用不到的</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">who</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (who) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`Hello, <span class="subst">$&#123;who&#125;</span>`</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">func</span>(<span class="string">&#x27;Guest&#x27;</span>) <span class="comment">// 使用 func 再次调用函数自身</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHi</span>() <span class="comment">// Hello, Guest</span></span><br><span class="line"><span class="comment">// 但这不工作：</span></span><br><span class="line"><span class="title function_">func</span>() <span class="comment">// Error, func is not defined（在函数外不可见）</span></span><br></pre></td></tr></table></figure><p>同样不适用<code>sayHi()</code>去写递归 因为 <code>sayHi()</code>很容易就被外部污染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">function</span> (<span class="params">who</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (who) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;who&#125;</span>`</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">sayHi</span>(<span class="string">&#x27;Guest&#x27;</span>) <span class="comment">// Error: sayHi is not a function</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> welcome = sayHi</span><br><span class="line">sayHi = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">welcome</span>() <span class="comment">// Error，嵌套调用 sayHi 不再有效！</span></span><br></pre></td></tr></table></figure><p>当我们需要一个可靠的内部名时，这就成为了你把函数声明重写成函数表达式的理由了。</p><h3 id="调度：setTimeout-和-setInterval"><a href="#调度：setTimeout-和-setInterval" class="headerlink" title="调度：setTimeout 和 setInterval"></a>调度：setTimeout 和 setInterval</h3><p>当我们并不想立刻执行一个函数，而是等待特定一段时间之后再执行。这就是所谓的“计划调用（scheduling a call）”。</p><p>目前的实现方式有下面两种方式实现</p><ul><li><code>setTimeout</code>: 允许我们将函数推迟到一段时间间隔之后再执行</li><li><code>setInterval</code>: 允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数。</li></ul><p><strong>setTimeout</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">function</span> (<span class="params">who</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    count++</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;who&#125;</span>! <span class="subst">$&#123;count&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="title function_">sayHi</span>(<span class="string">&#x27;yueyun&#x27;</span>), <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p><code>setTimeout</code> 期望得到一个对函数的引用</p><p><strong>clearTimeout 来取消调度</strong></p><p><code>setTimeout</code> 在调用时会返回一个“定时器标识符（timer identifier）”，在我们的例子中是 <code>timerId</code>，我们可以使用它来取消执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timerId = <span class="built_in">setTimeout</span>(...);</span><br><span class="line"><span class="built_in">clearTimeout</span>(timerId);</span><br></pre></td></tr></table></figure><p><strong>setInterval</strong></p><p><code>setInterval</code> 方法和 <code>setTimeout</code> 的语法相同：不过与 <code>setTimeout</code> 只执行一次不同，<code>setInterval</code> 是每间隔给定的时间周期性执行。</p><h3 id="装饰器模式和转发：Call-apply"><a href="#装饰器模式和转发：Call-apply" class="headerlink" title="装饰器模式和转发：Call&#x2F;apply"></a>装饰器模式和转发：Call&#x2F;apply</h3><p><strong>JavaScript</strong>在处理函数时提供了很高的灵活性，它们可以被传递 用作对象 下面将介绍它们之间的<code>转发(forward)</code>和<code>装饰(decorate)</code></p><h5 id="透明缓存"><a href="#透明缓存" class="headerlink" title="透明缓存"></a>透明缓存</h5><p>假设现在我们有一个 CPU 重负载的函数<code>slow(x)</code> 但是他纯函数 给定相同的参数总是会返回相同的结果 如果这个函数使用频繁 我们希望能记住这个缓存能记住 因此避免花费额外的时间 如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">slow</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="comment">// big Clc</span></span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cachingDecorator</span>(<span class="params">func</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.<span class="title function_">has</span>(x)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.<span class="title function_">get</span>(x) <span class="comment">// 从缓存中读取结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="title function_">func</span>(x)</span><br><span class="line">    cache.<span class="title function_">set</span>(x, result) <span class="comment">// 将结果记录下来</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">slow = <span class="title function_">cachingDecorator</span>(slow)</span><br><span class="line">consle.<span class="title function_">log</span>(<span class="title function_">slow</span>(<span class="number">1</span>)) <span class="comment">// 被缓存下 并返回结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Again&#x27;</span>, <span class="title function_">slow</span>(<span class="number">1</span>)) <span class="comment">//返回缓存记录的结果</span></span><br></pre></td></tr></table></figure><p>在上面的例子中 <code>cachingDecorator</code>是一个<strong>装饰器(decorator)</strong></p><p>这样我们可以为任何函数调用<code>cachingDecorator</code> 它将返回缓存包装器 这样别的函数需要这种特性就可以直接复用 还可以将缓存与主代码分开变得更加简单</p><p><code>cachingDecorator(func)</code> 的结果是一个“包装器”：<code>function(x)</code> 将 <code>func(x)</code> 的调用“包装”到缓存逻辑中 从外部代码来看，包装的 <code>slow</code> 函数执行的仍然是与之前相同的操作。它只是在其行为上添加了缓存功能。</p><p>使用分离的 <code>cachingDecorator</code> 而不是改变 <code>slow</code> 本身的代码有几个好处</p><ul><li><code>cachingDecorator</code> 是可重用的。我们可以将它应用于另一个函数。</li><li>缓存逻辑是独立的，它没有增加 <code>slow</code> 本身的复杂性（如果有的话）。</li><li>如果需要，我们可以组合多个装饰器（其他装饰器将遵循同样的逻辑）。</li></ul><h5 id="function-call-设定上下文"><a href="#function-call-设定上下文" class="headerlink" title="function.call 设定上下文"></a>function.call 设定上下文</h5><p>但是如果我们在对象中这样使用的话呢 如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = &#123;</span><br><span class="line">  <span class="title function_">someMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">slow</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="comment">// calc</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="variable language_">this</span>.<span class="title function_">someMethod</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cachingDecorator</span>(<span class="params">func</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.<span class="title function_">has</span>(x)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.<span class="title function_">get</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="title function_">func</span>(x) <span class="comment">// (*step*)</span></span><br><span class="line">    cache.<span class="title function_">set</span>(x, result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(worker.<span class="title function_">slow</span>(<span class="number">1</span>)) <span class="comment">// 原始方法有效</span></span><br><span class="line"></span><br><span class="line">worker.<span class="property">slow</span> = <span class="title function_">cachingDecorator</span>(worker.<span class="property">slow</span>) <span class="comment">// 现在对其进行缓存</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(worker.<span class="title function_">slow</span>(<span class="number">2</span>)) <span class="comment">// 报错！Error: Cannot read property &#x27;someMethod&#x27; of undefined</span></span><br></pre></td></tr></table></figure><p>错误在于试图访问<code>this.someMethod</code>失败了 原因是包装器将原始函数调用为 <code>(*step*)</code> 行中的 <code>func(x)</code>。但是这样调用得到的<code>this=undefined</code> 这是因为包装器将调用传递给原始方法 但是并没有上下文的<code>this</code></p><p>使用内建的函数方法<code>function.call(context,...args)</code>允许调用一个显示设置的<code>this</code>函数</p><p>例如，在下面的代码中，我们在不同对象的上下文中调用 <code>sayHi</code>：<code>sayHi.call(user)</code> 运行 <code>sayHi</code> 并提供了 <code>this=user</code>，然后下一行设置 <code>this=admin</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> admin = &#123; <span class="attr">name</span>: <span class="string">&#x27;Admin&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 call 将不同的对象传递为 &quot;this&quot;</span></span><br><span class="line">sayHi.<span class="title function_">call</span>(user) <span class="comment">// John</span></span><br><span class="line">sayHi.<span class="title function_">call</span>(admin) <span class="comment">// Admin</span></span><br></pre></td></tr></table></figure><p>在我们的例子中，我们可以在包装器中使用 <code>call</code> 将上下文传递给原始函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = &#123;</span><br><span class="line">  <span class="title function_">someMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">slow</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="comment">// calc</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="variable language_">this</span>.<span class="title function_">someMethod</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cachingDecorator</span>(<span class="params">func</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.<span class="title function_">has</span>(x)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.<span class="title function_">get</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = func.<span class="title function_">call</span>(<span class="variable language_">this</span>, x)</span><br><span class="line">    cache.<span class="title function_">set</span>(x, result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(worker.<span class="title function_">slow</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">worker.<span class="property">slow</span> = <span class="title function_">cachingDecorator</span>(worker.<span class="property">slow</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(worker.<span class="title function_">slow</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>现在一切工作正常 <code>this</code>的传递过程</p><ul><li>在经过装饰之后，<code>worker.slow</code> 现在是包装器 <code>function (x) &#123; ... &#125;</code>。</li><li>因此，当 <code>worker.slow(2)</code> 执行时，包装器将 <code>2</code> 作为参数，并且 <code>this=worker</code>（它是点符号 <code>.</code> 之前的对象）。</li><li>在包装器内部，假设结果尚未缓存，<code>func.call(this, x)</code> 将当前的 <code>this</code>（<code>=worker</code>）和当前的参数（<code>=2</code>）传递给原始方法。</li></ul><h5 id="传递多个参数"><a href="#传递多个参数" class="headerlink" title="传递多个参数"></a>传递多个参数</h5><p>记住参数组合(min,max)的结果</p><ul><li>实现一个新的类似于 map 的更通用的并且允许多个键的数据结构</li><li>使用嵌套的 map 去实现比如<code>map.get(min).get(max)</code>来获取 result</li><li>将两个值合并成一个 多为装饰器添加一个函数</li></ul><p>现在以第三种方法写出带多个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = &#123;</span><br><span class="line">  <span class="title function_">slow</span>(<span class="params">min, max</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> min + max</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cachingDecorator</span>(<span class="params">func</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// **</span></span><br><span class="line">    <span class="keyword">let</span> key = <span class="title function_">hash</span>(args)</span><br><span class="line">    <span class="keyword">if</span> (cache.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.<span class="title function_">get</span>(key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = func.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args) <span class="comment">//***</span></span><br><span class="line">    cache.<span class="title function_">set</span>(key, result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hash</span>(<span class="params">args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个包装器可以处理任意数量的参数了</p><ul><li>在 <code>(**)</code> 行中它调用 <code>hash</code> 来从 <code>arguments</code> 创建一个单独的键。这里我们使用一个简单的“连接”函数，将参数 <code>(3, 5)</code> 转换为键 <code>&quot;3,5&quot;</code>。更复杂的情况可能需要其他哈希函数。</li><li>然后 <code>(***)</code> 行使用 <code>func.call(this, ...arguments)</code> 将包装器获得的上下文和所有参数（不仅仅是第一个参数）传递给原始函数。</li></ul><h5 id="function-apply"><a href="#function-apply" class="headerlink" title="function.apply"></a>function.apply</h5><p><code>apply</code> 和 <code>call</code>的用法类似 区别就是 apply 希望接受的是一个参数列表而不是多个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,...args) === <span class="keyword">function</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>,args)</span><br></pre></td></tr></table></figure><h5 id="装饰器和属性函数"><a href="#装饰器和属性函数" class="headerlink" title="装饰器和属性函数"></a>装饰器和属性函数</h5><p>通常，用装饰的函数替换一个函数或一个方法是安全的，除了一件小东西。如果原始函数有属性，例如 <code>func.calledCount</code> 或其他，则装饰后的函数将不再提供这些属性。因为这是装饰器。因此，如果有人使用它们，那么就需要小心。</p><p>例如，在上面的示例中，如果 <code>slow</code> 函数具有任何属性，而 <code>cachingDecorator(slow)</code> 则是一个没有这些属性的包装器。</p><p>一些包装器可能会提供自己的属性。例如，装饰器会计算一个函数被调用了多少次以及花费了多少时间，并通过包装器属性公开（expose）这些信息。</p><p>存在一种创建装饰器的方法，该装饰器可保留对函数属性的访问权限，但这需要使用特殊的 <code>Proxy</code> 对象来包装函数。</p><h3 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h3><p>在将对象的方法作为回调进行传递 例如传递给<code>setTimeout</code>的时候 会存在一个常见的问题即是丢失<code>this</code></p><p>比如下面的情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;yueyun&#x27;</span>,</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(user.<span class="property">sayHi</span>, <span class="number">1000</span>) <span class="comment">// 输出 Hello,undefined</span></span><br></pre></td></tr></table></figure><p>这是因为<code>setTimeout</code>获取到了函数<code>user.sayHi</code> 但是他和对象分开了 <code>this</code>丢失了</p><p>解决办法 1 用函数包括执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;yueyun&#x27;</span>,</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  user.<span class="title function_">sayHi</span>()</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>这样即可以成功</p><p>但是这样又会存在 可能在定时器还在计时的过程中如果 <code>sayHi()</code> 函数发生变化 那么又会调用到错误的对象<code>this</code></p><p>解决办法 2 <strong>bind</strong><br><code>func.bind(context)</code>的结果是一个特殊的类似于函数的“外来对象”，它可以像函数一样被调用，并且透明地将调用传递给 <code>func</code> 并设定 <code>this=context</code>。</p><p>如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;yueyun&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> funcUser = func.<span class="title function_">bind</span>(user)</span><br><span class="line"><span class="title function_">funcUser</span>() <span class="comment">// hello yueyun</span></span><br></pre></td></tr></table></figure><p>上面例子的解法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;yueyun&#x27;</span>,</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.firstName&#125;</span>!`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user.<span class="property">sayHi</span> = user.<span class="property">sayHi</span>.<span class="title function_">bind</span>(user)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(user.<span class="property">sayHi</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">user = &#123;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Another user in setTimeout!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数不仅仅是编写简介代码的”捷径” 还具有非常特殊有用的特性</p><p>JavaScript 充满了我们需要编写在其他地方执行的小函数的情况</p><p>例如:</p><ul><li><code>arr.forEach(func)</code> 每个元素都执行<code>func</code></li><li><code>setTimeout(func)</code> 由内建调度器执行</li><li>….</li></ul><p>JavaScript 的精髓在于创建一个函数并将其传递到某个地方。</p><p>在这样的函数中，我们通常不想离开当前上下文。这就是箭头函数的应用场景</p><p><strong>箭头函数没有 this</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Our Group&#x27;</span>,</span><br><span class="line">  <span class="attr">students</span>: [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Pete&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>],</span><br><span class="line"></span><br><span class="line">  <span class="title function_">showList</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">students</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">student</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">title</span> + <span class="string">&#x27;: &#x27;</span> + student))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.<span class="title function_">showList</span>()</span><br></pre></td></tr></table></figure><p>这里<code>forEach</code>中使用了箭头函数 其中的<code>this.title</code> 其实和外部方法<code>showList</code>完全一样</p><p>如果我们使用正常的函数 则会出现错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Our Group&#x27;</span>,</span><br><span class="line">  <span class="attr">students</span>: [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Pete&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>],</span><br><span class="line"></span><br><span class="line">  <span class="title function_">showList</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">students</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">student</span>) &#123;</span><br><span class="line">      <span class="comment">// Error: Cannot read property &#x27;title&#x27; of undefined</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">title</span> + <span class="string">&#x27;: &#x27;</span> + student)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.<span class="title function_">showList</span>()</span><br></pre></td></tr></table></figure><p>报错是因为 <code>forEach</code> 运行它里面的这个函数，但是这个函数的 <code>this</code> 为默认值 <code>this=undefined</code>，因此就出现了尝试访问 <code>undefined.title</code> 的情况。但箭头函数就没事，因为它们没有 <code>this</code>。</p><div class="note warning simple"><p>warning 不能对箭头函数进行<code>new</code>操作 不具有<code>this</code>自然就意味着箭头函数不能作为构造(constructor)器</p></div><p><strong>箭头函数没有 arguments</strong></p><p>箭头函数也没有<code>arguments</code>变量</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="属性标志和属性描述符"><a href="#属性标志和属性描述符" class="headerlink" title="属性标志和属性描述符"></a>属性标志和属性描述符</h3><p>我们知道 对象可以存储属性到目前为止，属性对我们来说只是一个简单的“键值”对。但对象属性实际上是更灵活且更强大的东西。</p><h4 id="属性标志"><a href="#属性标志" class="headerlink" title="属性标志"></a>属性标志</h4><p>对象属性(properties) 是除了<code>value</code> 还有三个特殊的特性(attributes) 即标志</p><ul><li><code>writable</code> 如果是<code>true</code> 则值可以被修改 否则它是只可读的</li><li><code>enumerable</code> 如果是<code>true</code> 则值可以被枚举 否则不会被列出。</li><li><strong><code>configurable</code></strong> — 如果为 <code>true</code>，则此属性可以被删除，这些特性也可以被修改，否则不可以。</li></ul><p><code>Object.getOwnPropertyDescriptor</code>方法允许查询有关属性的<strong>完整</strong>信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;yueyun&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(user, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(descriptor, <span class="literal">null</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment">/* 属性描述符：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;value&quot;: &quot;yueyun&quot;,</span></span><br><span class="line"><span class="comment">  &quot;writable&quot;: true,</span></span><br><span class="line"><span class="comment">  &quot;enumerable&quot;: true,</span></span><br><span class="line"><span class="comment">  &quot;configurable&quot;: true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>为了修改标志,我们可以使用<code>Object.defineProperty</code></p><p>使用的语法是<code>Object.defineProperty(obj,propertyName,descriptor)</code></p><p><code>obj</code>,<code>propertyName</code> 要应用描述符的对象及其属性 <code>descriptor</code>要应用的属性描述符对象</p><p>如果该属性存在，<code>defineProperty</code> 会更新其标志。否则，它会使用给定的值和标志创建属性；在这种情况下，如果没有提供标志，则会假定它是 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(user, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;yueyun&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(user, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(descriptor, <span class="literal">null</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;value&quot;: &quot;John&quot;,</span></span><br><span class="line"><span class="comment">  &quot;writable&quot;: false,</span></span><br><span class="line"><span class="comment">  &quot;enumerable&quot;: false,</span></span><br><span class="line"><span class="comment">  &quot;configurable&quot;: false</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>将它与上面的“以常用方式创建的” <code>user.name</code> 进行比较：现在所有标志都为 <code>false</code>。如果这不是我们想要的，那么我们最好在 <code>descriptor</code> 中将它们设置为 <code>true</code>。</p><p>可以设置属性为: <strong>只读 不可枚举 不可配置</strong></p><p><code>Object.defineProperties</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(user, &#123;</span><br><span class="line">  <span class="attr">name</span>: &#123; <span class="attr">value</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  <span class="attr">surname</span>: &#123; <span class="attr">value</span>: <span class="string">&#x27;Smith&#x27;</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="设定一个全局的密封对象"><a href="#设定一个全局的密封对象" class="headerlink" title="设定一个全局的密封对象"></a>设定一个全局的密封对象</h4><ul><li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions">Object.preventExtensions(obj)</a></p><p>禁止向对象添加新属性。</p></li><li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal">Object.seal(obj)</a></p><p>禁止添加&#x2F;删除属性。为所有现有的属性设置 <code>configurable: false</code>。</p></li><li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze">Object.freeze(obj)</a></p><p>禁止添加&#x2F;删除&#x2F;更改属性。为所有现有的属性设置 <code>configurable: false, writable: false</code>。</p></li></ul><p>还有针对它们的测试：</p><ul><li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible">Object.isExtensible(obj)</a></p><p>如果添加属性被禁止，则返回 <code>false</code>，否则返回 <code>true</code>。</p></li><li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed">Object.isSealed(obj)</a></p><p>如果添加&#x2F;删除属性被禁止，并且所有现有的属性都具有 <code>configurable: false</code>则返回 <code>true</code>。</p></li><li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen">Object.isFrozen(obj)</a></p><p>如果添加&#x2F;删除&#x2F;更改属性被禁止，并且所有当前属性都是 <code>configurable: false, writable: false</code>，则返回 <code>true</code>。</p></li></ul><h3 id="对象属性配置"><a href="#对象属性配置" class="headerlink" title="对象属性配置"></a>对象属性配置</h3><h4 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter 和 setter"></a>getter 和 setter</h4><p>有两种类型的对象属性。</p><p>第一种是 <strong>数据属性</strong>。我们已经知道如何使用它们了。到目前为止，我们使用过的所有属性都是数据属性。</p><p>第二种类型的属性是新东西。它是 <strong>访问器属性（accessor property）</strong>。它们本质上是用于获取和设置值的函数，但从外部代码来看就像常规属性。</p><p>访问器属性由 “getter” 和 “setter” 方法表示。在对象字面量中，它们用 <code>get</code> 和 <code>set</code> 表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">propName</span>() &#123;</span><br><span class="line">    <span class="comment">// 当读取 obj.propName 时，getter 起作用</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">propName</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 当执行 obj.propName = value 操作时，setter 起作用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当读取 <code>obj.propName</code> 时，getter 起作用，当 <code>obj.propName</code> 被赋值时，setter 起作用。</p><p>例如，我们有一个具有 <code>name</code> 和 <code>surname</code> 属性的对象 <code>user</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;yue&#x27;</span>,</span><br><span class="line">  <span class="attr">surname</span>: <span class="string">&#x27;yun&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.surname&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">fullName</span>) <span class="comment">// yue yun</span></span><br></pre></td></tr></table></figure><p>从外表看，访问器属性看起来就像一个普通属性。这就是访问器属性的设计思想。我们不以函数的方式 <strong>调用</strong> <code>user.fullName</code>，我们正常 <strong>读取</strong> 它：getter 在幕后运行。</p><p>让我们通过为 <code>user.fullName</code> 添加一个 setter 来修改它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;yue&#x27;</span>,</span><br><span class="line">  <span class="attr">surname</span>: <span class="string">&#x27;yun&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.surname&#125;</span>`</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">fullName</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    ;[<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">surname</span>] = value.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set fullName 将以给定值执行</span></span><br><span class="line">user.<span class="property">fullName</span> = <span class="string">&#x27;me gumi&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">name</span>) <span class="comment">// me</span></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">surname</span>) <span class="comment">// gumi</span></span><br></pre></td></tr></table></figure><h4 id="访问器描述符"><a href="#访问器描述符" class="headerlink" title="访问器描述符"></a>访问器描述符</h4><p>访问器属性的描述符与数据属性的不同。</p><p>对于访问器属性，没有 <code>value</code> 和 <code>writable</code>，但是有 <code>get</code> 和 <code>set</code> 函数。</p><p>所以访问器描述符可能有：</p><ul><li><strong><code>get</code></strong> —— 一个没有参数的函数，在读取属性时工作，</li><li><strong><code>set</code></strong> —— 带有一个参数的函数，当属性被设置时调用，</li><li><strong><code>enumerable</code></strong> —— 与数据属性的相同，</li><li><strong><code>configurable</code></strong> —— 与数据属性的相同。</li></ul><p>例如上面的例子使用<code>defineProperty</code>创建一个<code>fullName</code>访问器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;yue&#x27;</span>,</span><br><span class="line">  <span class="attr">surname</span>: <span class="string">&#x27;yun&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(user, <span class="string">&#x27;fullName&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.surname&#125;</span>`</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    ;[<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">surname</span>] = value.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">fullName</span>) <span class="comment">// yue yun</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user) <span class="title function_">alert</span>(key) <span class="comment">// yue yun</span></span><br></pre></td></tr></table></figure><p>请注意，一个属性要么是访问器（具有 <code>get/set</code> 方法），要么是数据属性（具有 <code>value</code>），但不能两者都是。</p><p>如果我们试图在同一个描述符中同时提供 <code>get</code> 和 <code>value</code>，则会出现错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error: Invalid property descriptor.</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, <span class="string">&#x27;prop&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">value</span>: <span class="number">2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>在编程中我们经常会想获取并扩展一些东西</p><p>比如我们有一个<code>user</code>对象及其属性和方法,并希望将 <code>admin</code> 和 <code>guest</code> 作为基于 <code>user</code> 稍加修改的变体。我们想重用 <code>user</code> 中的内容，而不是复制&#x2F;重新实现它的方法，而只是在其之上构建一个新的对象。</p><p><strong>原型继承（Prototypal inheritance）</strong> 这个语言特性能够帮助我们实现这一需求。</p><h3 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h3><p>在 JavaScript 中 对象有特殊的隐藏属性[[Prototype]] 他们要么是<code>null</code> 要么就是在另一个对象中的引用 该对象称之为原型</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/javascriptlearing/10.png"></p><p>我们会从<code>Object</code>逐步的向上寻找 即原型继承属性 <code>[[Prototype]]</code> 是内部的而且是隐藏的，但是这儿有很多设置它的方式。其中之一就是使用特殊的名字 <code>__proto__</code>，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  <span class="attr">eats</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> rabbit = &#123;</span><br><span class="line">  <span class="attr">jumps</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rabbit.<span class="property">__proto__</span> = animal</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在这两个属性我们都能在 rabbit 中找到：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rabbit.<span class="property">eats</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rabbit.<span class="property">jumps</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>原型链可能会很长</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  <span class="attr">eats</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="title function_">walk</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Animal walk&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> rabbit = &#123;</span><br><span class="line">  <span class="attr">jumps</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">__proto__</span>: animal</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> longEar = &#123;</span><br><span class="line">  <span class="attr">earLength</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">__proto__</span>: rabbit</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// walk 是通过原型链获得的</span></span><br><span class="line">longEar.<span class="title function_">walk</span>() <span class="comment">// Animal walk</span></span><br><span class="line"><span class="title function_">alert</span>(longEar.<span class="property">jumps</span>) <span class="comment">// true（从 rabbit）</span></span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/javascriptlearing/11.png"></p><p>现在，如果我们从 <code>longEar</code> 中读取一些它不存在的内容，JavaScript 会先在 <code>rabbit</code> 中查找，然后在 <code>animal</code> 中查找。</p><p>这里只有两个限制：</p><ol><li>引用不能形成闭环。如果我们试图给 <code>__proto__</code> 赋值但会导致引用形成闭环时，JavaScript 会抛出错误。</li><li><code>__proto__</code> 的值可以是对象，也可以是 <code>null</code>。而其他的类型都会被忽略。</li></ol><p>当然，这可能很显而易见，但是仍然要强调：只能有一个 <code>[[Prototype]]</code>。一个对象不能从其他两个对象获得继承。</p><blockquote><p>注意: <strong><code>__proto__</code> 是 <code>[[Prototype]]</code> 的因历史原因而留下来的 getter&#x2F;setter</strong><br><code>__proto__</code>与内部的<code>[[Prototype]]</code>不一样 <code>__proto__</code> 是 <code>[[Prototype]]</code> 的 getter&#x2F;setter。<code>__proto__</code> 属性有点过时了。它的存在是出于历史的原因，现代编程语言建议我们应该使用函数 <code>Object.getPrototypeOf/Object.setPrototypeOf</code> 来取代 <code>__proto__</code> 去 get&#x2F;set 原型</p></blockquote><p>原型仅用于读取属性上,赋值操作是由<code>setter</code>函数去处理而 因此写入类属性实际上就是与调用函数相同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">surname</span>: <span class="string">&#x27;Smith&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">fullName</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    ;[<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">surname</span>] = value.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.surname&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: user,</span><br><span class="line">  <span class="attr">isAdmin</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(admin.<span class="property">fullName</span>) <span class="comment">// John Smith (*)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// setter triggers!</span></span><br><span class="line">admin.<span class="property">fullName</span> = <span class="string">&#x27;yue yun&#x27;</span> <span class="comment">// (**)</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(admin.<span class="property">fullName</span>) <span class="comment">// yue yun 的内容被修改了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">fullName</span>) <span class="comment">// John Smith，user 的内容被保护了</span></span><br></pre></td></tr></table></figure><p><code>Object.key(obj)</code>只会遍历当前的属性的值</p><p><code>for in</code> 会遍历当前的和继承的值 如果要判断是否是自己的可以使用<code>obj.hasOwnPropetry</code></p><details class="folding-tag" cyan><summary>总结</summary><div class="content"><ul><li>在 JavaScript 中，所有的对象都有一个隐藏的 <code>[[Prototype]]</code> 属性，它要么是另一个对象，要么就是 <code>null</code>。</li><li>我们可以使用 <code>obj.__proto__</code> 访问它（历史遗留下来的 getter&#x2F;setter，这儿还有其他方法，很快我们就会讲到）。</li><li>通过 <code>[[Prototype]]</code> 引用的对象被称为“原型”。</li><li>如果我们想要读取 <code>obj</code> 的一个属性或者调用一个方法，并且它不存在，那么 JavaScript 就会尝试在原型中查找它。</li><li>写&#x2F;删除操作直接在对象上进行，它们不使用原型（假设它是数据属性，不是 setter）。</li><li>如果我们调用 <code>obj.method()</code>，而且 <code>method</code> 是从原型中获取的，<code>this</code> 仍然会引用 <code>obj</code>。因此，方法始终与当前对象一起使用，即使方法是继承的。</li><li><code>for..in</code> 循环在其自身和继承的属性上进行迭代。所有其他的键&#x2F;值获取方法仅对对象本身起作用。</li></ul></div></details><h3 id="F-prototype"><a href="#F-prototype" class="headerlink" title="F.prototype"></a>F.prototype</h3><p>我们可以通过<code>new F()</code>这样的构造函数来创建一个新对象</p><p>如果<code>F.prototype</code>是一个对象, <code>new</code>操作符会使用它作为新对象设置<code>[[Prototype]]</code></p><p>这里的<code>F.prototype</code>指的是<code>F</code>的一个<code>prototype</code>的普通(常规)属性 如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  <span class="attr">eats</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Rabbit</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Rabbit</span>.<span class="property"><span class="keyword">prototype</span></span> = animal</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> <span class="title class_">Rabbit</span>(<span class="string">&#x27;white Rabbit&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rabbit.<span class="property">eats</span>)</span><br></pre></td></tr></table></figure><p>设置 <code>Rabbit.prototype = animal</code> 的字面意思是：“当创建了一个 <code>new Rabbit</code> 时，把它的 <code>[[Prototype]]</code> 赋值为 <code>animal</code>”。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/javascriptlearing/13.png"></p><p>在上图中，<code>&quot;prototype&quot;</code> 是一个水平箭头，表示一个常规属性，<code>[[Prototype]]</code> 是垂直的，表示 <code>rabbit</code> 继承自 <code>animal</code>。</p><blockquote><p><code>F.prototype</code>仅用在<code>new F</code>被调用时使用 它为新对象的[[Prototype]]赋值</p></blockquote><h4 id="默认的-F-prototype-构造器属性"><a href="#默认的-F-prototype-构造器属性" class="headerlink" title="默认的 F.prototype 构造器属性"></a>默认的 F.prototype 构造器属性</h4><p>每个函数都有 <code>&quot;prototype&quot;</code> 属性，即使我们没有提供它。默认的 <code>&quot;prototype&quot;</code> 是一个只有属性 <code>constructor</code> 的对象，属性 <code>constructor</code> 指向函数自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Rabbit</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 默认的 prototype</span></span><br><span class="line"><span class="comment">Rabbit.prototype = &#123; constructor: Rabbit &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Rabbit</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 默认：</span></span><br><span class="line"><span class="comment">// Rabbit.prototype = &#123; constructor: Rabbit &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Rabbit</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> == <span class="title class_">Rabbit</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Rabbit</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 默认：</span></span><br><span class="line"><span class="comment">// Rabbit.prototype = &#123; constructor: Rabbit &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> <span class="title class_">Rabbit</span>() <span class="comment">// 继承自 &#123;constructor: Rabbit&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rabbit.<span class="property">constructor</span> == <span class="title class_">Rabbit</span>) <span class="comment">// true (from prototype)</span></span><br></pre></td></tr></table></figure><ul><li><code>F.prototype</code> 属性（不要把它与 <code>[[Prototype]]</code> 弄混了）在 <code>new F</code> 被调用时为新对象的 <code>[[Prototype]]</code> 赋值。</li><li><code>F.prototype</code> 的值要么是一个对象，要么就是 <code>null</code>：其他值都不起作用。</li><li><code>&quot;prototype&quot;</code> 属性仅当设置在一个构造函数上，并通过 <code>new</code> 调用时，才具有这种特殊的影响。</li></ul><h3 id="原生的原型"><a href="#原生的原型" class="headerlink" title="原生的原型"></a>原生的原型</h3><p><code>prototype</code>属性在 JavaScript 中广泛的使用 所有而内建构造函数都使用到了它</p><h4 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="title function_">alert</span>(obj) <span class="comment">// &quot;[object Object]&quot;?</span></span><br></pre></td></tr></table></figure><p>内建的<code>toString</code>生成了字符串<code>[object object]</code> <code>obj = &#123;&#125;</code> 和 <code>obj = new Object()</code> 是一个意思，其中 <code>Object</code> 就是一个内建的对象构造函数，其自身的 <code>prototype</code> 指向一个带有 <code>toString</code> 和其他方法的一个巨大的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">toString</span> === obj.<span class="property">__proto__</span>.<span class="property">toString</span>) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">toString</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="其他内建原型"><a href="#其他内建原型" class="headerlink" title="其他内建原型"></a>其他内建原型</h4><p>例如: <code>Array</code> <code>Date</code> <code>Function</code>及其他,都在<code>prototype</code>上挂载了方法</p><p>当我们创建一个数组 <code>[1, 2, 3]</code>，在内部会默认使用 <code>new Array()</code> 构造器。因此 <code>Array.prototype</code> 变成了这个数组的 prototype，并为这个数组提供数组的操作方法。这样内存的存储效率是很高的。所有的内建原型顶端都是 <code>Object.prototype</code>。这就是为什么有人说“一切都从对象继承而来”。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/javascriptlearing/12.png"></p><p>经过下面验证</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 它继承自 Array.prototype？</span></span><br><span class="line"><span class="title function_">alert</span>(arr.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来继承自 Object.prototype？</span></span><br><span class="line"><span class="title function_">alert</span>(arr.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链的顶端为 null。</span></span><br><span class="line"><span class="title function_">alert</span>(arr.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>一些方法在原型上可能会发生重叠，例如，<code>Array.prototype</code> 有自己的 <code>toString</code> 方法来列举出来数组的所有元素并用逗号分隔每一个元素。</p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>最复杂的事情发生在字符串、数字和布尔值上。<br>正如我们记忆中的那样，它们并不是对象。但是如果我们试图访问它们的属性，那么临时包装器对象将会通过内建的构造器 <code>String</code>、<code>Number</code> 和 <code>Boolean</code> 被创建。它们提供给我们操作字符串、数字和布尔值的方法然后消失。<br>这些对象对我们来说是无形地创建出来的。大多数引擎都会对其进行优化，但是规范中描述的就是通过这种方式。这些对象的方法也驻留在它们的 prototype 中，可以通过 <code>String.prototype</code>、<code>Number.prototype</code> 和 <code>Boolean.prototype</code> 进行获取。</p><div class="note warning simple"><p>值<code>null</code>和<code>undefined</code>没有对象包装器.并且它们也没有相应的原型。</p></div><h4 id="更改原生原型"><a href="#更改原生原型" class="headerlink" title="更改原生原型"></a>更改原生原型</h4><p>在开发的过程中，我们可能会想要一些新的内建方法，并且想把它们添加到原生原型中。但这通常是一个很不好的想法。</p><blockquote><p>原型是全局的，所以很容易造成冲突。如果有两个库都添加了 <code>String.prototype.show</code> 方法，那么其中的一个方法将被另一个覆盖。</p><p>所以，通常来说，修改原生原型被认为是一个很不好的想法。</p></blockquote><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="class-语法"><a href="#class-语法" class="headerlink" title="class 语法"></a>class 语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">  <span class="title function_">method1</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">  <span class="title function_">method2</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">  <span class="title function_">method3</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>new MyClass()</code>来创建具有上述方法的新对象</p><p><code>new</code> 会自动调用 <code>constructor()</code> 方法，因此我们可以在 <code>constructor()</code> 中初始化对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>JavaScript</code>中 类其实是一种函数 在<code>ES6</code>中增加了类而关键字是一种新的语法糖放其更加方便直观的创建想要的类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">User</span>) <span class="comment">// function</span></span><br></pre></td></tr></table></figure><p><code>class User&#123;...&#125;</code>构造实际是完成了下面的事</p><ul><li>创建一个名为<code>User</code>的函数 该函数为类声明的结果 该函数的代码来自于<code>constructor</code>方法</li><li>存储类中的方法 例如<code>User.prototype</code>中的<code>sayHi</code></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/post_img/javascriptlearing/14.png"></p><p>如下面的代码解释</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class 是一个函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">User</span>) <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...或者，更确切地说，是 constructor 方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">User</span> === <span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法在 User.prototype 中，例如：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span>) <span class="comment">// sayHi 方法的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在原型中实际上有两个方法</span></span><br><span class="line">consoe.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>)) <span class="comment">// constructor, sayHi</span></span><br></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a><code>try catch</code></h3><p>通常我们在编写脚本的时候总是会遇到很多非预期的错误 导致脚本停止执行，有一种语法结构 <code>try...catch</code>，它使我们可以“捕获（catch）”错误，因此脚本可以执行更合理的操作，而不是死掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ...try to execute the code...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="comment">// ...handle errors...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先执行<code>try &#123;...&#125;</code>中的代码</li><li>如果没有错误，那么就跳过<code>catch(err)</code>中的代码，继续执行，<code>try</code>中的代码执行完毕</li><li>如果出现错误，那么<code>try</code>中剩下的代码停止执行，控制台执行<code>catch(err)</code>中的代码，<code>catch</code>中的代码将包含一个<strong>error 的对象</strong>执行完毕</li></ol><h3 id="Error对象"><a href="#Error对象" class="headerlink" title="Error对象"></a>Error对象</h3><p>发生错误时，JavaScript 会生成一个包含有关此 error 详细信息的对象。然后将该对象作为参数传递给 <code>catch</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123; <span class="comment">// &lt;-- “error 对象”，也可以用其他参数名代替 err</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>name</code>: Error的名称 例如一个未定义的变量则报错是<code>ReferenceError</code></li><li><code>message</code>: 关于error的详细文字描述</li><li><code>stack</code>: 当前的单调栈 用于调试</li></ul><h3 id="抛出自定义的Error"><a href="#抛出自定义的Error" class="headerlink" title="抛出自定义的Error"></a>抛出自定义的Error</h3><p><strong>throw操作符</strong></p><p><code>throw</code>操作符会生成一个error对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="language-xml"><span class="tag">&lt;<span class="name">error</span> <span class="attr">object</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>技术上讲，我们可以将任何东西用作 error 对象。甚至可以是一个原始类型数据，例如数字或字符串，但最好使用对象，最好使用具有 <code>name</code> 和 <code>message</code> 属性的对象（某种程度上保持与内建 error 的兼容性）。JavaScript 中有很多内建的标准 error 的构造器：<code>Error</code>，<code>SyntaxError</code>，<code>ReferenceError</code>，<code>TypeError</code> 等。我们也可以使用它们来创建 error 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> error = <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">let</span> error = <span class="keyword">new</span> <span class="title class_">SyntaxError</span>(message);</span><br><span class="line"><span class="keyword">let</span> error = <span class="keyword">new</span> <span class="title class_">ReferenceError</span>(message);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="再次抛出-Rethrowing"><a href="#再次抛出-Rethrowing" class="headerlink" title="再次抛出(Rethrowing)"></a>再次抛出(Rethrowing)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">&#x27;&#123; &quot;age&quot;: 30 &#125;&#x27;</span>; <span class="comment">// 不完整的数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> user = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(json);</span><br><span class="line">  <span class="keyword">if</span> (!user.<span class="property">name</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SyntaxError</span>(<span class="string">&quot;数据不全：没有 name&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">blabla</span>(); <span class="comment">// 预料之外的 error</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( user.<span class="property">name</span> );</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="title class_">SyntaxError</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;JSON Error: &quot;</span> + err.<span class="property">message</span> );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> err; <span class="comment">// 再次抛出 (*)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="try…catch…finally"><a href="#try…catch…finally" class="headerlink" title="try…catch…finally"></a>try…catch…finally</h3><p><code>try...catch</code> 结构可能还有一个代码子句（clause）：<code>finally</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   ... 尝试执行的代码 ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">   ... 处理 error ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   ... 总是会执行的代码 ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义Error-扩展Error"><a href="#自定义Error-扩展Error" class="headerlink" title="自定义Error,扩展Error"></a>自定义Error,扩展Error</h3><p>当我们开发项目时,经常需要我们自己定义error类来反映任务中可能出错的特定任务, 对于网络操作中的error 我们需要<code>HttpError</code> 对于数据库操作中的error 我们需要<code>DbError</code>,对于搜索操作的error 我们需要<code>NotFoundError</code></p><p>我们自定义的 error 应该支持基本的 error 的属性，例如 <code>message</code>，<code>name</code>，并且最好还有 <code>stack</code>。但是它们也可能会有其他属于它们自己的属性，例如，<code>HttpError</code> 对象可能会有一个 <code>statusCode</code> 属性，属性值可能为 <code>404</code>、<code>403</code> 或 <code>500</code> 等。</p><h4 id="扩展Error"><a href="#扩展Error" class="headerlink" title="扩展Error"></a>扩展Error</h4><p>如果我们需要使用json去检查是否存在某个数据我们现在规定成<code>ValidationError</code></p><p>Error类是内建的 结构类似如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript 自身定义的内建的 Error 类的“伪代码”</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span> (message) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">message</span> = message</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Error&quot;</span> <span class="comment">// (不同的内建error类拥有不同的名字)</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack</span> = <span class="language-xml"><span class="tag">&lt;<span class="name">call</span> <span class="attr">stack</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure><p>现在让我们从其中继承 <code>ValidationError</code>，并尝试进行运行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ValidationError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span> (message) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(message) </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;ValidationError&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ValidationError</span>(<span class="string">&quot;Explosion!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">test</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>); <span class="comment">// Explosion!</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">name</span>); <span class="comment">// ValidationError</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">stack</span>); <span class="comment">// 一个嵌套调用的列表，每个调用都有对应的行号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深入继承"><a href="#深入继承" class="headerlink" title="深入继承"></a>深入继承</h4><p><code>ValidationError</code>类是非常通用的 很多东西都可能出错 对象的属性可能缺失或者属性可能有格式错误,让我们针对缺少属性的错误来制作一个更具体的 <code>PropertyRequiredError</code> 类。它将携带有关缺少的属性的相关信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ValidationError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">message</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(message)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;ValidationError&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PropertyRequiredError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ValidationError</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">property</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(<span class="string">&quot;No property:&quot;</span> + property)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;PropertyRequiredError&quot;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">property</span> = property</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readUser</span>(<span class="params">json</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(json)</span><br><span class="line">    <span class="keyword">if</span>(!user.<span class="property">age</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PropertyRequiredError</span>(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!user.<span class="property">name</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PropertyRequiredError</span>(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> user = <span class="title function_">readUser</span>(<span class="string">&#x27;&#123;&quot;age&quot;: 25&#125;&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="title class_">ValidationError</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Invalid data&quot;</span> + err.<span class="property">message</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">name</span>)</span><br><span class="line">        consoe.<span class="title function_">log</span>(err.<span class="property">property</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(err <span class="keyword">instanceof</span> <span class="title class_">SyntaxError</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JSON Syntax Error:&quot;</span> + err.<span class="property">message</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个新的类 <code>PropertyRequiredError</code> 使用起来很简单：我们只需要传递属性名：<code>new PropertyRequiredError(property)</code>。人类可读的 <code>message</code> 是由 constructor 生成的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(message);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="variable language_">this</span>.<span class="property">constructor</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ValidationError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">MyError</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PropertyRequiredError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ValidationError</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">property</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(<span class="string">&quot;No property: &quot;</span> + property);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">property</span> = property;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name 是对的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="keyword">new</span> <span class="title class_">PropertyRequiredError</span>(<span class="string">&quot;field&quot;</span>).<span class="property">name</span> ); <span class="comment">// PropertyRequiredError</span></span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h3><p>常规函数只会返回一个单一值 (或者不返回任何值)</p><p>而 generator 可以按需一个接一个地返回yield多个值。它们可与iterable完美配合使用，从而可以轻松地创建数据流。</p><h3 id="generator函数"><a href="#generator函数" class="headerlink" title="generator函数"></a>generator函数</h3><p>要创建一个generator 我们需要一个特殊语法结构: <code>function *</code> 即所谓的<code>generator function</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* generateSequence () &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>generator</code>函数与常规函数的行为不同 在此类函数被调用时 他不会运行其代码.而是返回一个被称为 “generator object” 的特殊对象，来管理执行流程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generateSequence</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;generator function&quot; 创建了一个 &quot;generator object&quot;</span></span><br><span class="line"><span class="keyword">let</span> generator = <span class="title function_">generateSequence</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator) <span class="comment">//Object [Generator] &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>到现在为止 上段代码中的<strong>函数体</strong>代码并没有开始执行<br>一个 generator 的主要方法就是 <code>next()</code>。当被调用时，它会恢复运行，执行直到最近的 <code>yield &lt;value&gt;</code> 语句（<code>value</code> 可以被省略，默认为 <code>undefined</code>）。然后函数执行暂停，并将产出的（yielded）值返回到外部代码。</p><p><code>next()</code>的结果始终是一个具有两个属性的对象:</p><ul><li><code>value</code>: 产出的(yielded)的值</li><li><code>done</code>: 如果generator函数已执行完成则为<code>true</code>否则为<code>false</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generateSequence</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;generator function&quot; 创建了一个 &quot;generator object&quot;</span></span><br><span class="line"><span class="keyword">let</span> generator = <span class="title function_">generateSequence</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>())<span class="keyword">function</span>* <span class="title function_">generateSequence</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;generator function&quot; 创建了一个 &quot;generator object&quot;</span></span><br><span class="line"><span class="keyword">let</span> generator = <span class="title function_">generateSequence</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>()) <span class="comment">//&#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>()) <span class="comment">//&#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>()) <span class="comment">//&#123; value: 3, done: true &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>()) <span class="comment">//&#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h2 id="模块导入导出"><a href="#模块导入导出" class="headerlink" title="模块导入导出"></a>模块导入导出</h2><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><h1 id="浏览器中的-JS"><a href="#浏览器中的-JS" class="headerlink" title="浏览器中的 JS"></a>浏览器中的 JS</h1><h1 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h1></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/yueyun.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/yueyun.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">月晕</div><div class="post-copyright__author_desc">生命是有光的</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.yueyun.site/posts/b79900c3.html">原创</a><a class="post-copyright-title"><span onclick='rm.copyPageUrl("https://blog.yueyun.site/posts/b79900c3.html")'>JavaScript语言学习</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.yueyun.site/posts/b79900c3.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><script>function copyCurrentPageUrl(){var e=window.location.href,t=document.createElement("input");t.setAttribute("value",e),document.body.appendChild(t),t.select(),t.setSelectionRange(0,99999),document.execCommand("copy"),document.body.removeChild(t)}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.yueyun.site" target="_blank">月晕</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="categoryes-punctuation"><i class="anzhiyufont anzhiyu-icon-inbox"></i></span>编程语言<span class="categoryesPageCount">2</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/JavaScript/"><span class="tags-punctuation"><i class="anzhiyufont anzhiyu-icon-tag"></i></span>JavaScript<span class="tagsPageCount">9</span></a></div></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/7537191c.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1700562858285.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Nginx基本用法</div></div></a></div><div class="next-post pull-right"><a href="/posts/86f0144.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/-2dd5081fe43bb90a.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">git、PM2、Linux指令使用合集</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size:1.5rem;margin-right:4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/7251401c.html" title="NestJS学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/qiuqiunile.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-28</div><div class="title">NestJS学习</div></div></a></div><div><a href="/posts/938f2f9c.html" title="React Native开坑"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1702557508740.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-15</div><div class="title">React Native开坑</div></div></a></div><div><a href="/posts/9ac48510.html" title="React学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1701613946910.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-12</div><div class="title">React学习</div></div></a></div><div><a href="/posts/49ae955a.html" title="React 源码分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/wallpaper/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-15</div><div class="title">React 源码分析</div></div></a></div><div><a href="/posts/d681bdaf.html" title="TypeScript语言学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/liang.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-22</div><div class="title">TypeScript语言学习</div></div></a></div><div><a href="/posts/317b894e.html" title="Vue学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1702396713207.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-12</div><div class="title">Vue学习</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)" style="display:none">匿名评论</a><a href="/privacy" style="margin-left:4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/yueyun.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"><div class="author-info__decoration"><img class="avatar-decoration-1" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/avatar_desc/avatar_d1.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="decoration"><img class="avatar-decoration-2" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/avatar_desc/avatar_d2.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="decoration"><img class="avatar-decoration-3" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/avatar_desc/avatar_d3.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="decoration"><img class="avatar-decoration-4" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/avatar_desc/avatar_d4.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="decoration"></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><h1 class="author-info__name">月晕</h1><div class="author-info__desc">生命是有光的</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=3514392356&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="anzhiyufont anzhiyu-icon-qq"></i></a><a class="social-icon faa-parent animated-hover" href="https://github.com/apprehen" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/554370301" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVASCRIPT-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">JAVASCRIPT 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84-JavaScript-%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">浏览器中的 JavaScript 能做什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E7%9A%84%E4%B8%8A%E5%B1%82%E8%AF%AD%E8%A8%80"><span class="toc-number">1.2.</span> <span class="toc-text">JavaScript 的上层语言</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">JavaScript 中的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Number"><span class="toc-number">2.1.1.</span> <span class="toc-text">Number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-number">2.1.2.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">字符串中的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8"><span class="toc-number">2.1.2.1.1.</span> <span class="toc-text">常用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%B8%B8%E7%94%A8"><span class="toc-number">2.1.2.1.2.</span> <span class="toc-text">不常用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boolean-%E9%80%BB%E8%BE%91%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.3.</span> <span class="toc-text">Boolean(逻辑类型)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E8%BD%AC%E6%8D%A2%E6%97%B6"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">布尔转换时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">逻辑运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%96%E8%BF%90%E7%AE%97"><span class="toc-number">2.1.3.2.1.</span> <span class="toc-text">或运算(||)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="toc-number">2.1.3.2.2.</span> <span class="toc-text">与运算(&amp;&amp;)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E8%BF%90%E7%AE%97"><span class="toc-number">2.1.3.2.3.</span> <span class="toc-text">非运算(!)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E6%AF%94%E8%BE%83"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">值比较</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89"><span class="toc-number">2.1.3.3.1.</span> <span class="toc-text">严格相等</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#null%E5%92%8Cundefined%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83"><span class="toc-number">2.1.3.3.2.</span> <span class="toc-text">null和undefined进行比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%92%8C-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.1.3.3.3.</span> <span class="toc-text">?和??运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Null"><span class="toc-number">2.1.4.</span> <span class="toc-text">Null</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Undefined"><span class="toc-number">2.1.5.</span> <span class="toc-text">Undefined</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol"><span class="toc-number">2.1.6.</span> <span class="toc-text">Symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">隐藏属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E4%B8%AD%E7%9A%84-symbol"><span class="toc-number">2.1.6.2.</span> <span class="toc-text">对象字面量中的 symbol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbol-%E4%BC%9A%E5%9C%A8-for-in-%E4%B8%AD%E8%B7%B3%E8%BF%87"><span class="toc-number">2.1.6.3.</span> <span class="toc-text">Symbol 会在 for in 中跳过</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80-Symbol"><span class="toc-number">2.1.6.4.</span> <span class="toc-text">全局 Symbol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbol-keyFor"><span class="toc-number">2.1.6.5.</span> <span class="toc-text">Symbol.keyFor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigInt"><span class="toc-number">2.1.7.</span> <span class="toc-text">BigInt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object"><span class="toc-number">2.1.8.</span> <span class="toc-text">Object</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.1.8.1.</span> <span class="toc-text">Object 表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E5%A4%8D%E5%88%B6"><span class="toc-number">2.1.8.2.</span> <span class="toc-text">Object 的引用和复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-%E4%B8%AD%E7%9A%84-this"><span class="toc-number">2.1.8.3.</span> <span class="toc-text">Object 中的 this</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84this"><span class="toc-number">2.1.8.3.1.</span> <span class="toc-text">方法中的this</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%B2%A1%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84this"><span class="toc-number">2.1.8.3.2.</span> <span class="toc-text">箭头函数没有自己的this</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E9%93%BE%EF%BC%9F"><span class="toc-number">2.1.8.4.</span> <span class="toc-text">可选链？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Javascript-%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">Javascript 中的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">原始类型的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">数组中的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterable-object-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.3.</span> <span class="toc-text">Iterable object(可迭代对象)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbol-iterator"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">Symbol.iterator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%AD%E4%BB%A3"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">字符串迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E8%B0%83%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.2.3.3.</span> <span class="toc-text">显示调用迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-from"><span class="toc-number">2.2.3.4.</span> <span class="toc-text">Array.from</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map-%E5%92%8C-Set-%E6%98%A0%E5%B0%84%E5%92%8C%E9%9B%86%E5%90%88"><span class="toc-number">2.3.</span> <span class="toc-text">Map 和 Set(映射和集合)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">2.3.1.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-%E8%BF%AD%E4%BB%A3"><span class="toc-number">2.3.2.</span> <span class="toc-text">Map 迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.3.</span> <span class="toc-text">Map 和对象的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">2.3.4.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-%E8%BF%AD%E4%BB%A3-iteration"><span class="toc-number">2.3.5.</span> <span class="toc-text">Set 迭代(iteration)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakMap-%E5%92%8C-WeakSet"><span class="toc-number">2.3.6.</span> <span class="toc-text">WeakMap 和 WeakSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WeakMap"><span class="toc-number">2.3.6.1.</span> <span class="toc-text">WeakMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WeakSet"><span class="toc-number">2.3.6.2.</span> <span class="toc-text">WeakSet</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">2.4.</span> <span class="toc-text">解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84"><span class="toc-number">2.4.1.</span> <span class="toc-text">数组解构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-number">2.4.2.</span> <span class="toc-text">对象解构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E8%A7%A3%E6%9E%84"><span class="toc-number">2.4.3.</span> <span class="toc-text">嵌套解构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">2.4.4.</span> <span class="toc-text">智能函数参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON-%E6%96%B9%E6%B3%95-toJSON"><span class="toc-number">2.5.</span> <span class="toc-text">JSON 方法 toJSON</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON-stringify"><span class="toc-number">2.5.1.</span> <span class="toc-text">JSON.stringify</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON-parse"><span class="toc-number">2.5.2.</span> <span class="toc-text">JSON.parse</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%84%E8%8C%83%E5%92%8C%E8%B0%83%E8%AF%95"><span class="toc-number">3.</span> <span class="toc-text">规范和调试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%86%85%E5%AE%B9"><span class="toc-number">4.</span> <span class="toc-text">高级内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">4.1.1.</span> <span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%A0%86%E6%A0%88"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">执行上下文和堆栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rest-%E5%8F%82%E6%95%B0%E5%92%8C-Spread-%E8%AF%AD%E6%B3%95"><span class="toc-number">4.1.2.</span> <span class="toc-text">Rest 参数和 Spread 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85"><span class="toc-number">4.1.3.</span> <span class="toc-text">变量作用域和闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">嵌套函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83"><span class="toc-number">4.1.3.3.</span> <span class="toc-text">词法环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">4.1.3.4.</span> <span class="toc-text">垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.1.4.</span> <span class="toc-text">全局对象和函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.1.4.1.</span> <span class="toc-text">全局对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.1.4.2.</span> <span class="toc-text">函数对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.1.4.3.</span> <span class="toc-text">命名函数的表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%EF%BC%9AsetTimeout-%E5%92%8C-setInterval"><span class="toc-number">4.1.5.</span> <span class="toc-text">调度：setTimeout 和 setInterval</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%BD%AC%E5%8F%91%EF%BC%9ACall-apply"><span class="toc-number">4.1.6.</span> <span class="toc-text">装饰器模式和转发：Call&#x2F;apply</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E7%BC%93%E5%AD%98"><span class="toc-number">4.1.6.0.1.</span> <span class="toc-text">透明缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#function-call-%E8%AE%BE%E5%AE%9A%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">4.1.6.0.2.</span> <span class="toc-text">function.call 设定上下文</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.6.0.3.</span> <span class="toc-text">传递多个参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#function-apply"><span class="toc-number">4.1.6.0.4.</span> <span class="toc-text">function.apply</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E5%B1%9E%E6%80%A7%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.6.0.5.</span> <span class="toc-text">装饰器和属性函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="toc-number">4.1.7.</span> <span class="toc-text">函数绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.8.</span> <span class="toc-text">箭头函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.2.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%A0%87%E5%BF%97%E5%92%8C%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">4.2.1.</span> <span class="toc-text">属性标志和属性描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%A0%87%E5%BF%97"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">属性标志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E7%9A%84%E5%AF%86%E5%B0%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">设定一个全局的密封对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE"><span class="toc-number">4.2.2.</span> <span class="toc-text">对象属性配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#getter-%E5%92%8C-setter"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">getter 和 setter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%99%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">访问器描述符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">原型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Prototype"><span class="toc-number">4.3.1.</span> <span class="toc-text">Prototype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#F-prototype"><span class="toc-number">4.3.2.</span> <span class="toc-text">F.prototype</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%9A%84-F-prototype-%E6%9E%84%E9%80%A0%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">默认的 F.prototype 构造器属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="toc-number">4.3.3.</span> <span class="toc-text">原生的原型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-prototype"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">Object.prototype</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%86%85%E5%BB%BA%E5%8E%9F%E5%9E%8B"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">其他内建原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.3.3.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E5%8E%9F%E7%94%9F%E5%8E%9F%E5%9E%8B"><span class="toc-number">4.3.3.4.</span> <span class="toc-text">更改原生原型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">4.4.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#class-%E8%AF%AD%E6%B3%95"><span class="toc-number">4.4.1.</span> <span class="toc-text">class 语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">4.5.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#try-catch"><span class="toc-number">4.5.1.</span> <span class="toc-text">try catch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.5.2.</span> <span class="toc-text">Error对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84Error"><span class="toc-number">4.5.3.</span> <span class="toc-text">抛出自定义的Error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E6%AC%A1%E6%8A%9B%E5%87%BA-Rethrowing"><span class="toc-number">4.5.4.</span> <span class="toc-text">再次抛出(Rethrowing)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try%E2%80%A6catch%E2%80%A6finally"><span class="toc-number">4.5.5.</span> <span class="toc-text">try…catch…finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Error-%E6%89%A9%E5%B1%95Error"><span class="toc-number">4.5.6.</span> <span class="toc-text">自定义Error,扩展Error</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95Error"><span class="toc-number">4.5.6.1.</span> <span class="toc-text">扩展Error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%BB%A7%E6%89%BF"><span class="toc-number">4.5.6.2.</span> <span class="toc-text">深入继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.6.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#generator"><span class="toc-number">4.6.1.</span> <span class="toc-text">generator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#generator%E5%87%BD%E6%95%B0"><span class="toc-number">4.6.2.</span> <span class="toc-text">generator函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA"><span class="toc-number">4.7.</span> <span class="toc-text">模块导入导出</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-number">5.</span> <span class="toc-text">异步</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84-JS"><span class="toc-number">6.</span> <span class="toc-text">浏览器中的 JS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NodeJS"><span class="toc-number">7.</span> <span class="toc-text">NodeJS</span></a></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/f2d319ed.html" title="有用的网站资源整合"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/1705040055654.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="有用的网站资源整合"></a><div class="content"><a class="title" href="/posts/f2d319ed.html" title="有用的网站资源整合">有用的网站资源整合</a><time datetime="2024-01-17T11:24:35.636Z" title="发表于 2024-01-17 11:24:35">2024-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ac8590ca.html" title="go 语言速成"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/5370198c46b7e6193aad423d755464fd5aa83820_raw.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="go 语言速成"></a><div class="content"><a class="title" href="/posts/ac8590ca.html" title="go 语言速成">go 语言速成</a><time datetime="2024-01-16T13:38:42.000Z" title="发表于 2024-01-16 13:38:42">2024-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/9c0aba3e.html" title="leetcode 刷题(每日一题) 记录"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/wallpaper/1703262863447.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="leetcode 刷题(每日一题) 记录"></a><div class="content"><a class="title" href="/posts/9c0aba3e.html" title="leetcode 刷题(每日一题) 记录">leetcode 刷题(每日一题) 记录</a><time datetime="2023-12-27T10:47:16.000Z" title="发表于 2023-12-27 10:47:16">2023-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d681bdaf.html" title="TypeScript语言学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/postCover/liang.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="TypeScript语言学习"></a><div class="content"><a class="title" href="/posts/d681bdaf.html" title="TypeScript语言学习">TypeScript语言学习</a><time datetime="2023-12-22T17:46:54.000Z" title="发表于 2023-12-22 17:46:54">2023-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/49ae955a.html" title="React 源码分析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1301952160.cos.ap-shanghai.myqcloud.com/Apprehensive/wallpaper/2.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="React 源码分析"></a><div class="content"><a class="title" href="/posts/49ae955a.html" title="React 源码分析">React 源码分析</a><time datetime="2023-12-15T02:05:37.000Z" title="发表于 2023-12-15 02:05:37">2023-12-15</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/apprehen" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/apprehen" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/apprehen" title="facebook"><i class="anzhiyufont anzhiyu-icon-facebook1"></i></a><a class="deal_link" href="/atom.xml" title="RSS"><i class="anzhiyufont anzhiyu-icon-rss"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0,500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/yueyun.jpg" size="50px"><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/apprehen" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/apprehen" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/apprehen" title="抖音"><i class="anzhiyufont anzhiyu-icon-tiktok"></i></a><a class="deal_link" href="/copyright" title="CC"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i></a></div><div class="copyright">&copy;2023 - 2024 By 月晕</div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">14</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>留言</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size:.9em"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size:.9em"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size:.9em"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size:.9em"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Clash/" style="font-size:.88rem">Clash<sup>1</sup></a><a href="/tags/Git/" style="font-size:.88rem">Git<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size:.88rem">JavaScript<sup>9</sup></a><a href="/tags/Linux/" style="font-size:.88rem">Linux<sup>2</sup></a><a href="/tags/NestJS/" style="font-size:.88rem">NestJS<sup>1</sup></a><a href="/tags/Nginx/" style="font-size:.88rem">Nginx<sup>1</sup></a><a href="/tags/PM2/" style="font-size:.88rem">PM2<sup>1</sup></a><a href="/tags/Python/" style="font-size:.88rem">Python<sup>1</sup></a><a href="/tags/React/" style="font-size:.88rem">React<sup>3</sup></a><a href="/tags/React-Native/" style="font-size:.88rem">React Native<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size:.88rem">TypeScript<sup>1</sup></a><a href="/tags/Vite/" style="font-size:.88rem">Vite<sup>1</sup></a><a href="/tags/Vue/" style="font-size:.88rem">Vue<sup>2</sup></a><a href="/tags/go/" style="font-size:.88rem">go<sup>1</sup></a><a href="/tags/leetcode/" style="font-size:.88rem">leetcode<sup>1</sup></a><a href="/tags/vscode/" style="font-size:.88rem">vscode<sup>1</sup></a><a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size:.88rem">代理<sup>1</sup></a><a href="/tags/%E5%85%AB%E8%82%A1/" style="font-size:.88rem">八股<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size:.88rem;font-weight:500;color:var(--anzhiyu-lighttext)">前端<sup>7</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" style="font-size:.88rem">前端框架<sup>2</sup></a><a href="/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/" style="font-size:.88rem">反向代理<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size:.88rem">后端<sup>2</sup></a><a href="/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/" style="font-size:.88rem">打包工具<sup>1</sup></a><a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size:.88rem">插件<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size:.88rem">数据结构<sup>2</sup></a><a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" style="font-size:.88rem">浏览器工作原理<sup>1</sup></a><a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size:.88rem">源码分析<sup>2</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size:.88rem">爬虫<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size:.88rem">算法<sup>1</sup></a><a href="/tags/%E7%BC%96%E8%BE%91%E5%99%A8/" style="font-size:.88rem">编辑器<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" style="font-size:.88rem">计算机<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size:.88rem;font-weight:500;color:var(--anzhiyu-lighttext)">计算机基础<sup>3</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size:.88rem">计算机操作系统<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size:.88rem">计算机网络<sup>1</sup></a><a href="/tags/%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/" style="font-size:.88rem">资源整合<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size:.88rem">面试题<sup>1</sup></a></div></div><hr></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size:1rem"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display:none"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://chat.yueyun.site',
      region: 'ap-hangzhou',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.21/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://chat.yueyun.site',
      region: 'ap-hangzhou',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: true,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', 'G-W3DLGJMJDY', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginModelPath:"assets/",model:{jsonPath:"/live2dw/assets/unitychan.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html>